<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《编写高质量代码(改善Java程序的151个建议)》读书笔记 - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mp.weixin.qq.com/img/头像.jpg"><meta property="article:published_time" content="2018-11-22T00:31:03.000Z"><meta property="article:modified_time" content="2023-06-21T11:25:59.033Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="JAVA"><meta property="article:tag" content="代码优化"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2018/11/22/Java/%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81(%E6%94%B9%E5%96%84Java%E7%A8%8B%E5%BA%8F%E7%9A%84151%E4%B8%AA%E5%BB%BA%E8%AE%AE)%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"headline":"山河已无恙","image":["https://liruilongs.github.io/img/og_image.png"],"datePublished":"2018-11-22T00:31:03.000Z","dateModified":"2023-06-21T11:25:59.033Z","author":{"@type":"Person","name":"山河已无恙"},"description":"时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》"}</script><link rel="canonical" href="https://liruilongs.github.io/2018/11/22/Java/%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81(%E6%94%B9%E5%96%84Java%E7%A8%8B%E5%BA%8F%E7%9A%84151%E4%B8%AA%E5%BB%BA%E8%AE%AE)%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2018-11-22  <a class="commentCountImg" href="/2018/11/22/Java/%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81(%E6%94%B9%E5%96%84Java%E7%A8%8B%E5%BA%8F%E7%9A%84151%E4%B8%AA%E5%BB%BA%E8%AE%AE)%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">f216ea07c8a5ae682f57fc315afbd18e</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f216ea07c8a5ae682f57fc315afbd18e">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 小时  <i class="fas fa-pencil-alt"> </i>25.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《编写高质量代码(改善Java程序的151个建议)》读书笔记</h1><div class="content"><p>时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》</p>
<span id="more"></span>


<p><strong>嗯嗯，昨夜难眠，与Y君讲，要我遇些困苦，是要注定不凡的，我会走完一生的，要给自己些勇气。<br>2018.11.22</strong></p>
<h6 id="时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》"><a href="#时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》" class="headerlink" title="时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》"></a>时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》</h6><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><h1 id="第一章，Java开发中通用的方法和准则"><a href="#第一章，Java开发中通用的方法和准则" class="headerlink" title="第一章，Java开发中通用的方法和准则"></a>第一章，Java开发中通用的方法和准则</h1><h5 id="1-不要在常量和变量中出现易混淆的字母，-“1l“，表示一个long型的值，容易看做“11”-；"><a href="#1-不要在常量和变量中出现易混淆的字母，-“1l“，表示一个long型的值，容易看做“11”-；" class="headerlink" title="1. 不要在常量和变量中出现易混淆的字母，(“1l“，表示一个long型的值，容易看做“11”)；"></a>1. 不要在常量和变量中出现易混淆的字母，(“1l“，表示一个long型的值，容易看做“11”)；</h5><h5 id="2-莫让变量脱变成变量-public-static-final-int-RAND-CONST-x3D-Random-nextInt"><a href="#2-莫让变量脱变成变量-public-static-final-int-RAND-CONST-x3D-Random-nextInt" class="headerlink" title="2. 莫让变量脱变成变量(public static final int RAND_CONST &#x3D; Random().nextInt();)"></a>2. 莫让变量脱变成变量(public static final int RAND_CONST &#x3D; Random().nextInt();)</h5><h5 id="3-三元类型操作符的类型必须一致-转化规则，若不可转，返回值Object，为明确类型表达式-变量-，正常转化，若为数字与表达式，转换为范围大的，若为字面量数字，类型转化为范围大的"><a href="#3-三元类型操作符的类型必须一致-转化规则，若不可转，返回值Object，为明确类型表达式-变量-，正常转化，若为数字与表达式，转换为范围大的，若为字面量数字，类型转化为范围大的" class="headerlink" title="3. 三元类型操作符的类型必须一致(转化规则，若不可转，返回值Object，为明确类型表达式(变量)，正常转化，若为数字与表达式，转换为范围大的，若为字面量数字，类型转化为范围大的)"></a>3. 三元类型操作符的类型必须一致(转化规则，若不可转，返回值Object，为明确类型表达式(变量)，正常转化，若为数字与表达式，转换为范围大的，若为字面量数字，类型转化为范围大的)</h5><h5 id="4-避免带有变长参数的方法重载-从最简单开始-。"><a href="#4-避免带有变长参数的方法重载-从最简单开始-。" class="headerlink" title="4. 避免带有变长参数的方法重载(从最简单开始)。"></a>4. 避免带有变长参数的方法重载(从最简单开始)。</h5><h5 id="5-别让null值和空值威胁到重载的变长方法-变长参数N-gt-x3D-0-必须把null定义为具体的类型-。"><a href="#5-别让null值和空值威胁到重载的变长方法-变长参数N-gt-x3D-0-必须把null定义为具体的类型-。" class="headerlink" title="5. 别让null值和空值威胁到重载的变长方法(变长参数N&gt;&#x3D;0,必须把null定义为具体的类型)。"></a>5. 别让null值和空值威胁到重载的变长方法(变长参数N&gt;&#x3D;0,必须把null定义为具体的类型)。</h5><h5 id="6-覆写变长的方法也要循规蹈矩-可访问性一致-x2F-公开-参数列表相同-顺序等-返回类型相同-x2F-子类-不抛出新异常-或者超过父类的异常类"><a href="#6-覆写变长的方法也要循规蹈矩-可访问性一致-x2F-公开-参数列表相同-顺序等-返回类型相同-x2F-子类-不抛出新异常-或者超过父类的异常类" class="headerlink" title="6. 覆写变长的方法也要循规蹈矩(可访问性一致&#x2F;公开,参数列表相同(顺序等),返回类型相同&#x2F;子类,不抛出新异常,或者超过父类的异常类)"></a>6. 覆写变长的方法也要循规蹈矩(可访问性一致&#x2F;公开,参数列表相同(顺序等),返回类型相同&#x2F;子类,不抛出新异常,或者超过父类的异常类)</h5><h5 id="7-警惕自增的陷阱-i-x3D-0-while-true-i-x3D-i"><a href="#7-警惕自增的陷阱-i-x3D-0-while-true-i-x3D-i" class="headerlink" title="7. 警惕自增的陷阱(i &#x3D;0 ; while(true){i &#x3D; i++;})"></a>7. 警惕自增的陷阱(i &#x3D;0 ; while(true){i &#x3D; i++;})</h5><h5 id="8-不要让旧语法困扰。"><a href="#8-不要让旧语法困扰。" class="headerlink" title="8. 不要让旧语法困扰。"></a>8. 不要让旧语法困扰。</h5><h5 id="9-少用静态导入-规则：不使用-通配符，方法名为工具类-。"><a href="#9-少用静态导入-规则：不使用-通配符，方法名为工具类-。" class="headerlink" title="9. 少用静态导入(规则：不使用*通配符，方法名为工具类)。"></a>9. 少用静态导入(规则：不使用*通配符，方法名为工具类)。</h5><h5 id="10-不要在本类中覆盖静态导入的变量和方法-最短路径原则-，一般在原始类重构而不是覆盖。"><a href="#10-不要在本类中覆盖静态导入的变量和方法-最短路径原则-，一般在原始类重构而不是覆盖。" class="headerlink" title="10. 不要在本类中覆盖静态导入的变量和方法(最短路径原则)，一般在原始类重构而不是覆盖。"></a>10. 不要在本类中覆盖静态导入的变量和方法(最短路径原则)，一般在原始类重构而不是覆盖。</h5><h5 id="11-养成良好的习惯，显示申明UID"><a href="#11-养成良好的习惯，显示申明UID" class="headerlink" title="11.  养成良好的习惯，显示申明UID"></a>11.  养成良好的习惯，显示申明UID</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="comment">//流标识符(Stream Unique Identfier)类的版本定义,可以显示定义可以隐式定义</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">55799L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//序列化</span></span><br><span class="line">	Person person  =<span class="keyword">new</span> Person();</span><br><span class="line">	person.setName(<span class="string">&quot;李瑞龙&quot;</span>);</span><br><span class="line">	SerializationUtils.writeObject(person);</span><br><span class="line">	System.out.println(<span class="string">&quot;序列化成功！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtils</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String FILE_NAME = <span class="string">&quot;C:/LIRUILONG.bin&quot;</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 序列化</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Serializable s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(FILE_NAME));</span><br><span class="line">			oos.writeObject(s);</span><br><span class="line">			oos.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SerializationUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 反序列化</span></span><br><span class="line"><span class="comment">	 * @return obj</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Object obj  = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ObjectInput input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(FILE_NAME));</span><br><span class="line">		obj = input.readObject();</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//反序列化</span></span><br><span class="line">	Person p = (Person)SerializationUtils.readObject();</span><br><span class="line">	System.out.println(<span class="string">&quot;name=&quot;</span>+p.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当序列化和反序列化的版本不一致时,反序列化会报一个InvalidClassException异常，原因是类版本发生变化，JVM不能把数据流转换为实例对象,JVM通过SerialVersionUID(流标识符),即类的版本定义的，可以显示定义可以隐式定义(编译器自动申明),JVM反序列化时，会比较数据流中的SerialVersionUID与类中的SerialVersionUID是否相同，不相同抛出异常。依靠显示申明，改变一端的Person后可以运行。即显示申明SerialVersionUID可以避免对象不一致。但尽量不要以这种方式向JVM”撒谎”。</p>
<h5 id="12-避免用序列化类在构造函数中为不变量赋值，-反序列化时构造函数不会执行-。"><a href="#12-避免用序列化类在构造函数中为不变量赋值，-反序列化时构造函数不会执行-。" class="headerlink" title="12. 避免用序列化类在构造函数中为不变量赋值，(反序列化时构造函数不会执行)。"></a>12. 避免用序列化类在构造函数中为不变量赋值，(反序列化时构造函数不会执行)。</h5><h5 id="13-避免为final变量复杂赋值"><a href="#13-避免为final变量复杂赋值" class="headerlink" title="13. 避免为final变量复杂赋值:"></a>13. 避免为final变量复杂赋值:</h5><p>   (保存在磁盘上的对象文件包括两部分：</p>
<ul>
<li>1，<code>类文件描述信息</code>：包括类路径，继承关系，访问权限，变量描述，变量访问权限，方法签名，返回值，以及变量 的关联关系类信息。</li>
<li>2，<code>非瞬态(trtansient)和非静态(static)的的实例变量值</code>。<br>   <code>反序列化时final变量在一下情况不会被赋值：通过构造函数赋值，通过方法返回值赋值，final修饰的属性不是基本类型</code></li>
</ul>
<h5 id="14-使用序列化类的私有方法巧妙解决部分属性持久化的问题；"><a href="#14-使用序列化类的私有方法巧妙解决部分属性持久化的问题；" class="headerlink" title="14. 使用序列化类的私有方法巧妙解决部分属性持久化的问题；"></a>14. 使用序列化类的私有方法巧妙解决部分属性持久化的问题；</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//告诉JVM按照默认的规则写入对象，惯例的写法是写在第一句</span></span><br><span class="line">		out.defaultWriteObject();</span><br><span class="line">		<span class="comment">//写入相应的值</span></span><br><span class="line">		out.writeInt(salary.getBasePay());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">	<span class="comment">//告诉JVM按照默认规则读入对象，也写在第一句</span></span><br><span class="line">		in.defaultReadObject();</span><br><span class="line">		<span class="comment">//独处相应的值</span></span><br><span class="line">		salary = <span class="keyword">new</span> Salary(in.readInt(),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在序列化类中增加writeObject和readObject两个方法，使用序列化的独有机制，序列化回调，Java调用ObjectOutputStream类把一个对象转换为流数据时，会通过反射(Reflection)检查被序列化的类是否有writeObject方法，并且检查其是否为私有，无返回值的特性，若有，则会委托该方法进行对象序列化，若没有，则由ObjectOutputStream按照默认规则继续序列化，在反序列化的时候也会检查是否有私有方法readObject。如果有会通过该方法读取属性。</p>
<h5 id="15-break-万万不可以忘；"><a href="#15-break-万万不可以忘；" class="headerlink" title="15. break 万万不可以忘；"></a>15. break 万万不可以忘；</h5><h5 id="16-易变业务使用脚本语言编写-特性：灵活，便捷，简单-，JCP-Java-Community-Prosess-提出JSR223规范，JavaScript默认支持，"><a href="#16-易变业务使用脚本语言编写-特性：灵活，便捷，简单-，JCP-Java-Community-Prosess-提出JSR223规范，JavaScript默认支持，" class="headerlink" title="16. 易变业务使用脚本语言编写(特性：灵活，便捷，简单)，JCP(Java Community Prosess)提出JSR223规范，JavaScript默认支持，"></a>16. 易变业务使用脚本语言编写(特性：灵活，便捷，简单)，JCP(Java Community Prosess)提出JSR223规范，JavaScript默认支持，</h5><p>脚本语言可以随时发布而不用重新部署，即脚本语言改变，也能提供不间断的业务服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	<span class="comment">//获取JAVacript的执行引擎(engine)。	</span></span><br><span class="line">    ScriptEngine engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">    <span class="comment">//建立上下文变量</span></span><br><span class="line">    Bindings bind = engine.createBindings();</span><br><span class="line">    bind.put(<span class="string">&quot;factor&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//绑定上下文，作用域为当前引擎范围。</span></span><br><span class="line">    engine.setBindings(bind, ScriptContext.ENGINE_SCOPE);</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span>(input.hasNextInt()) &#123;</span><br><span class="line">    	<span class="keyword">int</span> first = input.nextInt();</span><br><span class="line">    	<span class="keyword">int</span> sec = input.nextInt();</span><br><span class="line">    	System.out.println(<span class="string">&quot;输入参数为：&quot;</span>+first+<span class="string">&quot;,&quot;</span>+sec);</span><br><span class="line">    	<span class="comment">//执行js代码</span></span><br><span class="line">    	engine.eval(<span class="keyword">new</span> FileReader(<span class="string">&quot;C:/model.js&quot;</span>));</span><br><span class="line">    	<span class="comment">//是否可调用方法</span></span><br><span class="line">    	<span class="keyword">if</span>(engine <span class="keyword">instanceof</span> Invocable) &#123;</span><br><span class="line">    		Invocable in = (Invocable)engine;</span><br><span class="line">    		Double result = (Double)in.invokeFunction(<span class="string">&quot;formula&quot;</span>,first,sec);</span><br><span class="line">    		System.out.println(<span class="string">&quot;运行结果:&quot;</span>+result.intValue());</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bindings</span> <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">String</span>,<span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">  所有键均为 <span class="title">String</span> 的键/值对映射关系。 </span></span><br><span class="line"><span class="class">   <span class="title">void</span> <span class="title">put</span>(<span class="title">String</span> <span class="title">key</span>, <span class="title">Object</span> <span class="title">value</span>) </span></span><br><span class="line"><span class="class">          设置 <span class="title">ScriptEngine</span> 的状态中的键/值对，它创建一个将在脚本执行中使用或者以其他方式</span></span><br><span class="line"><span class="class">          使用的 <span class="title">Java</span> <span class="title">Language</span> <span class="title">Binding</span>，具体取决于该键是否被保留      </span></span><br><span class="line"><span class="class"> <span class="title">public</span> <span class="title">interface</span> <span class="title">ScriptEngine</span> </span></span><br><span class="line"><span class="class"> <span class="title">ScriptEngine</span> 是基础接口，该接口的方法在此规范的每个实现中都必须具有完整的功能。</span></span><br><span class="line"><span class="class">这些方法提供基本的脚本功能。为这个简单接口编写的应用程序应该对每个实现稍做修改就能够运行。</span></span><br><span class="line"><span class="class">这包括执行脚本的方法，以及设置和获取值的方法。这些值是两种类型的键/值对。组成第一种类型的键/值对中的</span></span><br><span class="line"><span class="class">键是此规范或个别实现中保留和定义的键。包含保留键的键/值对中的值具有指定的含义。</span></span><br><span class="line"><span class="class">另一种类型由那些创建 <span class="title">Java</span> 语言 <span class="title">Bindings</span> 的键/值对组成，值通常通过相应键或其装饰的形式用脚本表示。 </span></span><br><span class="line"><span class="class"> <span class="title">Bindings</span> <span class="title">createBindings</span>() </span></span><br><span class="line"><span class="class">          返回一个未初始化的 <span class="title">Bindings</span>。 </span></span><br><span class="line"><span class="class">   <span class="title">void</span> <span class="title">setBindings</span>(<span class="title">Bindings</span> <span class="title">bindings</span>, <span class="title">int</span> <span class="title">scope</span>) </span></span><br><span class="line"><span class="class">          设置将由脚本使用的指定值的范围。        </span></span><br><span class="line"><span class="class">          </span></span><br><span class="line"><span class="class"> <span class="title">public</span> <span class="title">class</span> <span class="title">ScriptEngineManager</span> <span class="keyword">extends</span> <span class="title">ObjectScriptEngineManager</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"> 为 <span class="title">ScriptEngine</span> 类实现一个发现和实例化机制，还维护一个键/值对集合来存储所有 <span class="title">Manager</span> 创建的引擎所共享的状态。</span></span><br><span class="line"><span class="class"> 此类使用服务提供者机制枚举所有的 <span class="title">ScriptEngineFactory</span> 实现。</span></span><br><span class="line"><span class="class">   <span class="title">ScriptEngineManager</span> 提供了一个方法，可以返回一个所有工厂实现和基于语言名称、</span></span><br><span class="line"><span class="class">   文件扩展名和 <span class="title">mime</span> 类型查找工厂的实用方法所组成的数组。 键/值对的 <span class="title">Bindings</span>(即由管理器维护的 &quot;<span class="title">Global</span> <span class="title">Scope</span>&quot;)</span></span><br><span class="line"><span class="class">   对于 <span class="title">ScriptEngineManager</span> 创建的所有 <span class="title">ScriptEngine</span> 实例都是可用的。<span class="title">Bindings</span> 中的值通常公开于所有脚本中。 </span></span><br><span class="line"><span class="class"><span class="title">ScriptEngine</span> <span class="title">getEngineByName</span>(<span class="title">String</span> <span class="title">shortName</span>) </span></span><br><span class="line"><span class="class">          查找并创建一个给定名称的 <span class="title">ScriptEngine</span>。 </span></span><br><span class="line"><span class="class"> <span class="title">public</span> <span class="title">interface</span> <span class="title">Invocable</span></span></span><br><span class="line"><span class="class">由 <span class="title">ScriptEngines</span> 实现的可选接口，该 <span class="title">ScriptEngines</span> 的方法允许在以前执行过的脚本中调用程序。</span></span><br><span class="line"><span class="class">	<span class="title">Object</span> <span class="title">invokeFunction</span>(<span class="title">String</span> <span class="title">name</span>, <span class="title">Object</span>... <span class="title">args</span>) </span></span><br><span class="line"><span class="class">          用于调用脚本中定义的顶层程序和函数。 </span></span><br></pre></td></tr></table></figure>

<ol start="17">
<li>慎用动态编译(注意：在框架中谨慎使用，不要在要求高性能的项目中使用，动态编译要考虑安全问题，记录动态编译过程)</li>
<li>避免instanceof非预期的结果。(instanceof操作符的左右必须有继承或实现关系)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;String&quot;</span> <span class="keyword">instanceof</span> String <span class="comment">//返回值为true</span></span><br><span class="line"><span class="keyword">new</span> String() <span class="keyword">instanceof</span> String <span class="comment">//返回值为true</span></span><br><span class="line"><span class="keyword">new</span> Object() <span class="keyword">instanceof</span> String <span class="comment">//false(可以编译)</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span> <span class="keyword">instanceof</span> Character <span class="comment">//编译不通过，A为基本类型，Character为封装类，前边必须为对象。</span></span><br><span class="line"><span class="keyword">null</span> <span class="keyword">instanceof</span> String <span class="comment">//false,特殊规则，如果左操作数是null，结果就直接返回false，不在运运算右操作数，</span></span><br><span class="line">(String)<span class="keyword">null</span> <span class="keyword">instanceof</span> String <span class="comment">//false,null是一个万用类型，可以说它没有类型，即使类型转换也是null。</span></span><br><span class="line"><span class="keyword">new</span> Date() <span class="keyword">instanceof</span> String <span class="comment">//编译不通过，没有继承实现关系。</span></span><br><span class="line">T(T为泛型String类变量) <span class="keyword">instanceof</span> Date; <span class="comment">//通过，false，T被编译为Object类，传递String类的值，所以 &quot;Object instanceof Date&quot;；</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="19-断言绝不是鸡肋："><a href="#19-断言绝不是鸡肋：" class="headerlink" title="19. 断言绝不是鸡肋："></a>19. 断言绝不是鸡肋：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> &lt;boolean_expression&gt;</span><br><span class="line"><span class="keyword">assert</span> &lt;boolean_expression&gt;：&lt;erroe&gt;</span><br><span class="line">当布尔表达式为假时，抛出一个AssertionError错误，是继承自Error的，并附带错误信息，默认不启动。</span><br><span class="line">不可用：在对外的方法中不可用，在执行逻辑代码时不可用。因为生产中断言不会执行。</span><br><span class="line">可用：在私有方法中放置<span class="keyword">assert</span>作为输入参数校验。流程控制中不可能达到的区域。建立程序探针，即判断程序中不可变的量是否改变。</span><br></pre></td></tr></table></figure>
<h5 id="20-不要只替换一个类，-发布应用系统时禁止使用类文件替换方式，整体的WAR包发布才是万全之策"><a href="#20-不要只替换一个类，-发布应用系统时禁止使用类文件替换方式，整体的WAR包发布才是万全之策" class="headerlink" title="20. 不要只替换一个类，(发布应用系统时禁止使用类文件替换方式，整体的WAR包发布才是万全之策)"></a>20. 不要只替换一个类，(发布应用系统时禁止使用类文件替换方式，整体的WAR包发布才是万全之策)</h5><p> 对于final修饰的基本类型和String类型，编译器会认为他是稳定态(Immutable Status)，所以编译期间之间把值编译到字节码中，避免运行期引用(Run-time-reference)，提高代码执行效率对于final修饰的基本类型和String类型，编译器会认为他是稳定态(Immutable Status)，所以编译期间之间把值编译到字节码中，避免运行期引用(Run-time-reference)，提高代码执行效率，对于final类来讲编译器认为它是不稳定的，在编译期建立则是引用关系，即到final修饰一个类或实例时，不重新编译也会是最新值。</p>
<hr>
<h1 id="第二章，基本类型"><a href="#第二章，基本类型" class="headerlink" title="第二章，基本类型"></a>第二章，基本类型</h1><h5 id="21-用于偶判断，不用奇判断，-取模运算，"><a href="#21-用于偶判断，不用奇判断，-取模运算，" class="headerlink" title="21. 用于偶判断，不用奇判断，(取模运算，)"></a>21. 用于偶判断，不用奇判断，(取模运算，)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i%<span class="number">2</span> == <span class="number">1</span>?<span class="string">&quot;奇数&quot;</span>:<span class="string">&quot;偶数&quot;</span>;<span class="comment">//输入-1为偶数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">remainder</span><span class="params">(<span class="keyword">int</span> dividend,<span class="keyword">int</span> divisor)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dividend - dividend/divisor*divisor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="22-用整数类型处理货币-使用BigDecimal类，与数据库映射方便。使用整形-扩大倍数"><a href="#22-用整数类型处理货币-使用BigDecimal类，与数据库映射方便。使用整形-扩大倍数" class="headerlink" title="22. 用整数类型处理货币(使用BigDecimal类，与数据库映射方便。使用整形(扩大倍数))"></a>22. 用整数类型处理货币(使用BigDecimal类，与数据库映射方便。使用整形(扩大倍数))</h5><h5 id="23-不用让类型默默转换，-java-为先运算后进行类型转化的-当运算结果过界就会从头开始-负值-，在运算中加入数据范围大的值，基本类型转换时，使用主动声明方式减少不必要的bug"><a href="#23-不用让类型默默转换，-java-为先运算后进行类型转化的-当运算结果过界就会从头开始-负值-，在运算中加入数据范围大的值，基本类型转换时，使用主动声明方式减少不必要的bug" class="headerlink" title="23. 不用让类型默默转换，(java 为先运算后进行类型转化的)当运算结果过界就会从头开始(负值)，在运算中加入数据范围大的值，基本类型转换时，使用主动声明方式减少不必要的bug."></a>23. 不用让类型默默转换，(java 为先运算后进行类型转化的)当运算结果过界就会从头开始(负值)，在运算中加入数据范围大的值，基本类型转换时，使用主动声明方式减少不必要的bug.</h5><h5 id="24-边界，边界，还是边界-判断数值范围时，要考虑超过类型边界后为负数-。"><a href="#24-边界，边界，还是边界-判断数值范围时，要考虑超过类型边界后为负数-。" class="headerlink" title="24. 边界，边界，还是边界(判断数值范围时，要考虑超过类型边界后为负数)。"></a>24. 边界，边界，还是边界(判断数值范围时，要考虑超过类型边界后为负数)。</h5><h5 id="25-不要让四舍五入亏了一方-银行家舍入-："><a href="#25-不要让四舍五入亏了一方-银行家舍入-：" class="headerlink" title="25. 不要让四舍五入亏了一方(银行家舍入)："></a>25. 不要让四舍五入亏了一方(银行家舍入)：</h5><h5 id="26-堤防包装类型的null值：包装类型参与运算时，要做null值校验。"><a href="#26-堤防包装类型的null值：包装类型参与运算时，要做null值校验。" class="headerlink" title="26. 堤防包装类型的null值：包装类型参与运算时，要做null值校验。"></a>26. 堤防包装类型的null值：包装类型参与运算时，要做null值校验。</h5><h5 id="27-谨慎包装类型的大小比较：”-x3D-x3D-”对于基本类型比较的值，对象比较是否为同一个引用。-lt-gt-不能比较对象大小。"><a href="#27-谨慎包装类型的大小比较：”-x3D-x3D-”对于基本类型比较的值，对象比较是否为同一个引用。-lt-gt-不能比较对象大小。" class="headerlink" title="27. 谨慎包装类型的大小比较：”&#x3D;&#x3D;”对于基本类型比较的值，对象比较是否为同一个引用。&lt;&gt;不能比较对象大小。"></a>27. 谨慎包装类型的大小比较：”&#x3D;&#x3D;”对于基本类型比较的值，对象比较是否为同一个引用。&lt;&gt;不能比较对象大小。</h5><h5 id="28-优先使用整形池：装箱生成的对象，装箱动作通过valueOf实现的，chache是IntegerCatch内部类的静态数组，容纳-128—127之间的Integer对象，不在该范围的int类型通过new生成包装对象。即127这个数字的包装每次都是同一个对象，而128不是同一个对象。整形池存在不仅提高了系统性能，节约内存空间。"><a href="#28-优先使用整形池：装箱生成的对象，装箱动作通过valueOf实现的，chache是IntegerCatch内部类的静态数组，容纳-128—127之间的Integer对象，不在该范围的int类型通过new生成包装对象。即127这个数字的包装每次都是同一个对象，而128不是同一个对象。整形池存在不仅提高了系统性能，节约内存空间。" class="headerlink" title="28. 优先使用整形池：装箱生成的对象，装箱动作通过valueOf实现的，chache是IntegerCatch内部类的静态数组，容纳-128—127之间的Integer对象，不在该范围的int类型通过new生成包装对象。即127这个数字的包装每次都是同一个对象，而128不是同一个对象。整形池存在不仅提高了系统性能，节约内存空间。"></a>28. 优先使用整形池：装箱生成的对象，装箱动作通过valueOf实现的，chache是IntegerCatch内部类的静态数组，容纳-128—127之间的Integer对象，不在该范围的int类型通过new生成包装对象。即127这个数字的包装每次都是同一个对象，而128不是同一个对象。整形池存在不仅提高了系统性能，节约内存空间。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> offset= <span class="number">128</span>;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;=-<span class="number">128</span>&amp;&amp;i&lt;=<span class="number">127</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> IntegerCache[i+offset];&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Ingeger(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[] = <span class="keyword">new</span> Integer[-(-<span class="number">128</span>)+<span class="number">127</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; cache.length;i++)</span><br><span class="line">			cache[i] = <span class="keyword">new</span> Integer(i-<span class="number">128</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="29-优先选择基本类型：-自动装箱的重要原则，基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转换为宽类型的包装类型"><a href="#29-优先选择基本类型：-自动装箱的重要原则，基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转换为宽类型的包装类型" class="headerlink" title="29. 优先选择基本类型：(自动装箱的重要原则，基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转换为宽类型的包装类型)"></a>29. 优先选择基本类型：(自动装箱的重要原则，基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转换为宽类型的包装类型)</h5><h5 id="30-不要随便设置随机种子："><a href="#30-不要随便设置随机种子：" class="headerlink" title="30. 不要随便设置随机种子："></a>30. 不要随便设置随机种子：</h5><p>在java中，随机数的产生取决于种子，随机数和种子之间的关系(种子不同，产出的随机数不同，种子相同，即使实例不同也产生相同的随机数)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Random r= new Random();默认种子</span></span><br><span class="line">		Random r= <span class="keyword">new</span> Random(<span class="number">1000</span>);<span class="comment">//设置种子</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;随机数字为：&quot;</span>+r.nextInt());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>获得随机数：Math.random()方法，通过java.util.Random;</p>
<hr>
<h1 id="第三章，类对象及方法"><a href="#第三章，类对象及方法" class="headerlink" title="第三章，类对象及方法"></a>第三章，类对象及方法</h1><h5 id="31-在接口中不要存在实现代码-接口中声明一个匿名内部类的实例对象的静态常量-。"><a href="#31-在接口中不要存在实现代码-接口中声明一个匿名内部类的实例对象的静态常量-。" class="headerlink" title="31. 在接口中不要存在实现代码(接口中声明一个匿名内部类的实例对象的静态常量)。"></a>31. 在接口中不要存在实现代码(接口中声明一个匿名内部类的实例对象的静态常量)。</h5><h5 id="32-静态变量一定要先声明后赋值"><a href="#32-静态变量一定要先声明后赋值" class="headerlink" title="32. 静态变量一定要先声明后赋值"></a>32. 静态变量一定要先声明后赋值</h5><p>静态变量是类加载时被分配到数据区(Data Area)的，它在内存中只有一个拷贝，不会被分配多次，其后的所有赋值操作都是值改变，地址则保持不变。JVM初始化变量是先声明空间，然后在赋值(int i&#x3D; 12;&#x3D;&#x3D;&gt;int i ; i &#x3D;12;)<br>静态变量在类初始化时首先被加载的，JVM会查找类中所有的静态申明，然后分配空间，只是完成地址空间分配，还没有赋值，之后会根据类中的静态赋值(包括静态类型赋值和静态块赋值)的先后顺序执行。变量先申明后使用。</p>
<h5 id="33-不要-重写-覆写静态方法，覆写是针对非静态方法-实例方法-的，不针对静态方法-类方法-，但是可以隐藏静态方法-属于该类，与父类没有关系-。通过实例对象访问静态方法和属性是不好的习惯。"><a href="#33-不要-重写-覆写静态方法，覆写是针对非静态方法-实例方法-的，不针对静态方法-类方法-，但是可以隐藏静态方法-属于该类，与父类没有关系-。通过实例对象访问静态方法和属性是不好的习惯。" class="headerlink" title="33. 不要(重写)覆写静态方法，覆写是针对非静态方法(实例方法)的，不针对静态方法(类方法)，但是可以隐藏静态方法(属于该类，与父类没有关系)。通过实例对象访问静态方法和属性是不好的习惯。"></a>33. 不要(重写)覆写静态方法，覆写是针对非静态方法(实例方法)的，不针对静态方法(类方法)，但是可以隐藏静态方法(属于该类，与父类没有关系)。通过实例对象访问静态方法和属性是不好的习惯。</h5><p>实例对象有两个类型：<code>表面类型(Apparent Type)</code>和<code>实际类型(Actual Type)</code>,表面类型是声明时的类型，实际类型是对象产生时的类型，对于非静态方法，它是根据对象的实际类型来执行的，对于静态方法来说，不依赖实例对象，通过类名访问，通过对象访问静态方法，JVM会通过对象的表面类型查找到静态方法的入口，然后执行，<br>在子类中构建与父类相同的方法名，输入参数，输出参数，访问权限(权限可以扩大)，并且父类子类都是静态方法，此种行为称之为隐藏(Hide)，它与覆写有两点不同。</p>
<ul>
<li>1，<code>表现形式不同</code>：隐藏用于静态方法，覆写用于非静态，@OVerride可以用于覆写(写上自动检测是否合要求)，不能用于隐藏。</li>
<li>2，<code>职责不同</code>：隐藏的目的是为了抛弃父类静态方法,重现子类方法，覆写是为了将父类的行为增强或减弱。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//父类静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是父类的静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//父类非静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是父类的非静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="comment">//子类同名，同参数的静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是子类的静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//覆写父类的非静态方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是子类的非静态方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Base base1 = <span class="keyword">new</span> Sub();</span><br><span class="line">		Sub base = <span class="keyword">new</span> Sub();</span><br><span class="line">		base.doAnything();</span><br><span class="line">		base1.doSomething();</span><br><span class="line">		base.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//我是子类的非静态方法</span></span><br><span class="line"><span class="comment">//我是父类的静态方法</span></span><br><span class="line"><span class="comment">//我是子类的静态方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="34-构造函数尽量简化。-子类实例化时，会先初始化父类-初始化，不是生成父类对象-，就是初始化父类的对象，调用父类的构造函数，然后才会初始化子类的变量，调用子类的构造函数，最后生成一个实例对象"><a href="#34-构造函数尽量简化。-子类实例化时，会先初始化父类-初始化，不是生成父类对象-，就是初始化父类的对象，调用父类的构造函数，然后才会初始化子类的变量，调用子类的构造函数，最后生成一个实例对象" class="headerlink" title="34. 构造函数尽量简化。(子类实例化时，会先初始化父类(初始化，不是生成父类对象)，就是初始化父类的对象，调用父类的构造函数，然后才会初始化子类的变量，调用子类的构造函数，最后生成一个实例对象)"></a>34. 构造函数尽量简化。(子类实例化时，会先初始化父类(初始化，不是生成父类对象)，就是初始化父类的对象，调用父类的构造函数，然后才会初始化子类的变量，调用子类的构造函数，最后生成一个实例对象)</h5><h5 id="35-避免在构造函数中初始化其他类。"><a href="#35-避免在构造函数中初始化其他类。" class="headerlink" title="35. 避免在构造函数中初始化其他类。"></a>35. 避免在构造函数中初始化其他类。</h5><h5 id="36-使用构造代码精炼程序"><a href="#36-使用构造代码精炼程序" class="headerlink" title="36. 使用构造代码精炼程序,"></a>36. 使用构造代码精炼程序,</h5><p>代码块(Code Block):{}包裹的数据体，实现特定算法，一般不能单独运行，要有运行主体，java 中有四种：</p>
<ul>
<li>1，<code>普通代码块</code>：方法名后面{ }部分。</li>
<li>2，<code>静态代码块</code>：在类中使用static修饰的{ }，用于静态变量的初始化和对象创建前的环境初始化。<strong>类中的静态块</strong>会在整个<strong>类加载过程中的初始化阶段执行</strong>，而不是在<strong>类加载过程中的加载阶段执行</strong>。<strong>初始化阶段是类加载过程中的最后一个阶段</strong>，该阶段就是执行类构造器<clinit>方法的过程，<clinit>方法由编译器自动收集类中所有类变量(静态变量)的赋值动作和静态语句块中的语句合并生成 <strong>，一个类一旦进入初始化阶段，必然会执行静态语句块。所以说，静态块一定会在类加载过程中被执行，但不会在加载阶段被执行</strong></li>
<li>3，<code>同步代码块</code>：使用synchronized修饰的{ }，表示同一时间只能有一个线程进入到该方法块，一种多线程保护机制。</li>
<li>4，<code>构造代码块</code>：在类中没有人任何前缀和后缀的{ }，编译器会把构造代码块插入到构造函数的最前端。<br>在通过new关键字生成一个实例时会先执行构造代码块，然后在执行其他构造函数代码，依托于构造函数运行，不是在构造函数之前运行。应用：</li>
<li>1，<code>初始化实例变量(Instance Variable)</code>：如果每个构造函数都需要初始化变量，可以通过构造代码块实现。</li>
<li>2，<code>初始化实例环境</code>：当一个对象必须在适的场景才能存在，jee中要产生HTTP Request,必须要建立HTTP session ,可以在创建HTTP Request时通过构造代码块检查HTTP Session是否存在，不存在就创建。</li>
</ul>
<h5 id="37-构造代码块会想你所想。-当构造代码块遇到this关键字时-构造函数调用自身其他无参构造函数-，则不插入代码块，遇到super时，会放到super方法之后执行"><a href="#37-构造代码块会想你所想。-当构造代码块遇到this关键字时-构造函数调用自身其他无参构造函数-，则不插入代码块，遇到super时，会放到super方法之后执行" class="headerlink" title="37. 构造代码块会想你所想。(当构造代码块遇到this关键字时(构造函数调用自身其他无参构造函数)，则不插入代码块，遇到super时，会放到super方法之后执行)"></a>37. 构造代码块会想你所想。(当构造代码块遇到this关键字时(构造函数调用自身其他无参构造函数)，则不插入代码块，遇到super时，会放到super方法之后执行)</h5><h5 id="38-使用静态内部类提高封装性："><a href="#38-使用静态内部类提高封装性：" class="headerlink" title="38. 使用静态内部类提高封装性："></a>38. 使用静态内部类提高封装性：</h5><p>java中的嵌套类(Nesetd Class)：分为两种，<code>静态内部类</code>(也叫静态嵌套类，Static Nested Class)和<code>内部类</code>(Inner Class),<br>静态内部类：加强了类的封装性，提高了代码的可读性。<br>静态内部类不持有外部类的引用(普通内部类可以访问外部类的方法，属性，即使是private类型也可以访问，静态内部类只可以访问外部类的静态方法和静态属性)，静态内部类不依赖外部类(普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，同生同死，一起声明，一起被拉圾回收器回收，静态内部类可以独立存在，即使外部类消亡，静态内部类还是可以存在)，普通内部不能声明static的方法和变量(常量可以修饰，静态内部类没有限制)</p>
<h5 id="39-使用匿名类的构造函数"><a href="#39-使用匿名类的构造函数" class="headerlink" title="39. 使用匿名类的构造函数"></a>39. 使用匿名类的构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个ArrayList对象。</span></span><br><span class="line">List la = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//一个继承了ArrayList的匿名类的声明和赋值，没有任何覆写方法。</span></span><br><span class="line">List lb = <span class="keyword">new</span> ArrayList()&#123;&#125;;</span><br><span class="line"><span class="comment">//在上面的基础上增加了构造函数块。可以有多个。</span></span><br><span class="line">List lc = <span class="keyword">new</span> ArrayList()&#123;&#123;&#125;&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="40-匿名类的构造函数很特殊：-一般类-具有显示名字的类-的所有构造函数默认都是调用父类的无参构造函数的，而匿名类没有名字，只能有构造代码块代替，它在初始化时直接调用父类的同参构造函数，然后在调用自己的构造代码块"><a href="#40-匿名类的构造函数很特殊：-一般类-具有显示名字的类-的所有构造函数默认都是调用父类的无参构造函数的，而匿名类没有名字，只能有构造代码块代替，它在初始化时直接调用父类的同参构造函数，然后在调用自己的构造代码块" class="headerlink" title="40. 匿名类的构造函数很特殊：(一般类(具有显示名字的类)的所有构造函数默认都是调用父类的无参构造函数的，而匿名类没有名字，只能有构造代码块代替，它在初始化时直接调用父类的同参构造函数，然后在调用自己的构造代码块)"></a>40. 匿名类的构造函数很特殊：(一般类(具有显示名字的类)的所有构造函数默认都是调用父类的无参构造函数的，而匿名类没有名字，只能有构造代码块代替，它在初始化时直接调用父类的同参构造函数，然后在调用自己的构造代码块)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ops</span></span>&#123;ADD,SUB &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i,j,result;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.i =i;</span><br><span class="line">		<span class="keyword">this</span>.j = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setOperator</span><span class="params">(Ops _op)</span> </span>&#123;</span><br><span class="line">		result = _op.equals(Ops.ADD)?i+j:i-j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个匿名内部类，使用构造代码块初始化</span></span><br><span class="line">	Calculator c1 = <span class="keyword">new</span> Calculator(<span class="number">1</span>,<span class="number">2</span>) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			setOperator(Ops.ADD);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	System.out.println(c1.getResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="41-让多重继承成为现实-内部类的重要特征，内部类可以继承一个与外部类无关的类，保证了内部类当然独立性-多重继承考虑内部类。"><a href="#41-让多重继承成为现实-内部类的重要特征，内部类可以继承一个与外部类无关的类，保证了内部类当然独立性-多重继承考虑内部类。" class="headerlink" title="41. 让多重继承成为现实(内部类的重要特征，内部类可以继承一个与外部类无关的类，保证了内部类当然独立性)多重继承考虑内部类。"></a>41. 让多重继承成为现实(内部类的重要特征，内部类可以继承一个与外部类无关的类，保证了内部类当然独立性)多重继承考虑内部类。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父亲</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//母亲</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mother</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Kind</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父亲实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FatherImpl</span> <span class="keyword">implements</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//母亲实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherImpl</span> <span class="keyword">implements</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Kind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//儿子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">FatherImpl</span> <span class="keyword">implements</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.strong()+<span class="number">1</span>;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Kind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MotherSpecial().Kind();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MotherSpecial</span> <span class="keyword">extends</span> <span class="title">MotherImpl</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.Kind() -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="42-让工具类不可实例化-一般为静态-：在构造函数设置私有，抛出异常。"><a href="#42-让工具类不可实例化-一般为静态-：在构造函数设置私有，抛出异常。" class="headerlink" title="42. 让工具类不可实例化(一般为静态)：在构造函数设置私有，抛出异常。"></a>42. 让工具类不可实例化(一般为静态)：在构造函数设置私有，抛出异常。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilsClass</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">UtilsClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;不要实例化我哎&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="43-避免对象的浅拷贝-浅拷贝是java的一种简单的机制，不便于直接使用"><a href="#43-避免对象的浅拷贝-浅拷贝是java的一种简单的机制，不便于直接使用" class="headerlink" title="43. 避免对象的浅拷贝(浅拷贝是java的一种简单的机制，不便于直接使用)"></a>43. 避免对象的浅拷贝(浅拷贝是java的一种简单的机制，不便于直接使用)</h5><p>一个类在实现了Cloneable接口就表示它具备了被拷贝的能力，如果在覆写clone()方法就会完全具备拷贝能力。拷贝在内存中进行，所以在性能方面比直接通过new生成对象要快的多，存在缺陷：浅拷贝(Shadow Clobe,也称影子拷贝)存在对象属性拷贝不彻底的问题。拷贝规则：</p>
<ul>
<li>1，<code>基本类型拷贝其值,。</code></li>
<li>2，<code>实例对象，拷贝地址引用</code>，就是说此时新拷贝的对象与原有对象共享该实例变量，不受访问权限的限制。</li>
<li>3，<code>String字符串，拷贝的也是地址</code>，但是在修改时，会从字符串池(String Pool)中重新生成字符串，原有的字符串保持不变</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="comment">//父亲</span></span><br><span class="line">	<span class="keyword">private</span> Person father;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,Person parent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.father = parent;</span><br><span class="line">	&#125;	<span class="comment">//getter与setter方法省略</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">			<span class="comment">//p.setFather(new Person(p.getFather().getName())实现深拷贝</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Person f = <span class="keyword">new</span> Person(<span class="string">&quot;父亲&quot;</span>);</span><br><span class="line">	Person s1 = <span class="keyword">new</span> Person(<span class="string">&quot;大儿子&quot;</span>,f);</span><br><span class="line">	Person s2 = s1.clone();</span><br><span class="line">	s2.setName(<span class="string">&quot;小儿子&quot;</span>);</span><br><span class="line">	<span class="comment">//s2.getFather().setName(&quot;干爹&quot;);</span></span><br><span class="line">	System.out.println(s1.getName()+<span class="string">&quot;的父亲为：&quot;</span>+s1.getFather().getName());</span><br><span class="line">	System.out.println(s2.getName()+<span class="string">&quot;的父亲为：&quot;</span>+s2.getFather().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="44-推存使用序列化实现对象的拷贝，"><a href="#44-推存使用序列化实现对象的拷贝，" class="headerlink" title="44. 推存使用序列化实现对象的拷贝，"></a>44. 推存使用序列化实现对象的拷贝，</h5><p>被拷贝的类只要实现Serializable接口，不需要任何实现，需要加上SerialVersionUID常量，使用需要注意：</p>
<ul>
<li>1，<code>对象的内部属性都是可序列化的。</code></li>
<li>2，<code>注意方法和属性的特殊修饰符。</code>final，static变量的序列化问题会被 引入到拷贝对象中，瞬态变量(trtansient)不能进行序列化。可一采用Apache下的commons工具包中的SerializationUtils类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line">	<span class="comment">//拷贝一个对象</span></span><br><span class="line">	<span class="comment">//@SuppressWarnings。该批注的作用是给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默。 </span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *    关键字         用途 </span></span><br><span class="line"><span class="comment">   deprecation   使用了不赞成使用的类或方法时的警告 </span></span><br><span class="line"><span class="comment">   unchecked     执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。 </span></span><br><span class="line"><span class="comment">   fallthrough   当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。 </span></span><br><span class="line"><span class="comment">   path          在类路径、源文件路径等中有不存在的路径时的警告。  </span></span><br><span class="line"><span class="comment">   serial        当在可序列化的类上缺少 serialVersionUID 定义时的警告。  </span></span><br><span class="line"><span class="comment">   finally       任何 finally 子句不能正常完成时的警告。 </span></span><br><span class="line"><span class="comment">   all           关于以上所有情况的警告。 </span></span><br><span class="line"><span class="comment"> @SuppressWarnings 批注允许您选择性地取消特定代码段(即，类或方法)中的警告。其中的想法是当您看到警告时，</span></span><br><span class="line"><span class="comment"> 您将调查它，如果您确定它不是问题，您就可以添加一个 @SuppressWarnings 批注，以使您不会再看到警告。</span></span><br><span class="line"><span class="comment"> 虽然它听起来似乎会屏蔽潜在的错误，但实际上它将提高代码安全性，因为它将防止您对警告无动于衷 — </span></span><br><span class="line"><span class="comment"> 您看到的每一个警告都将值得注意。 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//拷贝产生的对象</span></span><br><span class="line">		T clonedObj = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//读取对象字节数据</span></span><br><span class="line">			ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">			oos.writeObject(obj);<span class="comment">//写操作</span></span><br><span class="line">			oos.close();<span class="comment">//关闭流</span></span><br><span class="line">			<span class="comment">//分配内存空间，写入原始对象，生成新对象</span></span><br><span class="line">			ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">			ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">			clonedObj = (T)ois.readObject();<span class="comment">//读操作</span></span><br><span class="line">			ois.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> clonedObj;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="45-覆写equals方法时不要识别不出自己，equals方法的自反原则-对于任何非空引用x，x-equals-x-应该返回true"><a href="#45-覆写equals方法时不要识别不出自己，equals方法的自反原则-对于任何非空引用x，x-equals-x-应该返回true" class="headerlink" title="45. 覆写equals方法时不要识别不出自己，equals方法的自反原则(对于任何非空引用x，x.equals(x)应该返回true)"></a>45. 覆写equals方法时不要识别不出自己，equals方法的自反原则(对于任何非空引用x，x.equals(x)应该返回true)</h5><h5 id="46-equals应该考虑null值情景。对称性原则，对于任何引用x和y的情形，如果x-equals-y-返回true，那么y-equals-x-也应该返回true。"><a href="#46-equals应该考虑null值情景。对称性原则，对于任何引用x和y的情形，如果x-equals-y-返回true，那么y-equals-x-也应该返回true。" class="headerlink" title="46. equals应该考虑null值情景。对称性原则，对于任何引用x和y的情形，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。"></a>46. equals应该考虑null值情景。对称性原则，对于任何引用x和y的情形，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。</h5><h5 id="47-在equals中使用getClass进行类型判断，注意equals的传递性原则，对于实例对象s，y，z，如果如果s-equals-y-为true，y-equals-z-返回true，那么x-equals-z-也返回true。"><a href="#47-在equals中使用getClass进行类型判断，注意equals的传递性原则，对于实例对象s，y，z，如果如果s-equals-y-为true，y-equals-z-返回true，那么x-equals-z-也返回true。" class="headerlink" title="47. 在equals中使用getClass进行类型判断，注意equals的传递性原则，对于实例对象s，y，z，如果如果s.equals(y)为true，y.equals(z)返回true，那么x.equals(z)也返回true。"></a>47. 在equals中使用getClass进行类型判断，注意equals的传递性原则，对于实例对象s，y，z，如果如果s.equals(y)为true，y.equals(z)返回true，那么x.equals(z)也返回true。</h5><h5 id="48-覆写equals方法必须覆写hashCode方法。"><a href="#48-覆写equals方法必须覆写hashCode方法。" class="headerlink" title="48.  覆写equals方法必须覆写hashCode方法。"></a>48.  覆写equals方法必须覆写hashCode方法。</h5><p> HashMap的底层处理机制是以数组的方式保存Map条目的，链表保存val，依据传入元素的hashCode方法返回的哈希值决定数组下标，如果该位置已有Map条目了，且与传入的键值相等则不要处理，若不相等则则覆盖，如果数组位置没有条目则插入。并加入到Map条目的链表中。即在检查相等时也是由哈希吗确定位置。<br>  哈希码：由Object方法本地生成，确保每一个对象有一个哈希码(哈希算法，输入任意L，通过一定算法f(L)，将其转化为非可逆的输出，一对一，多对一成立)，重写hashCode方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HashCodeBuilder().append(),toHashCode();<span class="comment">//HashCodeBuilder哈希码生成工具。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="49-推存覆写toString方法，正常输出：类名-hashCode；"><a href="#49-推存覆写toString方法，正常输出：类名-hashCode；" class="headerlink" title="49. 推存覆写toString方法，正常输出：类名+@+hashCode；"></a>49. 推存覆写toString方法，正常输出：类名+@+hashCode；</h5><h5 id="50-使用package-info类为包服务：用于描述和记录包信息的，会被编译，不能声明类，不能继承，没有类关系，用于申明友好类和包内访问常量，为在包上标注一个注解-Annotation-提供方便，即将定义的注解写到这里，提供包的整体注释说明。"><a href="#50-使用package-info类为包服务：用于描述和记录包信息的，会被编译，不能声明类，不能继承，没有类关系，用于申明友好类和包内访问常量，为在包上标注一个注解-Annotation-提供方便，即将定义的注解写到这里，提供包的整体注释说明。" class="headerlink" title="50. 使用package-info类为包服务：用于描述和记录包信息的，会被编译，不能声明类，不能继承，没有类关系，用于申明友好类和包内访问常量，为在包上标注一个注解(Annotation)提供方便，即将定义的注解写到这里，提供包的整体注释说明。"></a>50. 使用package-info类为包服务：用于描述和记录包信息的，会被编译，不能声明类，不能继承，没有类关系，用于申明友好类和包内访问常量，为在包上标注一个注解(Annotation)提供方便，即将定义的注解写到这里，提供包的整体注释说明。</h5><h5 id="51-不要主动进行垃圾回收。"><a href="#51-不要主动进行垃圾回收。" class="headerlink" title="51. 不要主动进行垃圾回收。"></a>51. 不要主动进行垃圾回收。</h5><hr>
<h1 id="第四章，字符串"><a href="#第四章，字符串" class="headerlink" title="第四章，字符串"></a>第四章，字符串</h1><h5 id="52-推存使用String直接量赋值，"><a href="#52-推存使用String直接量赋值，" class="headerlink" title="52. 推存使用String直接量赋值，"></a>52. 推存使用String直接量赋值，</h5><p> Java为了避免在一个系统中产生大量的String对象，设计了一个字符串池(也称字符串常量池，String pool 或 String Constant Pool，存在于JVM常量池(Constant Pool)中)，在字符串池中容纳的都是String对象，当创建一个字符串时，首先检查池中是否有字面值相等的字符串，有不在创建，直接返回池中该对象的引用，没有则创建，然后放到池中，返回新建对象的引用，所以当用“&#x3D;&#x3D;”判断相等。当使用new String(“”) 时不会检查池，也不会放入池。不相等，intern方法(会检查池里，有返回)处理相等。String类是一个不可变(Immutable)的类,final不可继承，在String提供的方法中，如果返回字符串一般为新建的String对象，不对原对象进行修改。</p>
<h5 id="53-注意方法中传递的参数要求，replaceAll传递的是第一个参数为正则表达式。"><a href="#53-注意方法中传递的参数要求，replaceAll传递的是第一个参数为正则表达式。" class="headerlink" title="53. 注意方法中传递的参数要求，replaceAll传递的是第一个参数为正则表达式。"></a>53. 注意方法中传递的参数要求，replaceAll传递的是第一个参数为正则表达式。</h5><h5 id="54-正确使用String-，StringBuffer-StringBuilder"><a href="#54-正确使用String-，StringBuffer-StringBuilder" class="headerlink" title="54. 正确使用String ，StringBuffer , StringBuilder :"></a>54. 正确使用String ，StringBuffer , StringBuilder :</h5><p>CharSequence接口有三个实现类：String , StringBuffer , StringBuilder ,</p>
<ul>
<li>String为不可改变量，修改要么创建新的字符串对象，要么返回自己(str.substring(0)),</li>
<li>StringBuffer是一个可变字符序列，他与String一样，在内存中的都是一个有序的字符序列，不同点是值可以改变，</li>
<li>StringBuilder 与 StringBuffer在性能上基本相同，都为可变字符序列。不同点为StringBuffer为线程安全的，而StringBuilder为线程不安全。</li>
</ul>
<p><code>使用场景</code>：</p>
<ul>
<li>String：常量的声明，少量的变量运算。</li>
<li>StringBuffer：频繁的字符串运算，多线程(xml，Http解析)。</li>
<li>StringBuilder：频繁的字符串运算，单线程(SQL语句拼接)。</li>
</ul>
<h5 id="55-注意字符串的位置：在-号处理中，String字符串具有最高的优先级。"><a href="#55-注意字符串的位置：在-号处理中，String字符串具有最高的优先级。" class="headerlink" title="55. 注意字符串的位置：在+号处理中，String字符串具有最高的优先级。"></a>55. 注意字符串的位置：在+号处理中，String字符串具有最高的优先级。</h5><h5 id="56-自由选择字符串拼接方式："><a href="#56-自由选择字符串拼接方式：" class="headerlink" title="56. 自由选择字符串拼接方式："></a>56. 自由选择字符串拼接方式：</h5><ul>
<li>1，<code>“+”号拼接，时间最长</code>，等价于srt &#x3D; StringBuilder(srt).append(“c”).toString();</li>
<li>2,<code>concat方法拼接，时间中等</code>，每次都会新建一个String对象；</li>
<li>3，<code>append方法拼接字符串，时间最快，</code>只生成一个String对象。</li>
</ul>
<h5 id="57-推存在复杂字符串操作中使用正则表达式来完成复杂处理。查找单词数，-b-w-b"><a href="#57-推存在复杂字符串操作中使用正则表达式来完成复杂处理。查找单词数，-b-w-b" class="headerlink" title="57. 推存在复杂字符串操作中使用正则表达式来完成复杂处理。查找单词数，\b\w+\b"></a>57. 推存在复杂字符串操作中使用正则表达式来完成复杂处理。查找单词数，\b\w+\b</h5><h5 id="58-强烈建议使用UTF编码。"><a href="#58-强烈建议使用UTF编码。" class="headerlink" title="58. 强烈建议使用UTF编码。"></a>58. 强烈建议使用UTF编码。</h5><h5 id="59-对字符串排序持一种宽容的心态，如果排序不是关键算法，用Collator类即可。"><a href="#59-对字符串排序持一种宽容的心态，如果排序不是关键算法，用Collator类即可。" class="headerlink" title="59. 对字符串排序持一种宽容的心态，如果排序不是关键算法，用Collator类即可。"></a>59. 对字符串排序持一种宽容的心态，如果排序不是关键算法，用Collator类即可。</h5><h1 id="第五章，数组和集合"><a href="#第五章，数组和集合" class="headerlink" title="第五章，数组和集合"></a>第五章，数组和集合</h1><h5 id="60-性能考虑，数组是首选，集合类的底层都是通过数组实现的，基本类型在栈内存中操作的-速度快，容量小-，而对象则是在堆内存中操作的-速度慢，容量大-。性能要求较高的时候用数组代替集合。"><a href="#60-性能考虑，数组是首选，集合类的底层都是通过数组实现的，基本类型在栈内存中操作的-速度快，容量小-，而对象则是在堆内存中操作的-速度慢，容量大-。性能要求较高的时候用数组代替集合。" class="headerlink" title="60. 性能考虑，数组是首选，集合类的底层都是通过数组实现的，基本类型在栈内存中操作的(速度快，容量小)，而对象则是在堆内存中操作的(速度慢，容量大)。性能要求较高的时候用数组代替集合。"></a>60. 性能考虑，数组是首选，集合类的底层都是通过数组实现的，基本类型在栈内存中操作的(速度快，容量小)，而对象则是在堆内存中操作的(速度慢，容量大)。性能要求较高的时候用数组代替集合。</h5><h5 id="61-若有必要，使用变长数组，"><a href="#61-若有必要，使用变长数组，" class="headerlink" title="61. 若有必要，使用变长数组，"></a>61. 若有必要，使用变长数组，</h5><p>数组扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] expandpacity(T[] datas, <span class="keyword">int</span> newLen) &#123;</span><br><span class="line">			newLen = newLen&lt;<span class="number">0</span>?<span class="number">0</span>:newLen;</span><br><span class="line">			<span class="keyword">return</span>  Arrays.copyOf(datas, newLen);		</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		demo []de= <span class="keyword">new</span> demo[<span class="number">30</span>];</span><br><span class="line">		de = expandpacity(de,<span class="number">60</span>);						</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合的长度自动维护功能的原理与此类似。</p>
<h5 id="62-警惕数组的浅拷贝，数组的copyOf方法产生的数组为一个浅拷贝，与序列化的浅拷贝相同，基本类型拷贝值，其他拷贝地址，集合的clone方法也为浅拷贝，"><a href="#62-警惕数组的浅拷贝，数组的copyOf方法产生的数组为一个浅拷贝，与序列化的浅拷贝相同，基本类型拷贝值，其他拷贝地址，集合的clone方法也为浅拷贝，" class="headerlink" title="62. 警惕数组的浅拷贝，数组的copyOf方法产生的数组为一个浅拷贝，与序列化的浅拷贝相同，基本类型拷贝值，	其他拷贝地址，集合的clone方法也为浅拷贝，"></a>62. 警惕数组的浅拷贝，数组的copyOf方法产生的数组为一个浅拷贝，与序列化的浅拷贝相同，基本类型拷贝值，	其他拷贝地址，集合的clone方法也为浅拷贝，</h5><ul>
<li>浅拷贝(浅复制、浅克隆)：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。　换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</li>
<li>深拷贝(深复制、深克隆)：被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。继承自java.lang.Object类的clone()方法是浅复制。</li>
</ul>
<h5 id="63-在明确的场景下，为集合指定初始容量，ArrayList中java实现长度的动态管理。如果不设置初始容量，系统就按照1-5倍的规则扩充，每一次扩充都是一次数组拷贝。"><a href="#63-在明确的场景下，为集合指定初始容量，ArrayList中java实现长度的动态管理。如果不设置初始容量，系统就按照1-5倍的规则扩充，每一次扩充都是一次数组拷贝。" class="headerlink" title="63. 在明确的场景下，为集合指定初始容量，ArrayList中java实现长度的动态管理。如果不设置初始容量，系统就按照1.5倍的规则扩充，每一次扩充都是一次数组拷贝。"></a>63. 在明确的场景下，为集合指定初始容量，ArrayList中java实现长度的动态管理。如果不设置初始容量，系统就按照1.5倍的规则扩充，每一次扩充都是一次数组拷贝。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    	ensureCapacity(size + <span class="number">1</span>);<span class="comment">//扩展长度。</span></span><br><span class="line">    	elementData[size++] = e;<span class="comment">//追加元素</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span>&#123;</span><br><span class="line">			modCount++;<span class="comment">//修改计数器</span></span><br><span class="line">			<span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//上次数组长度</span></span><br><span class="line">			<span class="keyword">if</span>(minCapcity&gt;oldCapacity) &#123;</span><br><span class="line">				Object oldDate[] = elementDate;</span><br><span class="line">				<span class="comment">//计算新数组长度。</span></span><br><span class="line">				<span class="keyword">int</span> newCapacity = (oldCapacity*<span class="number">3</span>)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(newCapacity&lt;minCapacity) </span><br><span class="line">					newcapacity =  minCapacity;</span><br><span class="line">					<span class="comment">//数组拷贝，生成新数组</span></span><br><span class="line">					elementDate = Arrays.copyof(elementDate,newCapacity);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//并不是增加一个元素elementDate的长度就加1，而是在达到elementDate长度的临界点，才将elementDate元素扩充1.5倍。</span></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//指定长度的有参构造函数</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">if</span>(initialCapacity&lt;<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">this</span>.elementDate = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>vector的处理方式与ArrayList的长度处理相似，不同的地方是提供递增步长(capacityIncrement变量)。不设置容量翻倍。HashMap是按照倍数增加的。</p>
<h5 id="64-多种最值算法，适时选择，使用集合最简单，使用数组性能最优。"><a href="#64-多种最值算法，适时选择，使用集合最简单，使用数组性能最优。" class="headerlink" title="64. 多种最值算法，适时选择，使用集合最简单，使用数组性能最优。"></a>64. 多种最值算法，适时选择，使用集合最简单，使用数组性能最优。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> [] data)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> max = data[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i:data) &#123;</span><br><span class="line">				max = max &gt;i?max:i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> max;</span><br><span class="line">		&#125;<span class="comment">//自行实现，速度最快</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> [] data)</span> </span>&#123;</span><br><span class="line">		Arrays.sort(data.clone());</span><br><span class="line">		<span class="keyword">return</span> data[data.length-<span class="number">1</span>];</span><br><span class="line">	&#125;<span class="comment">//先排序后取值</span></span><br><span class="line">	<span class="comment">//查找不重复的仅次于最大值的。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSecond</span><span class="params">(Integer[] data)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; dataList = Arrays.asList(data);<span class="comment">//转换为列表</span></span><br><span class="line">		TreeSet&lt;Intger&gt; ts = <span class="keyword">new</span> TreeSet&lt;Integer&gt;(dataList);<span class="comment">//删除重复元素并升序排序，由TreeSet类实现。</span></span><br><span class="line">		<span class="keyword">return</span> ts.lower(ts.last());<span class="comment">//用lower获取小于最大值的值。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="65-避开基本类型数组转化为列表陷阱，原始数据类型数组不能做为asList的输入参数，否则会引起程序逻辑混乱。"><a href="#65-避开基本类型数组转化为列表陷阱，原始数据类型数组不能做为asList的输入参数，否则会引起程序逻辑混乱。" class="headerlink" title="65. 避开基本类型数组转化为列表陷阱，原始数据类型数组不能做为asList的输入参数，否则会引起程序逻辑混乱。"></a>65. 避开基本类型数组转化为列表陷阱，原始数据类型数组不能做为asList的输入参数，否则会引起程序逻辑混乱。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args )</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> [] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	List&lt;Integer&gt; dataList= Arrays.asList(data);</span><br><span class="line">	System.out.println(<span class="string">&quot;列表中的元素个数为：&quot;</span>+list.size());</span><br><span class="line">	<span class="comment">//asList方法输入的为泛型变长参数，在java中数组为一个对象，它是可以泛型化的，即把int型数组当做T的类型，所以转换后长度为1，调用getclass方法返回：class [I,jvm不能输出Arrays类型，因为Arrays是属于java.lang.reflect包的，它是通过反射访问数组元素的工具类，在java中任何一个数组的类都是“[I”数组类并没有定义，是在编译器编译时生成的，是一个特殊的类，</span></span><br></pre></td></tr></table></figure>
<h5 id="66-asList方法产生的List对象不可更给，"><a href="#66-asList方法产生的List对象不可更给，" class="headerlink" title="66. asList方法产生的List对象不可更给，"></a>66. asList方法产生的List对象不可更给，</h5><p> 调用add方法会抛不支持的操作的异常，基于Arrays的ArrayList是一个静态私有内部类，除了Arrays能访问以外，其他类都不能访问，且add方法为ArrayList的父类提供，但是没有具体的实现，Arrays的内部类没有覆写add方法。<br> ArrayList静态内部类实现了5 个方法。s<br> ize(元素数量)，toArray(转化为数组)，get(获取指定元素)，set(重置某一元素)，container(是否包含某个元素)，方法 ，没有实现add和remove方法，<br> 即asList返回的为一个长度不可变的列表，数组为多长转换为列表为多长，即不在保持列表动态变长的特性。List<String>names &#x3D; Arrays.asList(“”,””,””);不可取，列表长度不可修改；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.RandomAccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">asList_Demo</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 报不支持 的操作异常，	java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment"> * List的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;Sun,Mon,Tue,Wed,Thu,Fri,Sat&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Week[] workDays = &#123;Week.Mon,Week.Tue,Week.Wed,Week.Thu,Week.Fri&#125;;</span><br><span class="line">		List&lt;Week&gt; list = Arrays.asList(workDays);</span><br><span class="line">		list.add(Week.Sat);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * asList method 源码，直接new一个ArrayList对象并返回，</span></span><br><span class="line"><span class="comment">	 * 此ArrayList非java.util.ArrayList，而不是Arrays的工具类。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt;asList(T...a)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ArrayList类为Arrays的内置类，构造函数：为一个静态私有的内部类，没有提供add方法，即只能是</span></span><br><span class="line"><span class="comment">	 * AbstractList提供，但父类提供的add方法没有提供具体的实现，需要覆写。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">	                          <span class="title">RandomAccess</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> E[];</span><br><span class="line">		ArrayList(E[] array)&#123;</span><br><span class="line">			<span class="keyword">if</span>(array ==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">			&#125;</span><br><span class="line">			a = array;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="67-不同的列表选择不同的遍历方法，"><a href="#67-不同的列表选择不同的遍历方法，" class="headerlink" title="67.不同的列表选择不同的遍历方法，"></a>67.不同的列表选择不同的遍历方法，</h5><p> <code>对于 ArrayList数组for循环下标方式要比foreach遍历快，</code><br><code> 对于LinkedList类讲，foreach方法要比fo循环方法快，</code><br> ArrayList数组为随机存取列表，LinkedList为有序存取列表(实现了双向链表，每个数据节点有三个数据项前节点引用(Previons)，本节点元素(Node element)，后继节点的引用(Next Node ))。ArrayList数组实现了RandomAccess接口(随机存取接口)，即为一个随机存取的列表，数据元素之间没有关联，没有依赖和索引关系，<br> <code>Java中，RandomAccess(随机存取)和Cloneble(可以拷贝)。Serializable(可以序列化)接口一样，为标志性接口，不需要任何实现，只是用来表明实现类具有某种性质，</code><br> <code> java中foreach语句为iterator(迭代器)的变形使用</code>，即迭代器为23种设计模式的一种，提供一种方法访问一个容器中对象的各个元素，同时又无需暴露内部细节，对于ArrayList来讲，创建一个迭代器，然后屏蔽内部遍历细节，提供hasnext，next等方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.AbstractList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.RandomAccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">asList_Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> stuNum = <span class="number">80</span>*<span class="number">10000</span>;</span><br><span class="line">		<span class="comment">//实例化List集合，并指定初始容量。</span></span><br><span class="line">		List&lt;Integer&gt; scores = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(stuNum);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt;stuNum ;i++) &#123;</span><br><span class="line"><span class="comment">//返回一个伪随机数，它是取自此随机数生成器序列的、在 0(包括)和指定值(不包括)之间均匀分布的 int 值。</span></span><br><span class="line">			scores.add(<span class="keyword">new</span> Random().nextInt(<span class="number">150</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;平均分是：&quot;</span>+average(scores));</span><br><span class="line">		System.out.println(<span class="string">&quot;执行时间：&quot;</span>+(System.currentTimeMillis()-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//foreach语句遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i:list) &#123;</span><br><span class="line">			sum = sum+i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum/list.size();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下标遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum  = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,size=list.size();i&lt;size;i++) &#123;</span><br><span class="line">			sum += list.get(i); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum/list.size();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * foreach 原理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span>(Iterator&lt;Integer&gt;i = list.iterator();i.hasNext();) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适用用于有序存取列表和随机存取列表。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum  =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,size = list.size();i&lt;size;i++) &#123;</span><br><span class="line">				sum += list.get(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i:list) &#123;</span><br><span class="line">				sum +=i; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum/list.size();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//LinkList 下标遍历法；</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> entry(index).element;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(E)</span> <span class="title">entry</span><span class="params">( <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">		Entry&lt;E&gt; e = heder;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; (size&gt;&gt;<span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;= index; i++)</span><br><span class="line">				e = e.next;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = size; i&gt;index; i++) &#123;</span><br><span class="line">				e = e.previous;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> e;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="68-频繁插入和删除时使用LinkedList，"><a href="#68-频繁插入和删除时使用LinkedList，" class="headerlink" title="68.频繁插入和删除时使用LinkedList，"></a>68.频繁插入和删除时使用LinkedList，</h5><p> LinkedList的插入效率要比ArrayList快 50倍，删除要比ArrayList快40倍，修改要慢ArrayList许多，ArrayList在写操作时要慢Lnkedlist；</p>
<h5 id="69-列表相等只需关心元素数据，"><a href="#69-列表相等只需关心元素数据，" class="headerlink" title="69.列表相等只需关心元素数据，"></a>69.列表相等只需关心元素数据，</h5><p> 在java中，列表只是一个容器，只要是同一种类型的容器(List)，不会关心容器的细微差(ArrayList和Kinkedlist两者都实现了LIst接口继承了AbstractList抽象类，equals方法在抽象类中定义。),只要确定所有元素数据，个数相等即可，Set，Map与此相同。判断集合是否相等，只需要判断元素是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//是否为自身</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//是否为List的实现类，即是否为List列表</span></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//返回列表元素的迭代器，访问所有的元素进行比较。</span></span><br><span class="line">        ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">        ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">        <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">            E o1 = e1.next();</span><br><span class="line">            Object o2 = e2.next();</span><br><span class="line">            <span class="comment">//当都为空不执行，一个为空false，都不为空equals比较。</span></span><br><span class="line">            <span class="keyword">if</span> (!(o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断长度是否相等。</span></span><br><span class="line">        <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h5 id="70-子列表只是原列表的一个视图，"><a href="#70-子列表只是原列表的一个视图，" class="headerlink" title="70.子列表只是原列表的一个视图，"></a>70.子列表只是原列表的一个视图，</h5><p>List提供一个subList方法,与String的subString有点类似，subList方法是由AbstractList实现的，它会根据是不是随机存储提供不同的实现方法，SubList返回的类也是AbstractList的子类，其所有的方法(get,add,set,remove等)都是在原始列表上操作的，它自身并没有生成一个数组或是链表，也就是子列表只是原列表的一个视图(View),所有的修改都反映在原列表上。<br>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; c = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		c.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		List&lt;String&gt; c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;(c);</span><br><span class="line">		List&lt;String&gt; c2 = c.subList(<span class="number">0</span>, c.size());</span><br><span class="line">		c2.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;c==c1&quot;</span>+c.equals(c1));</span><br><span class="line">		System.out.println(<span class="string">&quot;c==c2&quot;</span>+c.equals(c2));</span><br></pre></td></tr></table></figure>
<h5 id="71-推存使用subList处理局部列表，"><a href="#71-推存使用subList处理局部列表，" class="headerlink" title="71.推存使用subList处理局部列表，"></a>71.推存使用subList处理局部列表，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; initate = Collections.nCopies(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o)</span></span><br><span class="line">		<span class="comment">//返回由指定对象的 n 个副本组成的不可变列表。</span></span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(initate);</span><br><span class="line">		<span class="comment">//转换为可变列表。</span></span><br><span class="line">		<span class="comment">//list.subList(20, 30).clear();</span></span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,size=list.size();i&lt;size;i++) &#123;</span><br><span class="line">	    	<span class="keyword">if</span>(i&gt;=<span class="number">20</span>&amp;&amp;i&lt;<span class="number">30</span>) &#123;</span><br><span class="line">	    		list.remove(i);</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="72-生成子列表后不要在操作原列表"><a href="#72-生成子列表后不要在操作原列表" class="headerlink" title="72.生成子列表后不要在操作原列表"></a>72.生成子列表后不要在操作原列表</h5><p> ，操作抛出java.util.ConcurrentModificationException并发修改异常，因为subLis取出的列表只是原列表的一个视图，原数据集修改了，但是subList取出的子列表不会重新生成一个新列表，后面的对子列表继续操作时，就会检测到修改计数器与预期的不相同，会抛出并发修改异常，subList的其他方法也会检测修改计数器，例如Set，get，add方法，如果生成子列表在操作原列表，必然会导致视图不稳定，有效的办法是通过Collections.unmodifiableList方法设置列表为只读状态当有多个字列表时，任何一个子列表就都不能修改啦。生成子列表后，原列表保持只读状态。防御式编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	    list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	    list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">	    list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">	    List&lt;String&gt;subList = list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">	    list.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">	    System.out.println(<span class="string">&quot;原列表的长度：&quot;</span>+list.size());</span><br><span class="line">	    System.out.println(<span class="string">&quot;子列表偶的长度：&quot;</span>+subList.size());</span><br><span class="line">	    抛出异常：Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException；</span><br><span class="line"><span class="comment">//设置列表为只读状态。	    </span></span><br><span class="line">List&lt;String&gt;list  = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		List&lt;String&gt; subList = list.subList(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="comment">//unmodifiableList(List&lt;?y extends T&gt; list) </span></span><br><span class="line">        <span class="comment">//返回指定列表的不可修改视图。</span></span><br><span class="line">		list = Collections.unmodifiableList(list);  </span><br></pre></td></tr></table></figure>

<h5 id="73-使用Comparator进行排序，"><a href="#73-使用Comparator进行排序，" class="headerlink" title="73.使用Comparator进行排序，"></a>73.使用Comparator进行排序，</h5><p> 在java中，要想给数据进行排序，有两种事项方式，一种为实现Comparable接口，一种是实现Comparator接口，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。实现此接口的对象列表(和数组)可以通过 Collections.sort(和 Arrays.sort)进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。<br>int compareTo(T o)比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>比较功能，对一些对象的集合施加了一个整体排序 。 可以将比较器传递给排序方法(如Collections.sort或Arrays.sort )，以便对排序顺序进行精确控制。 比较器还可以用来控制某些数据结构(如顺序sorted sets或sorted maps )，或对于不具有对象的集合提供的排序natural ordering ，与Comparable不同，比较器可以可选地允许比较空参数，同时保持对等价关系的要求。<br>int compare(T o1, T o2) 比较其两个参数的顺序。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liruilong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : 集合排序整理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Liruilong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/7/31 22:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compara</span> <span class="keyword">implements</span>  <span class="title">Comparable</span>&lt;<span class="title">Compara</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> Liruilong</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> public interface Comparable&lt;T&gt;</span></span><br><span class="line"><span class="comment">     * 此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，</span></span><br><span class="line"><span class="comment">     * 类的 compareTo 方法被称为它的自然比较方法。</span></span><br><span class="line"><span class="comment">     * 实现此接口的对象列表(和数组)可以通过 Collections.sort(和 Arrays.sort)进行自动排序。</span></span><br><span class="line"><span class="comment">     * 实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</span></span><br><span class="line"><span class="comment">     * int compareTo(T o)比较此对象与指定对象的顺序。</span></span><br><span class="line"><span class="comment">     * 如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 22:54 2019/7/31</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [o]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Compara o)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// (x == 1) ? -1 : ((x == 2) ? 0 : ((x == 3) ? 1:((x == 4) ? 3 : ))) 代替 if -else if。</span></span><br><span class="line">       <span class="keyword">return</span>  (<span class="keyword">this</span>.data &lt; o.data) ? -<span class="number">1</span> : ((<span class="keyword">this</span>.data == o.data) ? <span class="number">0</span>: <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Compara&gt; comparaList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//方法一 集合元素实现了Comparable 接口，直接用工具类排序</span></span><br><span class="line">        Collections.sort(comparaList);</span><br><span class="line">        <span class="comment">// 方法二 在排序时将比较器传入</span></span><br><span class="line">        Collections.sort(comparaList, (Compara o1, Compara o2) -&gt;o1.compareTo(o2) );</span><br><span class="line">        <span class="comment">//方法三，通过Comparator传入一个比较器</span></span><br><span class="line">        comparaList.sort((Compara o1,Compara o2) -&gt;o1.compareTo(o2));</span><br><span class="line">        comparaList.sort(<span class="keyword">new</span> java.util.Comparator&lt;Compara&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Author</span> Liruilong </span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Description</span> 针对一些本身没有比较能力的对象(数组)为它们实现比较的功能，</span></span><br><span class="line"><span class="comment">             * 所以它叫做比较器，是一个外部的东西，通过它定义比较的方式，</span></span><br><span class="line"><span class="comment">             * 再传到Collection.sort()和Arrays.sort()中对目标排序，</span></span><br><span class="line"><span class="comment">             * 而且通过自身的方法compare()定义比较的内容和结果的升降序；</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Date</span> 23:16 2019/7/31</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Param</span> [o1, o2] </span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> int </span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Compara o1, Compara o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getData()== o2.getData())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.getData() &lt; o2.getData()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="74-不推存使用binarySearch对队列进行检索。一般使用indexOf方法进行检索，binarySearch使用二分搜索法搜索指定列表，以获得指定的对象，二分法查询，数据要已经实现了升序排序。但是binarySearch在性能上要比indexOf好。"><a href="#74-不推存使用binarySearch对队列进行检索。一般使用indexOf方法进行检索，binarySearch使用二分搜索法搜索指定列表，以获得指定的对象，二分法查询，数据要已经实现了升序排序。但是binarySearch在性能上要比indexOf好。" class="headerlink" title="74.不推存使用binarySearch对队列进行检索。一般使用indexOf方法进行检索，binarySearch使用二分搜索法搜索指定列表，以获得指定的对象，二分法查询，数据要已经实现了升序排序。但是binarySearch在性能上要比indexOf好。"></a>74.<code>不推存使用binarySearch对队列进行检索</code>。一般使用indexOf方法进行检索，binarySearch使用二分搜索法搜索指定列表，以获得指定的对象，二分法查询，数据要已经实现了升序排序。但是binarySearch在性能上要比indexOf好。</h5><h5 id="75-集合中的元素必须-做到compareTo和equals同步：实现了Comparable接口的元素就可以排序，compareTo方法是Comparable接口要求必须实现的。当返回0时，表示进行比较的两个元素是相等的，indexOf检索方法是通过equals方法判断的，binarySearch则依赖compare方法查找，不懂？？？？？"><a href="#75-集合中的元素必须-做到compareTo和equals同步：实现了Comparable接口的元素就可以排序，compareTo方法是Comparable接口要求必须实现的。当返回0时，表示进行比较的两个元素是相等的，indexOf检索方法是通过equals方法判断的，binarySearch则依赖compare方法查找，不懂？？？？？" class="headerlink" title="75.集合中的元素必须 做到compareTo和equals同步：实现了Comparable接口的元素就可以排序，compareTo方法是Comparable接口要求必须实现的。当返回0时，表示进行比较的两个元素是相等的，indexOf检索方法是通过equals方法判断的，binarySearch则依赖compare方法查找，不懂？？？？？"></a>75.集合中的元素必须 做到compareTo和equals同步：实现了Comparable接口的元素就可以排序，compareTo方法是Comparable接口要求必须实现的。当返回0时，表示进行比较的两个元素是相等的，indexOf检索方法是通过equals方法判断的，binarySearch则依赖compare方法查找，不懂？？？？？</h5><h5 id="76-集合运算时使用更优雅的方式，并集，交集，差集。"><a href="#76-集合运算时使用更优雅的方式，并集，交集，差集。" class="headerlink" title="76.集合运算时使用更优雅的方式，并集，交集，差集。"></a>76.集合运算时使用更优雅的方式，并集，交集，差集。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list1.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">		list1.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list2.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">		list2.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">		<span class="comment">//并集</span></span><br><span class="line">		list1.addAll(list2);</span><br><span class="line">		<span class="comment">//交集</span></span><br><span class="line">		list1.retainAll(list2);</span><br><span class="line">		list1.removeAll(list2);</span><br><span class="line">		<span class="comment">//无重复的并集</span></span><br><span class="line">		list2.removeAll(list1);</span><br><span class="line">		list1.addAll(list2);</span><br></pre></td></tr></table></figure>
<h5 id="77-使用shuffle打乱列表，"><a href="#77-使用shuffle打乱列表，" class="headerlink" title="77.使用shuffle打乱列表，"></a>77.使用shuffle打乱列表，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tagCloudNum = <span class="number">10</span>;</span><br><span class="line">	List&lt;String&gt; tagClouds = <span class="keyword">new</span> ArrayList&lt;String&gt;(tagCloudNum);</span><br><span class="line">	Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;tagCloudNum;i++) &#123;</span><br><span class="line">		<span class="comment">//获取随机位置；</span></span><br><span class="line">		<span class="keyword">int</span> randPotion  = random.nextInt(tagCloudNum);</span><br><span class="line">		<span class="comment">//当前元素与随机位置元素交换。</span></span><br><span class="line">		String temp = tagClouds.get(i);</span><br><span class="line">		tagClouds.set(i, tagClouds.get(randPotion));</span><br><span class="line">		tagClouds.set(randPotion, temp);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> tagCloudNum = <span class="number">10</span>;</span><br><span class="line">		List&lt;String&gt; tagClouds = <span class="keyword">new</span> ArrayList&lt;String&gt;(tagCloudNum);</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;tagCloudNum;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> randPotion  = random.nextInt(tagCloudNum);</span><br><span class="line">			<span class="comment">//当前元素与随机位置元素交换。</span></span><br><span class="line">			Collections.swap(tagClouds, i, randPotion);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="keyword">int</span> tagCloudNum = <span class="number">10</span>;</span><br><span class="line">		List&lt;String&gt; tagClouds = <span class="keyword">new</span> ArrayList&lt;String&gt;(tagCloudNum);</span><br><span class="line">		Collections.shuffle(tagClouds);</span><br></pre></td></tr></table></figure>
<h5 id="78-减少HashMap中的元素的数量"><a href="#78-减少HashMap中的元素的数量" class="headerlink" title="78.减少HashMap中的元素的数量"></a>78.减少HashMap中的元素的数量</h5><p>HashMap在底层也是以数组的方式保存元素的，每一个键值对就是一个元素，HashMap把键值对封装为Entry对象，然后把Entry放到数组中，HashMap的底层数组变量为table，是Entry类型的数组，保存一个一个的键值对，HashMap也可以动态的增加，大于等于阈值，数组增大一倍，阈值为当前长度与加载因子的乘机，默认加载因子为 0.75，即HashMap的size大于等于数组长度的0.75倍，就开始扩容。</p>
<h5 id="79-集合中的哈希码不要重复"><a href="#79-集合中的哈希码不要重复" class="headerlink" title="79.集合中的哈希码不要重复"></a>79.集合中的哈希码不要重复</h5><p> 随机存取的列表是遍历查找，顺序存储列表是链表查找，或者Collections的二分法查找，HashMap等set集合要快于List集合，HashMap每次增加元素都会先计算器哈希码，然后使用hash方法再次对hashCode进行抽取和统计，同时兼顾哈希码的高位和低位的信息产生唯一值，之后通过indexFor方法与数组长度做一次与运算，计算数组位置，hash的方法和iindexFor方法就是把哈希码转化为数组，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">10000</span>;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(size);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size; i++) &#123;</span><br><span class="line">			list.add(<span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> statc = System.nanoTime();</span><br><span class="line">		<span class="comment">//开始查找</span></span><br><span class="line">		list.contains(<span class="string">&quot;value&quot;</span>+(size-<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">&quot;List时间为：&quot;</span>+(end-statc)+<span class="string">&quot;ns&quot;</span>);</span><br><span class="line">		<span class="comment">//Map 的查找时间</span></span><br><span class="line">		Map  map  =  <span class="keyword">new</span> HashMap&lt;String, String&gt;(size);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size; i++) &#123;</span><br><span class="line">			map.put(<span class="string">&quot;key&quot;</span>+i, <span class="string">&quot;value&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		 statc = System.nanoTime();</span><br><span class="line">		<span class="comment">//开始查找</span></span><br><span class="line">		map.containsKey(<span class="string">&quot;key&quot;</span>+(size-<span class="number">1</span>));</span><br><span class="line">		 end = System.nanoTime();</span><br><span class="line">		System.out.println(<span class="string">&quot;Map 时间为：&quot;</span>+(end-statc)+<span class="string">&quot;ns&quot;</span>);	</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h5 id="80-多线程使用Vector或HashTable，"><a href="#80-多线程使用Vector或HashTable，" class="headerlink" title="80.多线程使用Vector或HashTable，"></a>80.多线程使用Vector或HashTable，</h5><p>Vector是ArrayList的多线程版本，HashTable是HashMap的多线程版本，线程安全和同步修改异常是两个概念，基本上所有集合类都有一个叫做快速失败的校验机制(Ffail-Fast)，当一个集合在被多个线程修改并访问时，就可能会出现ConcurrentModificationException 异常，这是为了确保集合方法一致设置对的保护措施，实现原理为modCount修改统计器，当读取列表是发生变化(其他线程也在操作)，则会抛出异常，也与 线程同步不同，线程同步是为了保护数据不被脏写，脏读而设置的，Vector的每个方法都加上了synchronized，两个线程进行同样的操作才可以讨论线程同步，一个线程删除一个线程增加，不属于多线程范畴。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//火车票列表</span></span><br><span class="line">		<span class="keyword">final</span> List&lt;String&gt;tickets = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="comment">//线程安全：final Vector&lt;String&gt;tickets = new Vector&lt;String&gt;();</span></span><br><span class="line">		<span class="comment">//初始化数据池，</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span> ;i++) &#123;</span><br><span class="line">			tickets.add(<span class="string">&quot;火车票&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//退票</span></span><br><span class="line">		Thread returnThread  = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rnu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">					tickets.add(<span class="string">&quot;车票&quot;</span>+<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//售票</span></span><br><span class="line">		Thread saleThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(String ticket:tickets)</span><br><span class="line">					tickets.remove(ticket);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//启动退票线程</span></span><br><span class="line">		returnThread.start();</span><br><span class="line">		saleThread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;Thread-1&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">937</span>)</span><br><span class="line">	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">891</span>)</span><br><span class="line">	at java_151/java_151.Vector$<span class="number">2.</span>run(Vector.java:<span class="number">28</span>)</span><br><span class="line"><span class="comment">//10个窗口售票</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">						System.out.println(Thread.currentThread().getId()+<span class="string">&quot;---&quot;</span>+tickets.remove(<span class="number">0</span>));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;.start();</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//为线程同步问题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="81-非稳定排序推："><a href="#81-非稳定排序推：" class="headerlink" title="81.非稳定排序推："></a>81.非稳定排序推：</h5><p> 存使用List，Set与List的最大区别为Set中的元素不可以重复(基于equals的返回值)，Set的实现类有一个比较常用的类TreeSet，该类实现了类默认排序为升序Set集合，插入一个元素，默认按照升序排序，SortedSet(TreeSet实现了该接口)接口只是定义了在给集合加入元素时将其进行排序，不能保证修改后的排序结果。所以TreeSet适合不变量的集合数据排序。Sstring或Integer等</p>
<h5 id="82-由点几面，集合大家族："><a href="#82-由点几面，集合大家族：" class="headerlink" title="82.由点几面，集合大家族："></a>82.由点几面，集合大家族：</h5><ul>
<li><p>&#96;<em><strong>List</strong></em>：实现List的集合主要有ArrayList(动态数组)，LinkedList(双向链表)，Vector(线程安全的动态数组)，Stack(对象栈，先进后出)。</p>
</li>
<li><p><em><strong>Set</strong></em>： 不包含重复元素的集合，其主要的实现类有：EnumSet(枚举类型专用，所有为枚举类型)，HashSet(以哈希码决定元素位置，与HashMap相似，提供快速插入和查找)，TreeSet(自动排序Set，实现了SortedSet接口)</p>
</li>
<li><p><em><strong>Map</strong></em>：分为排序Map和非排序Map，排序Map主要是TreeMap类，根据Key值进行自动排序，非排序Map主要包括：HashMap，HsahTable，Properties，EnumMap等，其中Properties是HashTable的子类，它的主要用途从property文件中加载数据，并提供方便的读写操作:EnumMap则要求Key必须为某一个枚举类型。Map中还有一个weakHashMap类，采用弱键方式实现的Map类，WeakHashMap对象的存在并不会阻止垃圾回收器对键值对的回收，即不用担心内存溢出问题。</p>
</li>
<li><p><em><strong>Query</strong></em>：队列，分为阻塞式队列和非阻塞式队列，阻塞式队列主要包括：ArrayBlockingQuery(以数组方式实现的有借阻塞数组)，PrinonityBoockingQuery(依照优先级组建的队列)，LinkedBlockingQuery(通过链表实现的阻塞队列)，非阻塞式队列，PrinonityQuery类.</p>
</li>
<li><p><em><strong>数组</strong></em>：数组与集合的最大区别就是数组能够容纳基本类型，而集合不行，且数组为非动态，集合的底层都是数组。</p>
</li>
<li><p><em><strong>工具类</strong></em>：数组的工具类时java.util.Arrays和java.lang.reflect.Array,集合的工具类是java.util.Collections.</p>
</li>
</ul>
<h1 id="第六章，-枚举和注解"><a href="#第六章，-枚举和注解" class="headerlink" title="第六章， 枚举和注解"></a>第六章， 枚举和注解</h1><h5 id="83-推存使用枚举定义常量，"><a href="#83-推存使用枚举定义常量，" class="headerlink" title="83.推存使用枚举定义常量，"></a>83.推存使用枚举定义常量，</h5><p> JLS(Java Language Specification，java语言规范)，提倡枚举全部大写，枚举常量简单，属于稳定型，具有内置方法，可以自定义方法，</p>
<h5 id="84-使用构造函数协助描述枚举项"><a href="#84-使用构造函数协助描述枚举项" class="headerlink" title="84.使用构造函数协助描述枚举项"></a>84.使用构造函数协助描述枚举项</h5><p> 枚举描述，通过枚举的构造函数，声明每个枚举项必须具有的属性的行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">	Spring(<span class="string">&quot;春&quot;</span>),Summer(<span class="string">&quot;夏&quot;</span>),Autumn,Winter;</span><br><span class="line">	<span class="keyword">private</span>  String desc;</span><br><span class="line">	Season(String desc)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.desc = desc;</span><br><span class="line">	&#125;</span><br><span class="line">	Season()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> desc;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="85-小心Switch带来的空值异常，"><a href="#85-小心Switch带来的空值异常，" class="headerlink" title="85.小心Switch带来的空值异常，"></a>85.小心Switch带来的空值异常，</h5><p> java中Switch可以判断byte，short，int，char即String类型，枚举也可以更在Sewitch后面，原因是switch先计算变量的排序值，然后与枚举常量的每个排序值进行对比，当变量为空时，调用ordinal方法报空指针异常。所以需要判断。switch(s) &#x3D;s.ordinal；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enums</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Season s: Season.values())</span><br><span class="line">			System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">(Season s)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">switch</span>(s) &#123;</span><br><span class="line">	<span class="keyword">case</span> Spring:</span><br><span class="line">            System.out.println(Season.Spring);<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Winter:</span><br><span class="line">		    System.out.println(Season.Winter);<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> Summer:</span><br><span class="line">		    System.out.println(Season.Summer);<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="86-在switch的default代码块中增加AssertionError错误。当有不存在枚举时需要。"><a href="#86-在switch的default代码块中增加AssertionError错误。当有不存在枚举时需要。" class="headerlink" title="86.在switch的default代码块中增加AssertionError错误。当有不存在枚举时需要。"></a>86.在switch的default代码块中增加AssertionError错误。当有不存在枚举时需要。</h5><h5 id="87-使用valueOf前必须进行校验，"><a href="#87-使用valueOf前必须进行校验，" class="headerlink" title="87.使用valueOf前必须进行校验，"></a>87.使用valueOf前必须进行校验，</h5><p> 枚举类都是java.lang.Enum的子类，可以访问hashCode，name，valueOf等方法，valueOf会在枚举项中查找出字面值与参数相等的枚举项，当不存在时会报错。rllegalArrumentExcep。可以抛出异常</p>
<h5 id="88-用枚举实现工厂方法模式更简洁。"><a href="#88-用枚举实现工厂方法模式更简洁。" class="headerlink" title="88.用枚举实现工厂方法模式更简洁。"></a>88.用枚举实现工厂方法模式更简洁。</h5><p> ：工厂模式(Factory Method Pattern)即创建对象的接口，让子类决定实例化哪一个类，并使一个类的实例化延迟到其子类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"><span class="comment">//抽象产品</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FordCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulickCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">//生产汽车</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CarFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(Class&lt;? extends Car&gt; c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> (Car)c.newInstance();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Car car = CarFactory.createCar(FordCar.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举方法：</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">	<span class="comment">//定义工厂类能生产汽车的类型</span></span><br><span class="line">	FordCar,BulickCar;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> FordCar:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> FordCar();</span><br><span class="line">		<span class="keyword">case</span> BulickCar:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BulickCar();</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;无效参数&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Car car = CarFactory.BulickCar.create();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象方法生成产品，eclipse报错误</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">	FordCar&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> FordCar();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	BulickCar&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BulickCar();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用枚举类的工厂方法模式，可以避免错误调用的发生，性能好，使用便捷，降低类的耦合性最少知识原则(一个对象应该对其他对象有最少的了解，LoD)。</p>
<h5 id="89-枚举项的数量限制在64个以内"><a href="#89-枚举项的数量限制在64个以内" class="headerlink" title="89.枚举项的数量限制在64个以内"></a>89.枚举项的数量限制在64个以内</h5><p> java提供个两个枚举项，EnumSet和EnumMap，Enum表示元素必须是某一枚举的枚举项，EnumMap表示Key值必须是某一枚举项，Java的处理机制当枚举项数量小于等于64时，创建一个RegularEnumSet实例对象，大于64小时则创建一个jumboEnumSet 实例对象。枚举项的排序值ordinal是从0.1.2.3……依次递增的，没有重号，没有跳号，RegularEnumSet利用这点吧每个枚举项的ordinal映射到一个long类型的每个位上，long类型为64 位，所以RegularEnumSet类型就只能负责不大于64位。</p>
<h5 id="90-小心注解的继承，"><a href="#90-小心注解的继承，" class="headerlink" title="90.小心注解的继承，"></a>90.小心注解的继承，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> li rui long</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span><span class="comment">//保留策略</span></span><br><span class="line"><span class="meta">@Target(java.lang.annotation.ElementType.TYPE)</span><span class="comment">//注解的使用范围</span></span><br><span class="line"><span class="meta">@Inherited</span><span class="comment">//父类被子类继承，子类自动修饰。</span></span><br><span class="line"><span class="meta">@interface</span> Desc&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">		White,Grayish,Yellow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Color <span class="title">c</span><span class="params">()</span> <span class="keyword">default</span> Color.White</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="91-枚举与注解结合使用威力更强大。分析ACM-Access-Control-List-访问控制列表-，ACM要求，资源，权限级别，控制器。"><a href="#91-枚举与注解结合使用威力更强大。分析ACM-Access-Control-List-访问控制列表-，ACM要求，资源，权限级别，控制器。" class="headerlink" title="91.枚举与注解结合使用威力更强大。分析ACM(Access Control List,访问控制列表)，ACM要求，资源，权限级别，控制器。"></a>91.枚举与注解结合使用威力更强大。分析ACM(Access Control List,访问控制列表)，ACM要求，资源，权限级别，控制器。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span><span class="comment">//保留策略</span></span><br><span class="line"><span class="meta">@Target(java.lang.annotation.ElementType.TYPE)</span><span class="comment">//注解的使用范围</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> Access&#123;</span><br><span class="line">	<span class="function">CommonIdentifier <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> CommonIdentifier.Admin</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Identifier</span></span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	String PEFUSE_WORD = <span class="string">&quot;您无权访问&quot;</span>;</span><br><span class="line">	<span class="comment">//鉴定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">identify</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CommonIdentifier</span> <span class="keyword">implements</span> <span class="title">Identifier</span></span>&#123;</span><br><span class="line">	Reader,Author,Admin </span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">identify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Access(level = CommonIdentifier.Author)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Foo b= <span class="keyword">new</span> Foo();</span><br><span class="line">		<span class="comment">//获取注释</span></span><br><span class="line">		Access access = b.getClass().getAnnotation(Access.class);</span><br><span class="line">		<span class="comment">//没有注释或鉴定失败</span></span><br><span class="line">		<span class="keyword">if</span>(access == <span class="keyword">null</span>|| access.level().identify()) &#123;</span><br><span class="line">			<span class="comment">//没有access注解或者鉴定失败</span></span><br><span class="line">			System.out.println(access.level().PEFUSE_WORD);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="92-注意-Override不同版本的区别，在1-6版本中可以在实现接口中加上-Override，而以下版本父类必须是一个类，子类方法和父类方法必须具有相同的方法名，输入参数，输出参数-允许缩小-，访问权限-允许类扩大-。"><a href="#92-注意-Override不同版本的区别，在1-6版本中可以在实现接口中加上-Override，而以下版本父类必须是一个类，子类方法和父类方法必须具有相同的方法名，输入参数，输出参数-允许缩小-，访问权限-允许类扩大-。" class="headerlink" title="92.注意@Override不同版本的区别，在1.6版本中可以在实现接口中加上@Override，而以下版本父类必须是一个类，子类方法和父类方法必须具有相同的方法名，输入参数，输出参数(允许缩小)，访问权限(允许类扩大)。"></a>92.注意@Override不同版本的区别，在1.6版本中可以在实现接口中加上@Override，而以下版本父类必须是一个类，子类方法和父类方法必须具有相同的方法名，输入参数，输出参数(允许缩小)，访问权限(允许类扩大)。</h5><hr>
<h1 id="第七章，泛型和反射"><a href="#第七章，泛型和反射" class="headerlink" title="第七章，泛型和反射"></a>第七章，泛型和反射</h1><p>泛型可减少强制类型的转换，规范集合的元素类型，提高代码的安全性和可读性，优先使用泛型</p>
<h5 id="93-Java的泛型是类型擦除的"><a href="#93-Java的泛型是类型擦除的" class="headerlink" title="93.Java的泛型是类型擦除的"></a>93.Java的泛型是类型擦除的</h5><p>Java泛型(Generic)的引入加强了参数类型的安全性，减少了乐行的转化，Java泛型在编译期有效，在运行期被删除，即泛型参数类型在编译后都会被清除掉。<br>转化规则：<br>List&lt; String&gt;,List&lt; Integer&gt;,List<T>擦除后的类型为List<br>List&lt; String&gt;[]，类型擦除后是List[];<br>List&lt;? extends E&gt;,List&lt;? super E&gt;擦除后的类型为List<E>.<br>List&lt;T extends Serializable &amp; Cloneable&gt;擦除后为List&lt; Serializable&gt;<br>Java中泛型的class对象都是相同的，泛型数组初始化时不能声明泛型类型，instanceof不允许存在泛型参数，<br>即&#96;List&lt; String &gt;[] listArray &#x3D; new List&lt; String&gt;[];’编译不成功。<br>System.out.prinln(list instanceof List&lt; String&gt;);编译不通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayMethod</span><span class="params">(String[] strArray)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayMethod</span><span class="params">(Integer[] intArray )</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMethod</span><span class="params">(List&lt;String&gt; stringList)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listMethod</span><span class="params">(List&lt;Integer&gt; intList)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//无法通过编译</span></span><br><span class="line"><span class="function">Erasure of method <span class="title">listMethod</span><span class="params">(List&lt;Integer&gt;)</span> is the same as another method in type Generic</span></span><br></pre></td></tr></table></figure>
<h5 id="94-不能初始化泛型参数和数组，"><a href="#94-不能初始化泛型参数和数组，" class="headerlink" title="94.不能初始化泛型参数和数组，"></a>94.不能初始化泛型参数和数组，</h5><p> <code>new T();,new T(5)</code>都不能通过，new ArrayList&lt; T&gt;()可以通过。ArrayList表面是泛型，其实已经在编译期转型为Object了，数组允许协变(Covariant)，即可以容纳所有对象，类的成员变量是在类初始化前初始化的，所有要求在初始化前它必须具有明确的类型，否则则就只能申明，不能初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class acces</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用泛型数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//由构造函数初始化</span></span><br><span class="line">	<span class="keyword">private</span> T t;</span><br><span class="line">	<span class="keyword">private</span> T[] tArray;</span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;(); </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; tType = Class.forName(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			t = (T)Array.newInstance(tType, <span class="number">5</span>);</span><br><span class="line">			<span class="comment">//创建一个具有指定的组件类型和长度的新数组。</span></span><br><span class="line">			<span class="comment">//Array 类提供了动态创建和访问 Java 数组的方法。 Array 允许在执行 get 或 set 操作期间进行扩展转换，但如果发生收缩转换，则抛出 IllegalArgumentException。 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="95-强制声明泛型的实际类型，强制类型转换，"><a href="#95-强制声明泛型的实际类型，强制类型转换，" class="headerlink" title="95.强制声明泛型的实际类型，强制类型转换，"></a>95.强制声明泛型的实际类型，强制类型转换，</h5><p> List&lt; Object &gt;与List&lt; Integer &gt;没有继承关系，不能进行强制转换，强制声明泛型类型，List&lt; Integer &gt; list2 &#x3D; ArrayUtils.&lt; Integer &gt;asList();即通过声明	强制确定类型。</p>
<h5 id="96-不同的场景使用不同的泛型通配符，"><a href="#96-不同的场景使用不同的泛型通配符，" class="headerlink" title="96.不同的场景使用不同的泛型通配符，"></a>96.不同的场景使用不同的泛型通配符，</h5><p> Java泛型支持通配符，可以使用“？”，表示任意类，也可以使用extends 关键字表示某一个类的(接口)的子类型，可以使用super关键字表示某一个类(接口)的父类。<br> 如果一个泛型结构即用作读操作，又用作写操作，使用确切的泛型类型即可。</p>
<ul>
<li>在泛型结构中，只参与“读”操作则限定上界(extends):</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;? extends list&gt;)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>( E e:list) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型结构只参与”写“操作则限定下界(super)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;? <span class="keyword">super</span>  Number&gt; lsit)</span></span>&#123;</span><br><span class="line">    lsit.add(<span class="number">123</span>);</span><br><span class="line">    lsit.add(<span class="number">33.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK的Collections.comp方法实现了把源列表中的所有元素拷贝到目标列表对应的索引上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcSize = src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="keyword">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (i)nt i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="97-警惕泛型是不能协变和逆变的。协变，即指窄类型替换宽类型的，逆变即宽类型覆盖窄类型。泛型不支持协变，但可以使用通配符-Wildcard-模拟协变。泛型不支持逆变，即不能把一个父类对象赋值给一个子类类型变量，可以使用super实现。"><a href="#97-警惕泛型是不能协变和逆变的。协变，即指窄类型替换宽类型的，逆变即宽类型覆盖窄类型。泛型不支持协变，但可以使用通配符-Wildcard-模拟协变。泛型不支持逆变，即不能把一个父类对象赋值给一个子类类型变量，可以使用super实现。" class="headerlink" title="97.警惕泛型是不能协变和逆变的。协变，即指窄类型替换宽类型的，逆变即宽类型覆盖窄类型。泛型不支持协变，但可以使用通配符(Wildcard)模拟协变。泛型不支持逆变，即不能把一个父类对象赋值给一个子类类型变量，可以使用super实现。"></a>97.警惕泛型是不能协变和逆变的。协变，即指窄类型替换宽类型的，逆变即宽类型覆盖窄类型。泛型不支持协变，但可以使用通配符(Wildcard)模拟协变。泛型不支持逆变，即不能把一个父类对象赋值给一个子类类型变量，可以使用super实现。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类的doStuff()方法返回值的类型比父类方法要窄，即该方法为协变方法，也称多态。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Number <span class="title">doStuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sub</span> <span class="keyword">extends</span> <span class="title">Bean</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Integer <span class="title">doStuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类的doSutff方法返回值的类型比父类方法宽，此时为逆变方法，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Number <span class="title">doStuff</span><span class="params">(Integer i )</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sub</span> <span class="keyword">extends</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Integer <span class="title">doStuff</span><span class="params">(Number i)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组支持协变</span></span><br><span class="line">Number [] n = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//java 为了保证运行期的安全性</span></span><br><span class="line"><span class="comment">//必须保证泛型参数类型是固定的，所以它不允许一个泛型参数可以同时包含两种类型，即使为父子关系也不行。</span></span><br><span class="line">List&lt;Number&gt;ln = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//即Number的子类型都可以为泛型类型参数，即允许NUmber所有的子类作为泛型参数类型，在运行期为一个具体的值，</span></span><br><span class="line"><span class="comment">//通配符在编译期有效，在运行期必须为一个明确的类型。，协变</span></span><br><span class="line">List&lt; ? extends Number &gt; ln = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//Integer的父类型(包括Integer)都可以为泛型参数类型，逆变</span></span><br><span class="line">List&lt; ? <span class="keyword">super</span> Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>带泛型参数的子类型定义</p>
<table>
<thead>
<tr>
<th>问</th>
<th>答</th>
</tr>
</thead>
<tbody><tr>
<td>Integer 是Number的子类型</td>
<td>对</td>
</tr>
<tr>
<td>ArrayList&lt; Integer&gt;是List&lt; Integer&gt;的子类型</td>
<td>对</td>
</tr>
<tr>
<td>Integer[] 是Number[]的子类型</td>
<td>对</td>
</tr>
<tr>
<td>List&lt; Integer&gt;是List&lt; Number&gt;</td>
<td>的子类型</td>
</tr>
<tr>
<td>List&lt; Integer&gt; 是List&lt;? extends Integer&gt;的子类型</td>
<td>错</td>
</tr>
<tr>
<td>List&lt; Integer&gt;是List&lt; ? super Integer&gt;的子类型</td>
<td>错</td>
</tr>
</tbody></table>
<h5 id="98-建议采用的顺序为List-lt-T-gt-List-lt-gt-List-lt-Object-gt-原因为："><a href="#98-建议采用的顺序为List-lt-T-gt-List-lt-gt-List-lt-Object-gt-原因为：" class="headerlink" title="98.建议采用的顺序为List&lt; T&gt;,List&lt; ?&gt;,List&lt; Object&gt;,原因为："></a>98.建议采用的顺序为List&lt; T&gt;,List&lt; ?&gt;,List&lt; Object&gt;,原因为：</h5><ul>
<li>1，List&lt; T &gt;:表示List集合中的元素都为T类型，具体类型在运行期决定，List&lt; ?&gt;表示为任意类型，List&lt; Object &gt;表示为所以元素为Object类型，因为Object为所有类型的父类，所以List&lt; Objerct&gt;可以容纳所有 的类型。</li>
<li>2，List<T>：可以进行读写操作，add或remove等操作，因为是固定的T类型，在编码期不需要进行类型转化。</li>
<li>3，List&lt; ? &gt;:是只读类型，不能进行增加修改操作，因为编译器不知道List中容纳的是什么类型的元素，而且读取的类型为Object类型，需要主动转型，所以经常采用泛型方法的返回值，可以执行删除类型，因为删除动作与泛型类型无关。</li>
<li>4，List&lt; Object&gt;也可以读写操作，但是它执行写入操作时需要向上转型(Up cast)，在读取数据时需要向下转型(Docwncast)，</li>
</ul>
<h5 id="99-严格限定泛型类型采用多重界限，"><a href="#99-严格限定泛型类型采用多重界限，" class="headerlink" title="99.严格限定泛型类型采用多重界限，"></a>99.严格限定泛型类型采用多重界限，</h5><p> 使用“&amp;”设定多重边界(Multi Bounds)，在java中的泛型中，可以使用 &amp; 符号关联多个上界并实现多个边界的限定，只有上界才有限定，下界没有多重限定的情况，<strong>指定泛型类型T必须为Staff和passenger的共有的子类型，此时变量t就具有了所以限定的属性和方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">staff</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSa</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Passeng</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">implements</span> <span class="title">staff</span>,<span class="title">Passeng</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends staff&amp;Passeng&gt;<span class="function"><span class="keyword">void</span> <span class="title">dis</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.getSa()&lt;<span class="number">2250</span> &amp;&amp;t.isSa() ) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;李瑞龙&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     dis(<span class="keyword">new</span> Me());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//策略模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">permit</span><span class="params">(T user,List&lt;Job&gt; jobs)</span> </span>&#123;</span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; iList =Arrays.asList(user.getClass().getInterfaces());</span><br><span class="line">		<span class="comment">//判断用户是否是 管理员</span></span><br><span class="line">		<span class="comment">//返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</span></span><br><span class="line">		<span class="keyword">if</span>(iList.indexOf(Admin.class) &gt;-<span class="number">1</span>)&#123;</span><br><span class="line">			   Admin admin = (Admin)user;</span><br><span class="line">			   <span class="comment">//判断管理员权限</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			    <span class="comment">//判断普通用户权限</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="100-数组的真实类型必须是泛型类型的子类型，"><a href="#100-数组的真实类型必须是泛型类型的子类型，" class="headerlink" title="100.数组的真实类型必须是泛型类型的子类型，"></a>100.数组的真实类型必须是泛型类型的子类型，</h5><p> List接口的toArray()方法可以将一个集合转换为一个数组，返回的是一个Object数组，所以需要自行转变，yoArray(T[] a)虽然返回的事T类型的数组，但是还需要传入一个T类型的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java_151;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">genericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; T[] toArray(List&lt;T&gt; list) &#123;</span><br><span class="line">		T[] t = (T[]) <span class="keyword">new</span> Object[list.size()];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,n = list.size();i &lt; n;i++) &#123;</span><br><span class="line">			t[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(String str:toArray(list)) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: java.base/[Ljava.lang.Object; cannot be cast to java.base/[Ljava.lang.String;</span><br><span class="line">	at java_151.genericDemo.main(genericDemo.java:<span class="number">21</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类型转化异常，不能把一个Object数组转换为一个String数组，数组是一个容器，只有确保容器内的所有元素与期望的类型有父子关系时才能转换，Object数组只能保证数组内的元素是Object类型，却不能保证他们都是String的父类型，所以转换失败。为什么在main方法中抛出异常，因为泛型是类型擦除的，toArray方法经过编译后的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  Object[]  toArray(List&lt;T&gt; list) &#123;</span><br><span class="line">		Object [] t = (Object[]) <span class="keyword">new</span> Object[list.size()];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,n = list.size();i &lt; n;i++) &#123;</span><br><span class="line">			t[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(String str:(String[])toArray(list)) &#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//改进办法。即把实际类型也变为要转换的类型。</span></span><br><span class="line">	<span class="comment">//objectArray的实际类型和表面类型都是String类型</span></span><br><span class="line">		Object[] objectArray = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>&#125;;</span><br><span class="line">		String [] stringArray = (String [])objectArray;</span><br><span class="line">		</span><br><span class="line">		String[] ss = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>&#125;;</span><br><span class="line">		<span class="comment">//objs的真实类型为String数组，显示类型为Object数组。</span></span><br><span class="line">		Object [] objs = ss;</span><br><span class="line">		String [] stas = (String[])objs;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; T[] toArray(List&lt;T&gt; list,Class&lt;T&gt; tClass) &#123;</span><br><span class="line">	<span class="comment">//newInstance(Class&lt;?&gt; componentType, int length)     创建一个具有指定的组件类型和长度的新数组</span></span><br><span class="line">		T[] t = (T[]) Array.newInstanc(tClass，list.size())</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,n = list.size();i &lt; n;i++) &#123;</span><br><span class="line">			t[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过反射类Array申明了一个T类型的数组，调用者传入Class类型参数，获取数组的实际类型，</span></span><br></pre></td></tr></table></figure>
<p>当一个泛型类(泛型集合)转变为泛型数组时，泛型数组的真实类型不能是泛型类型的父类型，只能是泛型类型的子类型，否则就会出现异常。</p>
<h5 id="101-注意Class类的特殊性："><a href="#101-注意Class类的特殊性：" class="headerlink" title="101.注意Class类的特殊性："></a>101.注意Class类的特殊性：</h5><p> Java语言把Java源文件编译为后缀为class的字节码文件，然后通过ClassLocale机制把类文件加载到内存中，最后生成实例执行，Java使用元类(MetaClass)来描述加载到内存中的类数据，即Class类，描述类的类对象，</p>
<ol>
<li>无构造函数，不能主动实例化，Class对象在加载时由java虚拟机通过类加载器中的defineClass自动构造。</li>
<li>可以描述基本类型<code> Class as=int.class;</code>8个基本类型执行JVM中并不是一个对象，一般存在于栈中，通过Class可以描述它们，可以使用<code>int.calss</code>描述int类型的类对象。</li>
<li>对象都是单例模式，一个Class对象描述一个类，只描述一个类，即一个类只有一个Class对象。<br>Class是java 的反射入口，只有在获得一个类的动态描述时才能动态的加载调用。获得Class对象有三种方法，类属性方法，对象的getClass方法，forName()方法。</li>
</ol>
<h5 id="102-适时选择getDeclaredXXX和getXXX"><a href="#102-适时选择getDeclaredXXX和getXXX" class="headerlink" title="102.适时选择getDeclaredXXX和getXXX;"></a>102.适时选择getDeclaredXXX和getXXX;</h5><p> getDeclaredMethod方法获得的是所有public访问级别的方法，包括从父类继承来的方法，而getDeclareMethod获得自身类的所有方法，包括公有的(public)，私有(private),方法等，不受访问权限限制。如果需要列出所有继承自父类的方法，可以先获得父类，然后使用getDeclareMethods，之后持续递归。</p>
<h5 id="103-反射访问属性或方法时将Accessible设置为true，"><a href="#103-反射访问属性或方法时将Accessible设置为true，" class="headerlink" title="103.反射访问属性或方法时将Accessible设置为true，"></a>103.反射访问属性或方法时将Accessible设置为true，</h5><p> java中通过反射执行方法的步骤，获取一个对象的方法，然后根据isAccessible返回值确定是否能执行，如果返回false，则需要调用&#96;setAccessible(true),在调用invoke执行方法。<br>     Access并不是语法层次理解的访问权限，而是指是否更容易获得，是否进行安全检查。动态的修改一个类或方法或执行方法时都会受到Java安全体系的制约，而安全处理非常消耗资源，所以对于运行期要执行的方法或修改的属性就提供了Accessible可选项，由开发者决定是否要逃避安全体系的检查。<br>     AccessibleObject是field，Method，constructor的父类，决定其是否可以快速访问而不进行访问控制检查，AccessobleObject类中是以override变量保存该值的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Method  method= genericDemo.class.getMethod(<span class="string">&quot;toArray&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(!method.isAccessible())</span><br><span class="line">		   method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		method.invoke(obj, args);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Do liruilong ___$# ^_^&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, Throwable </span>&#123;</span><br><span class="line">		Method method = Foo.class.getMethod(<span class="string">&quot;doStuff&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;可以访问吗！！&quot;</span>+method.isAccessible());</span><br><span class="line">		method.invoke(<span class="keyword">new</span> Foo());</span><br><span class="line">	&#125;	</span><br></pre></td></tr></table></figure>
<p>Accessible属性只是用来判断是否需要进行安全检查的，如果不需要则直接执行，可以提升系统性能，AccessibleObject的其他两个子类field和 constructor也相似，所以要设置Accessible为true。</p>
<h5 id="104-使用forName动态加载类文件，动态加载-Dynamic-Loading-是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时决定是否要加载一个类，一个类文件只有在被加载到内存中才可能生成实例对象，即加载到内存中，生成Class对象，通过new关键字生成实例对象。"><a href="#104-使用forName动态加载类文件，动态加载-Dynamic-Loading-是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时决定是否要加载一个类，一个类文件只有在被加载到内存中才可能生成实例对象，即加载到内存中，生成Class对象，通过new关键字生成实例对象。" class="headerlink" title="104.使用forName动态加载类文件，动态加载(Dynamic Loading)是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时决定是否要加载一个类，一个类文件只有在被加载到内存中才可能生成实例对象，即加载到内存中，生成Class对象，通过new关键字生成实例对象。"></a>104.使用forName动态加载类文件，动态加载(Dynamic Loading)是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时决定是否要加载一个类，一个类文件只有在被加载到内存中才可能生成实例对象，即加载到内存中，生成Class对象，通过new关键字生成实例对象。</h5><h5 id="105-动态加载不适合数组，当使用forName加载一个类时，8个基本类型排除，它不是一个具体的类，还要具有可追索的类路径，否则包ClassNotFoundException异常。数组虽然是一个类，但没有定义类路径，可以加载编译后的对象动态动态加载一个对象数组，但是没有意义。在java中数组是定长的，没有长度的数组是不允许存在的。可以使用Array数组反射类来动态加载一个数组。"><a href="#105-动态加载不适合数组，当使用forName加载一个类时，8个基本类型排除，它不是一个具体的类，还要具有可追索的类路径，否则包ClassNotFoundException异常。数组虽然是一个类，但没有定义类路径，可以加载编译后的对象动态动态加载一个对象数组，但是没有意义。在java中数组是定长的，没有长度的数组是不允许存在的。可以使用Array数组反射类来动态加载一个数组。" class="headerlink" title="105.动态加载不适合数组，当使用forName加载一个类时，8个基本类型排除，它不是一个具体的类，还要具有可追索的类路径，否则包ClassNotFoundException异常。数组虽然是一个类，但没有定义类路径，可以加载编译后的对象动态动态加载一个对象数组，但是没有意义。在java中数组是定长的，没有长度的数组是不允许存在的。可以使用Array数组反射类来动态加载一个数组。"></a>105.动态加载不适合数组，当使用forName加载一个类时，8个基本类型排除，它不是一个具体的类，还要具有可追索的类路径，否则包ClassNotFoundException异常。数组虽然是一个类，但没有定义类路径，可以加载编译后的对象动态动态加载一个对象数组，但是没有意义。在java中数组是定长的，没有长度的数组是不允许存在的。可以使用Array数组反射类来动态加载一个数组。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建一个数组</span></span><br><span class="line">String [] strs = (String[]) Array.newInstance(String.class,<span class="number">8</span>);</span><br><span class="line">      <span class="keyword">int</span>[][] ints = (<span class="keyword">int</span> [][])Array.newInstance(<span class="keyword">int</span>.class,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>元素类型</th>
<th>编译后的类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte[]</td>
<td>[B</td>
</tr>
<tr>
<td>char[]</td>
<td>[C</td>
</tr>
<tr>
<td>Double[]</td>
<td>[D</td>
</tr>
<tr>
<td>Float[]</td>
<td>[F</td>
</tr>
<tr>
<td>Int[]</td>
<td>[I</td>
</tr>
<tr>
<td>Long[]</td>
<td>[J</td>
</tr>
<tr>
<td>Short[]</td>
<td>[S</td>
</tr>
<tr>
<td>Boolean</td>
<td>[Z</td>
</tr>
<tr>
<td>引用类型(如String)</td>
<td>[L引用类型</td>
</tr>
</tbody></table>
<h5 id="106-动态可以让代理模式更灵活，java的反射框架提供了动态代理-Dynamic-Proxy-机制，允许在运行期对目标对象生成代理，静态代理：通过代理主题角色和具体主题角色共同实现抽象主题角色的逻辑的，只是代理主题角色把相关的执行逻辑委托给了具体主题角色而已。"><a href="#106-动态可以让代理模式更灵活，java的反射框架提供了动态代理-Dynamic-Proxy-机制，允许在运行期对目标对象生成代理，静态代理：通过代理主题角色和具体主题角色共同实现抽象主题角色的逻辑的，只是代理主题角色把相关的执行逻辑委托给了具体主题角色而已。" class="headerlink" title="106.动态可以让代理模式更灵活，java的反射框架提供了动态代理(Dynamic Proxy)机制，允许在运行期对目标对象生成代理，静态代理：通过代理主题角色和具体主题角色共同实现抽象主题角色的逻辑的，只是代理主题角色把相关的执行逻辑委托给了具体主题角色而已。"></a>106.动态可以让代理模式更灵活，java的反射框架提供了动态代理(Dynamic Proxy)机制，允许在运行期对目标对象生成代理，静态代理：通过代理主题角色和具体主题角色共同实现抽象主题角色的逻辑的，只是代理主题角色把相关的执行逻辑委托给了具体主题角色而已。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> subject subjects = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        subjects = <span class="keyword">new</span>  RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(subject subjects)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subjects =subjects; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        befoer();</span><br><span class="line">        subjects.request();</span><br><span class="line">        afert();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">befoer</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afert</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
<p>java基于java.lang.reflect.Proxy用于实现动态代理，使SubjectHandler作为主要的逻辑委托对象，invoke是必须要实现的，完成对真实方法的调用。即通过InvocationHandler接口的实现类来实现，所有被代理的方法都是由InvocationHandler接管实际的处理任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> subject subjects;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SubjectHandler</span><span class="params">(subject subjects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subjects = subjects;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;预处理&quot;</span>);</span><br><span class="line">        Object obj = method.invoke(subjects,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;后处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//场景类</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">      </span><br><span class="line">      subject subjects = <span class="keyword">new</span> RealSubject();</span><br><span class="line">      InvocationHandler handler = <span class="keyword">new</span> SubjectHandler(subjects);</span><br><span class="line">      <span class="comment">//当前加载器</span></span><br><span class="line">      ClassLoader cl = subjects.getClass().getClassLoader();</span><br><span class="line">      <span class="comment">//动态代理</span></span><br><span class="line">      subject proxy = (subject) Proxy.newProxyInstance(cl,subjects.getClass().getInterfaces().request(),handler);</span><br><span class="line">      <span class="comment">//执行具体的角色方法</span></span><br><span class="line">      proxy.request();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="107-使用反射增加装饰模式的普遍性，装饰模式：动态的给一个对象添加一些额外的职责。使用动态代理可以实现装饰模式。"><a href="#107-使用反射增加装饰模式的普遍性，装饰模式：动态的给一个对象添加一些额外的职责。使用动态代理可以实现装饰模式。" class="headerlink" title="107.使用反射增加装饰模式的普遍性，装饰模式：动态的给一个对象添加一些额外的职责。使用动态代理可以实现装饰模式。"></a>107.使用反射增加装饰模式的普遍性，装饰模式：动态的给一个对象添加一些额外的职责。使用动态代理可以实现装饰模式。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老鼠</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rat</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Jetty Tom&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义某种能力</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Featuer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyFeatuer</span> <span class="keyword">implements</span> <span class="title">Featuer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加 一支翅膀&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigFeatuer</span> <span class="keyword">implements</span> <span class="title">Featuer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加钻地能力！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecorateAnimal</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Animal animal;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Featuer&gt; clz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecorateAnimal</span><span class="params">(Animal animal,Class&lt;? extends Featuer&gt; clz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animal = animal;</span><br><span class="line">        <span class="keyword">this</span>.clz = clz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">//具体的包装行为</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//设置包装</span></span><br><span class="line">                <span class="comment">// public class Modifier</span></span><br><span class="line">                <span class="comment">// extends ObjectModifier类提供了static方法和常量来解码类和成员访问修饰符。 修饰符集合被表示为具有表示不同修饰符的不同位位置的整数。</span></span><br><span class="line">        <span class="comment">//method.getModifiers()返回由该对象表示的可执行文件的Java语言modifiers 。</span></span><br><span class="line">         <span class="keyword">if</span> (Modifier.isPublic(method.getModifiers()))&#123;</span><br><span class="line">                obj = method.invoke(clz.newInstance(),args);</span><br><span class="line">         &#125;</span><br><span class="line">         animal.doStuff();</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ClassLoader cl = getClass().getClassLoader();</span><br><span class="line">        Featuer Proxy = (Featuer) java.lang.reflect.Proxy.newProxyInstance(cl,clz.getInterfaces(),handler);</span><br><span class="line">        Proxy.load();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//定义Jerry老树</span></span><br><span class="line">        Animal Jerry = <span class="keyword">new</span> Rat();</span><br><span class="line">        Jerry = <span class="keyword">new</span> DecorateAnimal(Jerry,FlyFeatuer.class);</span><br><span class="line">        Jerry = <span class="keyword">new</span> DecorateAnimal(Jerry,DigFeatuer.class);</span><br><span class="line">        Jerry.doStuff();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="108-反射让模板方法模式更强大，模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可定义该算法的某些特定的步骤，即父类定义抽象模板为骨架，其中包括基本方法-由子类实现的方法，并且在模板方法被调用-和模板方法-实现对基本方法的调用，完成固定的逻辑"><a href="#108-反射让模板方法模式更强大，模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可定义该算法的某些特定的步骤，即父类定义抽象模板为骨架，其中包括基本方法-由子类实现的方法，并且在模板方法被调用-和模板方法-实现对基本方法的调用，完成固定的逻辑" class="headerlink" title="108.反射让模板方法模式更强大，模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可定义该算法的某些特定的步骤，即父类定义抽象模板为骨架，其中包括基本方法(由子类实现的方法，并且在模板方法被调用)和模板方法(实现对基本方法的调用，完成固定的逻辑)"></a>108.反射让模板方法模式更强大，模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可定义该算法的某些特定的步骤，即父类定义抽象模板为骨架，其中包括基本方法(由子类实现的方法，并且在模板方法被调用)和模板方法(实现对基本方法的调用，完成固定的逻辑)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsPopulator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dataInitialing</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        doInit();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">protected</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPopulator</span> <span class="keyword">extends</span> <span class="title">AbsPopulator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/*初始化用户表，如创建，加载数据等*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基于反射增强的模板方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsPopulator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dataInitialing</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        doInit();</span><br><span class="line">        <span class="comment">//获得所有public方法</span></span><br><span class="line">        Method[] methods = getClass().getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">            <span class="comment">//判断是否是数据初始化方法</span></span><br><span class="line">            <span class="keyword">if</span>(isIinitDataMethod(m))&#123;</span><br><span class="line">                m.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIinitDataMethod</span><span class="params">(Method m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.getName().startsWith(<span class="string">&quot;init&quot;</span>)&amp;&amp;<span class="comment">//init开始</span></span><br><span class="line">                Modifier.isPublic(m.getModifiers())&amp;&amp;<span class="comment">//公开的方法</span></span><br><span class="line">                m.getReturnType().equals(<span class="string">&quot;Void.Type&quot;</span>)&amp;&amp;<span class="comment">//返回类型为void</span></span><br><span class="line">                !m.isVarArgs()&amp;&amp;<span class="comment">//输入参数不为空</span></span><br><span class="line">                 !Modifier.isAbstract(m.getModifiers());<span class="comment">//不能为抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPopulator</span> <span class="keyword">extends</span> <span class="title">AbsPopulator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Inituser</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitPassword</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitJobz</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Inituser</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/*初始化用户表，如创建，加载数据等*/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用反射后，不需要定义任何抽象方法，只需要定义一个基本的方法鉴别器，即可加载否和规则的基本方法，模板方法根据鉴别器返回执行相应的方法。</p>
<h5 id="109-不需要太多的关注反射效率，"><a href="#109-不需要太多的关注反射效率，" class="headerlink" title="109.不需要太多的关注反射效率，"></a>109.不需要太多的关注反射效率，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="comment">//获得一个泛型类的实际泛型类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Class&lt;T&gt; <span class="title">getGenricClassType</span><span class="params">(Class clz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回 Type表示此所表示的实体(类，接口，基本类型或void)的直接超类 类</span></span><br><span class="line">        Type type = clz.getGenericSuperclass();</span><br><span class="line">        <span class="comment">//ParameterizedType表示一个参数化类型，如Collection &lt;String&gt;。</span></span><br><span class="line">        <span class="keyword">if</span>(type <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType)&#123;</span><br><span class="line">                ParameterizedType pt = (ParameterizedType)type;</span><br><span class="line">                Type[] types = pt.getActualTypeArguments();</span><br><span class="line">                <span class="keyword">if</span> (types.length&gt;<span class="number">0</span>&amp;&amp;types[<span class="number">0</span>] <span class="keyword">instanceof</span> Class)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (Class)types[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (Class)Object.class;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第八章-异常"><a href="#第八章-异常" class="headerlink" title="第八章 异常"></a>第八章 异常</h1><h5 id="110-提倡异常的封装，可以提供按系统的友好性，提高系统的可维护性，对异常进行分类，解决Java异常机制缺陷。进行异常封装。"><a href="#110-提倡异常的封装，可以提供按系统的友好性，提高系统的可维护性，对异常进行分类，解决Java异常机制缺陷。进行异常封装。" class="headerlink" title="110.提倡异常的封装，可以提供按系统的友好性，提高系统的可维护性，对异常进行分类，解决Java异常机制缺陷。进行异常封装。"></a>110.提倡异常的封装，可以提供按系统的友好性，提高系统的可维护性，对异常进行分类，解决Java异常机制缺陷。进行异常封装。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Throwable&gt; causes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(List&lt;? extends Throwable&gt; causes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.causes.add((Throwable) causes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Throwable&gt; <span class="title">getException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> causes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        List&lt;Throwable&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//异常代码</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//异常代码</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="111-采用异常链传递异常，设计模式中有一种叫责任链意识，它的目标是将多个对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止，即先封装，然后传递，把FileNotFoundException封装为MyException，抛到逻辑层，逻辑层根据异常代码确定后续的处理，然后抛出到视图层，在视图层，如果为管理员展现低层次异常，如果为普通用户则展现为封装后异常。"><a href="#111-采用异常链传递异常，设计模式中有一种叫责任链意识，它的目标是将多个对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止，即先封装，然后传递，把FileNotFoundException封装为MyException，抛到逻辑层，逻辑层根据异常代码确定后续的处理，然后抛出到视图层，在视图层，如果为管理员展现低层次异常，如果为普通用户则展现为封装后异常。" class="headerlink" title="111.采用异常链传递异常，设计模式中有一种叫责任链意识，它的目标是将多个对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止，即先封装，然后传递，把FileNotFoundException封装为MyException，抛到逻辑层，逻辑层根据异常代码确定后续的处理，然后抛出到视图层，在视图层，如果为管理员展现低层次异常，如果为普通用户则展现为封装后异常。"></a>111.采用异常链传递异常，设计模式中有一种叫责任链意识，它的目标是将多个对象连成一条链，并沿着这条链传递该请求，直到有对象处理为止，即先封装，然后传递，把FileNotFoundException封装为MyException，抛到逻辑层，逻辑层根据异常代码确定后续的处理，然后抛出到视图层，在视图层，如果为管理员展现低层次异常，如果为普通用户则展现为封装后异常。</h5><h5 id="112-受检异常尽可能转换为非受检异常。"><a href="#112-受检异常尽可能转换为非受检异常。" class="headerlink" title="112.受检异常尽可能转换为非受检异常。"></a>112.受检异常尽可能转换为非受检异常。</h5><h5 id="113-不要在finally块中处理返回值，"><a href="#113-不要在finally块中处理返回值，" class="headerlink" title="113.不要在finally块中处理返回值，"></a>113.不要在finally块中处理返回值，</h5><ul>
<li>会覆盖try块中的返回值(当没有定义变量时，会先返回try中的返回值，然后执行finally会重置返回值)，当定义变量时，不会重置try的返回值，异常代码加上try语句就标志着运行时会有一个Throwable线程监视该方法的运行，当出现异常时，交由异常逻辑处理，方法在栈内存中运行的，会按照“先进后出”的原则执行，main方法调用异常方法，main方法在下层，异常方法在上层，当异常方法执行完毕<code>return a</code>后，此方法的返回值以确定为固定值(基本类型为值拷贝)，此后finally代码块修改已经没有意义(类似值传递)，当为引用类型时，因为是地址拷贝，所以会改变。</li>
<li>屏蔽异常，无法捕捉到异常，当异常线程在监视到有异常发生时，就会登记当前的异常类型为DateFormatException，但当执行器执行finally语句时，则会重新为doSome方法赋值，告诉调用者没有异常产生，返回值为1。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            doSome();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里永远不会到达！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
与return语句类似的System.exit(0)或Runtime().exit(0)出现在异常代码块也会产生异常。不要在finally块中出现return语句。</li>
</ul>
<h5 id="114-不要在构造函数中抛出异常，java的异常机制有三种，"><a href="#114-不要在构造函数中抛出异常，java的异常机制有三种，" class="headerlink" title="114.不要在构造函数中抛出异常，java的异常机制有三种，"></a>114.不要在构造函数中抛出异常，java的异常机制有三种，</h5><ul>
<li>Erroe类及其子类表示为错误，它是不需要程序员处理也不能处理的异常，比如VirtualMachineError虚拟机错误，Thread线程僵死等。</li>
<li>RuntimeException类及其子类表示非受检异常，是系统可能会抛出的异常，编译器不要求强制处理的异常，常见的有NullPointException异常和IndexOutBoundException越界异常，</li>
<li>Exception类及其子类中除RuntimeException异常，表示受检异常，是程序员必须处理的异常，不处理程序不能通过，IOException和SQLException异常。<br> 一个对象的创建要经过内存分配，静态代码初始化，构造函数执行等过程，一般不在构造函数中抛出异常，是程序员无法处理的，会加重上层代码的编写者的负担，后续代码不会执行，违背了里氏替换原则，父类能出现的地方子类就可以出现，而且将父类替换为子类也不会产生任何异常， java的构造函数允许子类的构造函数抛出更广泛的异常类(正好与类方法的异常机制相反:子类方法的异常类型必须为父类方法的子类型，覆写要求)，当替换时，需要增加catch块，构造函数没有覆写的概念，只有构造函数之间的引用调用而已，</li>
<li>子类构造函数扩展受限。</li>
</ul>
<h5 id="115-使用Throwsable获得栈信息，AOP编程可以亲松的控制一个方法调用那些类，也能控制那些方法允许别调用，一般来讲切面编程只能控制到方法级别，不能实现代码级别的植入-Weave-，即不同类的不同方法参数相同调用相同方法返回不同的值。即要求被调用者具有识别调用者的能力，可以使用Throwable获得栈信息，然后鉴别调用者信息。"><a href="#115-使用Throwsable获得栈信息，AOP编程可以亲松的控制一个方法调用那些类，也能控制那些方法允许别调用，一般来讲切面编程只能控制到方法级别，不能实现代码级别的植入-Weave-，即不同类的不同方法参数相同调用相同方法返回不同的值。即要求被调用者具有识别调用者的能力，可以使用Throwable获得栈信息，然后鉴别调用者信息。" class="headerlink" title="115.使用Throwsable获得栈信息，AOP编程可以亲松的控制一个方法调用那些类，也能控制那些方法允许别调用，一般来讲切面编程只能控制到方法级别，不能实现代码级别的植入(Weave)，即不同类的不同方法参数相同调用相同方法返回不同的值。即要求被调用者具有识别调用者的能力，可以使用Throwable获得栈信息，然后鉴别调用者信息。"></a>115.使用Throwsable获得栈信息，AOP编程可以亲松的控制一个方法调用那些类，也能控制那些方法允许别调用，一般来讲切面编程只能控制到方法级别，不能实现代码级别的植入(Weave)，即不同类的不同方法参数相同调用相同方法返回不同的值。即要求被调用者具有识别调用者的能力，可以使用Throwable获得栈信息，然后鉴别调用者信息。</h5><p>JVM在创建一个Throwable类及其子类时会把当前线程的栈信息记录下来，以便在输出异常时准确定位异常原因，在出现异常时，JVM会通过fillInStackTrace(填写执行堆栈跟踪。)方法记录下栈帧的信息，然后生成一个Throwable对象，可以知道类间的调用顺序，方法名称及当前行号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//堆栈跟踪中的一个元素，由Throwable.getStackTrace()返回。 每个元素表示单个堆栈帧。 堆栈顶部除堆栈之外的所有堆栈都表示方法调用。 堆栈顶部的帧表示生成堆栈跟踪的执行点。 通常，这是创建与堆栈跟踪相对应的throwable的点。</span></span><br><span class="line">            <span class="comment">//取得当前栈信息</span></span><br><span class="line">            StackTraceElement []  stackTraceElements = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line">            <span class="comment">//检查是否是m1方法调用</span></span><br><span class="line">            <span class="keyword">for</span>(StackTraceElement st: stackTraceElements)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st.getMethodName().equals(<span class="string">&quot;m1&quot;</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;除m1方法外，该方法不允许其他方法调用&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Invoker</span></span>&#123;</span><br><span class="line">        <span class="comment">//该方法打印true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Foo.m());</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="comment">//该方法打印true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Foo.m());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出现异常的栈记录</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StackTraceElement[] UNASSIGNED_STACK = <span class="keyword">new</span> StackTraceElement[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//构造函数记录栈帧</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//本地方法，抓取执行时的栈信息。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="116-异常只为异常服务，即异常块里不添加逻辑，添加逻辑，会造成异常判断降低了系统性能，降低了代码可读性，隐藏了运行期可能产生的异常"><a href="#116-异常只为异常服务，即异常块里不添加逻辑，添加逻辑，会造成异常判断降低了系统性能，降低了代码可读性，隐藏了运行期可能产生的异常" class="headerlink" title="116.异常只为异常服务，即异常块里不添加逻辑，添加逻辑，会造成异常判断降低了系统性能，降低了代码可读性，隐藏了运行期可能产生的异常"></a>116.异常只为异常服务，即异常块里不添加逻辑，添加逻辑，会造成异常判断降低了系统性能，降低了代码可读性，隐藏了运行期可能产生的异常</h5><h5 id="117-多使用异常，把性能放一边，异常是主逻辑的例外逻辑，比如-在马路上走路-主逻辑-，突然开过一辆车，我要避让-受检异常，必须处理-，继续走路，突然一架飞机从我头顶飞过-非受检异常-，我可以选择走路-不捕捉-，也可以选择职责其噪音污染-捕捉，主逻辑的补充处理-，在继续走下去，突然一棵流星砸下类，这是没有选择，属于错误，不能做任何处理。"><a href="#117-多使用异常，把性能放一边，异常是主逻辑的例外逻辑，比如-在马路上走路-主逻辑-，突然开过一辆车，我要避让-受检异常，必须处理-，继续走路，突然一架飞机从我头顶飞过-非受检异常-，我可以选择走路-不捕捉-，也可以选择职责其噪音污染-捕捉，主逻辑的补充处理-，在继续走下去，突然一棵流星砸下类，这是没有选择，属于错误，不能做任何处理。" class="headerlink" title="117.多使用异常，把性能放一边，异常是主逻辑的例外逻辑，比如 在马路上走路(主逻辑)，突然开过一辆车，我要避让(受检异常，必须处理)，继续走路，突然一架飞机从我头顶飞过(非受检异常)，我可以选择走路(不捕捉)，也可以选择职责其噪音污染(捕捉，主逻辑的补充处理)，在继续走下去，突然一棵流星砸下类，这是没有选择，属于错误，不能做任何处理。"></a>117.多使用异常，把性能放一边，异常是主逻辑的例外逻辑，比如 在马路上走路(主逻辑)，突然开过一辆车，我要避让(受检异常，必须处理)，继续走路，突然一架飞机从我头顶飞过(非受检异常)，我可以选择走路(不捕捉)，也可以选择职责其噪音污染(捕捉，主逻辑的补充处理)，在继续走下去，突然一棵流星砸下类，这是没有选择，属于错误，不能做任何处理。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//正常登陆，</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InvalidLonginException e)&#123;</span><br><span class="line">            <span class="comment">//用户名无效</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InvalidPasswordException e)&#123;</span><br><span class="line">            <span class="comment">//密码错误异常</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="118-不推存覆写start方法"><a href="#118-不推存覆写start方法" class="headerlink" title="118.不推存覆写start方法."></a>118.不推存覆写start方法.</h5><h5 id="119-启动线程前stop方法是不可靠的。"><a href="#119-启动线程前stop方法是不可靠的。" class="headerlink" title="119.启动线程前stop方法是不可靠的。"></a>119.启动线程前stop方法是不可靠的。</h5><h5 id="120-不要使用stop方法停止线程。"><a href="#120-不要使用stop方法停止线程。" class="headerlink" title="120.不要使用stop方法停止线程。"></a>120.不要使用stop方法停止线程。</h5><h5 id="121-线程优先级只是用三个等级，priority只是表示线程获得CPU运行的机会，不代表强制符号。优先级相同，由操作系统决定，基本上按照FiFO-先入先出-原则，不能完全保证。"><a href="#121-线程优先级只是用三个等级，priority只是表示线程获得CPU运行的机会，不代表强制符号。优先级相同，由操作系统决定，基本上按照FiFO-先入先出-原则，不能完全保证。" class="headerlink" title="121.线程优先级只是用三个等级，priority只是表示线程获得CPU运行的机会，不代表强制符号。优先级相同，由操作系统决定，基本上按照FiFO(先入先出)原则，不能完全保证。"></a>121.线程优先级只是用三个等级，priority只是表示线程获得CPU运行的机会，不代表强制符号。优先级相同，由操作系统决定，基本上按照FiFO(先入先出)原则，不能完全保证。</h5><h5 id="122-使用线程异常处理器提升系统可靠性，在java1-5版本后在Thread类中增加了setUncaughhtExceptionHandle方法，实现了异常的捕捉和处理，"><a href="#122-使用线程异常处理器提升系统可靠性，在java1-5版本后在Thread类中增加了setUncaughhtExceptionHandle方法，实现了异常的捕捉和处理，" class="headerlink" title="122.使用线程异常处理器提升系统可靠性，在java1.5版本后在Thread类中增加了setUncaughhtExceptionHandle方法，实现了异常的捕捉和处理，"></a>122.使用线程异常处理器提升系统可靠性，在java1.5版本后在Thread类中增加了setUncaughhtExceptionHandle方法，实现了异常的捕捉和处理，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tcpserver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建后及运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tcpserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//设置当该线程由于未捕获的异常而突然终止时调用的处理程序。 线程可以完全控制如何通过明确设置其未捕获的异常处理来响应未捕获的异常。 如果没有设置这样的处理程序，那么线程的ThreadGroup对象将作为其处理程序。 </span></span><br><span class="line">        t.setUncaughtExceptionHandler(<span class="keyword">new</span> TcpServerExceptionHandler());</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;系统正常运行：&quot;</span>+i);</span><br><span class="line"><span class="comment">//线程在等待，睡眠或以其他方式占用时抛出，线程在活动之前或活动期间中断。 偶尔，一个方法可能希望测试当前线程是否已被中断，如果是，立即抛出该异常。 可以使用以下代码来实现这一效果：  if (Thread.interrupted())    throw new InterruptedException();                 </span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当Thread由于未捕获的异常而突然终止时，处理程序的接口被调用。</span></span><br><span class="line"><span class="comment">//当一个线程要终止由于未捕获到异常的Java虚拟机将使用查询线程其UncaughtExceptionHandler Thread.getUncaughtExceptionHandler() ，将调用处理程序的uncaughtException方法，将线程和异常作为参数。 如果一个线程一直没有其UncaughtExceptionHandler明确设置，那么它ThreadGroup对象充当其UncaughtExceptionHandler。 如果ThreadGroup对象没有处理异常的特殊要求，则可以将调用转发到default uncaught exception handler 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异常处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>+t.getName()+<span class="string">&quot;出现异常，自行启动，分析原因&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">new</span> Tcpserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第九章-线程安全"><a href="#第九章-线程安全" class="headerlink" title="第九章 线程安全"></a>第九章 线程安全</h1><h5 id="123，volatile不能保证数据同步，"><a href="#123，volatile不能保证数据同步，" class="headerlink" title="123，volatile不能保证数据同步，"></a>123，volatile不能保证数据同步，</h5><p>每个线程都运行在栈内存中，每个线程都有自己的工作内存(Working Memory)，比如寄存器Register，高速缓存存储器Cache等，线程的计算一般是通过工作内存进行交互的，线程在初始化时从主内存中加载所需要的变量值到工作内存中，然后在线程运行时，如果读取内存，则直接从工作内存中读取，若是写入则先写入到工作内存中，之后在刷新到主内存中，在多线程情况下，可能读到的不是最新的值，可以使用synchronized同步代码块，或使用Lock锁来解决该问题，java可以使用volatile解决，在变量前加volatile关键字，可以保证每个线程对本地变量的访问和修改都是直接与主内存交互的，而不是与本线程的工作内存交互。但是Volatile关键字并不能保证线程安全，它只能保证当前线程需要该变量的值能够获得最新的值，而不能保证多个线程修改的安全性。</p>
<h5 id="124-异步运算考虑使用Callable接口："><a href="#124-异步运算考虑使用Callable接口：" class="headerlink" title="124.异步运算考虑使用Callable接口："></a>124.异步运算考虑使用Callable接口：</h5><p>多线程应用有两种实现方式，一种是实现Runnable接口，另一种是继承Thread类，run方法没有返回值。不能抛出异常，使用Callable可以实现多线程任务， Executors 是静态工具类，提供异步执行器的创建能力，一般是异步计算的入口类，Future关注的是线程执行后的 结果。<br>public class Executors  extends Object<br>工厂和工具方法Executor ， ExecutorService ， ScheduledExecutorService ， ThreadFactory和Callable在此包中定义的类。 该类支持以下几种方法：<br>创建并返回一个ExecutorService设置的常用的配置设置的方法。<br>创建并返回一个ScheduledExecutorService的方法， 其中设置了常用的配置设置。<br>创建并返回“包装”ExecutorService的方法，通过使实现特定的方法无法访问来禁用重新配置。<br>创建并返回将新创建的线程设置为已知状态的ThreadFactory的方法。<br>创建并返回一个方法Callable出的其他闭包形式，这样他们就可以在需要的执行方法使用Callable 。 </p>
<p>public interface Future<V>Future<br>表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>boolean cancel(boolean mayInterruptIfRunning)</td>
<td>试图取消对此任务的执行。</td>
</tr>
<tr>
<td>V get()</td>
<td>如有必要，等待计算完成，然后获取其结果。</td>
</tr>
<tr>
<td>V get(long timeout, TimeUnit unit)</td>
<td>如有必要，最多等待为使计算完成所给定的时间之后，获取其结果(如果结果可用)。</td>
</tr>
<tr>
<td>boolean isCancelled()</td>
<td>如果在任务正常完成前将其取消，则返回 true。</td>
</tr>
<tr>
<td>boolean isDone()</td>
<td>如果任务已完成，则返回 true</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxCallabletor</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seedMoney;</span><br><span class="line">    TaxCallabletor(<span class="keyword">int</span> seedMoney)&#123;</span><br><span class="line">        <span class="keyword">this</span>.seedMoney = seedMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//TimeUnit 表示给定单元粒度的时间段，它提供在这些单元中进行跨单元转换和执行计时及延迟操作的实用工具方法。</span></span><br><span class="line">        TimeUnit.MICROSECONDS.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> seedMoney/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//生成一个单线程的异步执行器，</span></span><br><span class="line">        ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">//线程执行后的期望值</span></span><br><span class="line">        <span class="comment">//Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果</span></span><br><span class="line">        Future&lt;Integer&gt; future =  es.submit(<span class="keyword">new</span> TaxCallabletor(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">while</span>(!future.isDone())&#123;</span><br><span class="line">            <span class="comment">//还没有运算完成，等待200毫秒</span></span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">//输出进度符号</span></span><br><span class="line">            System.out.print(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算完成。税金是：&quot;</span>+future.get()+<span class="string">&quot;yun&quot;</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="126-适时选择不同的线程池来实现，java线程池实现从根本讲，ThreadPoolExecuto类和ScheduleThreadPoolException类。还是父子关系。"><a href="#126-适时选择不同的线程池来实现，java线程池实现从根本讲，ThreadPoolExecuto类和ScheduleThreadPoolException类。还是父子关系。" class="headerlink" title="126,.适时选择不同的线程池来实现，java线程池实现从根本讲，ThreadPoolExecuto类和ScheduleThreadPoolException类。还是父子关系。"></a>126,.适时选择不同的线程池来实现，java线程池实现从根本讲，ThreadPoolExecuto类和ScheduleThreadPoolException类。还是父子关系。</h5><p>线程池的优点:<br>重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;<br>能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;<br>能够多线程进行简单的管理,使线程的使用简单、高效。</p>
<p>线程池框架Executor<br>java中的线程池是通过Executor框架实现的，Executor 框架包括类：Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask的使用等。<br>Executor: 所有线程池的接口,只有一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;        </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService: 增加Executor的行为，是Executor实现类的最直接接口。<br>Executors： 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService 接口。<br>ThreadPoolExecutor：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。<br>构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数介绍：<br>corePoolSize：线程池的核心线程数,线程池中运行的线程数也永远不会超过 corePoolSize 个,默认情况下可以一直存活。可以通过设置allowCoreThreadTimeOut为True,此时 核心线程数就是0,此时keepAliveTime控制所有线程的超时时间。<br>maximumPoolSize：线程池允许的最大线程数;<br>keepAliveTime： 指的是空闲线程结束的超时时间;<br>unit ：是一个枚举，表示 keepAliveTime 的单位;<br>workQueue：表示存放任务的BlockingQueue&lt;Runnable队列。<br>BlockingQueue:阻塞队列(BlockingQueue)是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。<br>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued等。一般其内部的都是通过Lock和Condition(显示锁(Lock)及Condition的学习与使用)来实现阻塞和唤醒。</p>
<p>3.线程池的工作过程<br>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。<br>当调用 execute() 方法添加一个任务时，线程池会做如下判断：<br>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。<br>当一个线程完成任务时，它会从队列中取下一个任务来执行。<br>当一个线程无事可做，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>
<p>4.线程池的创建和使用<br>生成线程池采用了工具类Executors的静态方法，以下是几种常见的线程池。<br>1)SingleThreadExecutor：单个后台线程 (其缓冲队列是无界的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,                                    </span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                    </span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个单线程的线程池。这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>2)FixedThreadPool：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                       </span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,                                         </span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。<br>3)CachedThreadPool：无界线程池，可以进行自动线程回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,                                           </span><br><span class="line">           <span class="number">60L</span>, TimeUnit.SECONDS,                                       </span><br><span class="line">           <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲(60秒不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统(或者说JVM)能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。<br>4)ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPool(corePoolSize, </span><br><span class="line">              Integer.MAX_VALUE,                                                  </span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,                                                    </span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.线程池实现的原理<br>线程池的实现过程没有用到Synchronized关键字，用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类，FutureTask等等，因为后者的性能更优。理解的过程可以很好的学习源码中并发控制的思想。<br>在ThreadPoolExecutor主要Worker类来控制线程的复用。看下Worker类简化后的代码，这样方便理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Worker是一个Runnable，同时拥有一个thread，这个thread就是要开启的线程，在新建Worker对象时同时新建一个Thread对象，同时将Worker自己作为参数传入TThread，这样当Thread的start()方法调用时，运行的实际上是Worker的run()方法，接着到runWorker()中,有个while循环，一直从getTask()里得到Runnable对象，顺序执行。getTask()又是怎么得到Runnable对象的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(一些特殊情况) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable r = workQueue.take();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个workQueue就是初始化ThreadPoolExecutor时存放任务的BlockingQueue队列，这个队列里的存放的都是将要执行的Runnable任务。因为BlockingQueue是个阻塞队列，BlockingQueue.take()得到如果是空，则进入等待状态直到BlockingQueue有新的对象被加入时唤醒阻塞的线程。所以一般情况Thread的run()方法就不会结束,而是不断执行从workQueue里的Runnable任务，这就达到了线程复用的原理了。</p>
<p>控制最大并发数：<br>那Runnable是什么时候放入workQueue？Worker又是什么时候创建，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？<br>很容易想到是在execute(Runnable runnable)时会做上面的一些任务。看下execute里是怎么做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数 &lt; corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新的线程。</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 活动线程数 &gt;= corePoolSize</span></span><br><span class="line">    <span class="comment">// runState为RUNNING &amp;&amp; 队列未满</span></span><br><span class="line">    <span class="comment">// workQueue.offer(command)表示添加到队列，如果添加成功返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次检验是否为RUNNING状态</span></span><br><span class="line">        <span class="comment">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);<span class="comment">// 采用线程池指定的策略拒绝任务</span></span><br><span class="line">        <span class="comment">// 两种情况：</span></span><br><span class="line">        <span class="comment">// 1.非RUNNING状态拒绝新的任务</span></span><br><span class="line">        <span class="comment">// 2.队列满了启动新的线程失败(workCount &gt; maximumPoolSize)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码再来看上面提到的线程池工作过程中的添加任务的情况：<br>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；<br>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；<br>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。<br>线程知识参考知乎：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33725107%EF%BC%9B">https://zhuanlan.zhihu.com/p/33725107；</a></p>
<h5 id="127-Lock与Synchronized是不一样的"><a href="#127-Lock与Synchronized是不一样的" class="headerlink" title="127.Lock与Synchronized是不一样的"></a>127.Lock与Synchronized是不一样的</h5><p>对于同步资源来讲，显示锁是对象级别的锁，而内部锁是类级别的锁，Lock定义为多线程类的私有属性是起不到资源互斥的作用的，除非包Lock定义为所以线程的共享变量。Lock是无阻塞锁，synchronized是阻塞锁，Lock可实现公平锁，synchronized只能为非公平锁，Lock是代码级的，synchronized是JVM级的。</p>
<h5 id="128-预防线程死锁，"><a href="#128-预防线程死锁，" class="headerlink" title="128.预防线程死锁，"></a>128.预防线程死锁，</h5><p>ThreadPoolExecutor提供了四个构造方法：<br>我们以最后一个构造方法(参数最多的那个)，对其参数进行解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // <span class="number">1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,  // <span class="number">2</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,  // <span class="number">3</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,  // <span class="number">4</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue, // <span class="number">5</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,  // <span class="number">6</span></span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler )</span> </span>&#123; <span class="comment">//7</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>序号	名称	类型	含义</p>
<ul>
<li><p>1	corePoolSize	int	核心线程池大小 2	maximumPoolSize	int	最大线程池大小</p>
</li>
<li><p>3	keepAliveTime	long	线程最大空闲时间 4	unit	TimeUnit	时间单位</p>
</li>
<li><p>5	workQueue	BlockingQueue<Runnable>	线程等待队列   </p>
</li>
<li><p>6	threadFactory	ThreadFactory	线程创建工厂      </p>
</li>
<li><p>7	handler	RejectedExecutionHandler	拒绝策略</p>
</li>
</ul>
<p>如果对这些参数作用有疑惑的请看 ThreadPoolExecutor概述。<br>知道了各个参数的作用后，我们开始构造符合我们期待的线程池。首先看JDK给我们预定义的几种线程池：</p>
<h2 id="一、预定义线程池"><a href="#一、预定义线程池" class="headerlink" title="一、预定义线程池"></a>一、预定义线程池</h2><p>FixedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；<br>keepAliveTime &#x3D; 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；<br>workQueue 为LinkedBlockingQueue(无界阻塞队列)，队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；<br>FixedThreadPool的任务执行是无序的；</p>
<p><strong>适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。</strong></p>
<p>CachedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                   <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>corePoolSize &#x3D; 0，maximumPoolSize &#x3D; Integer.MAX_VALUE，即线程数量几乎无限制；<br>keepAliveTime &#x3D; 60s，线程空闲60s后自动结束。 workQueue 为 SynchronousQueue<br>同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；</p>
</blockquote>
<p><strong>适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。</strong></p>
<p>SingleThreadExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">          (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>dome来解释一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;</span><br><span class="line">        System.out.println(threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(<span class="number">8</span>);</span><br><span class="line">        </span><br><span class="line">        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//      运行时异常 java.lang.ClassCastException</span></span><br><span class="line"><span class="comment">//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。</p>
</blockquote>
<p>ScheduledThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。</p>
<pre><code>public ScheduledThreadPoolExecutor(int corePoolSize) &#123;
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
&#125;
</code></pre>
<h2 id="二、自定义线程池"><a href="#二、自定义线程池" class="headerlink" title="二、自定义线程池"></a>二、自定义线程池</h2><p>以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">10</span>;</span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> NameTreadFactory();</span><br><span class="line">        RejectedExecutionHandler handler = <span class="keyword">new</span> MyIgnorePolicy();</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,</span><br><span class="line">                workQueue, threadFactory, handler);</span><br><span class="line">        executor.prestartAllCoreThreads(); <span class="comment">// 预启动所有核心线程</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            MyTask task = <span class="keyword">new</span> MyTask(String.valueOf(i));</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read(); <span class="comment">//阻塞主线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mThreadNum = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r, <span class="string">&quot;my-thread-&quot;</span> + mThreadNum.getAndIncrement());</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; has been created&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIgnorePolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            doLog(r, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 可做日志记录等</span></span><br><span class="line">            System.err.println( r.toString() + <span class="string">&quot; rejected&quot;</span>);</span><br><span class="line"><span class="comment">//          System.out.println(&quot;completedTaskCount: &quot; + e.getCompletedTaskCount());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.toString() + <span class="string">&quot; is running!&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">//让任务执行慢点</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MyTask [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嗯，好累，因为要准备一些考试，这本书就刷到这里啦！哎，小秘密被发现的感觉真不爽。加油生活！！"><a href="#嗯，好累，因为要准备一些考试，这本书就刷到这里啦！哎，小秘密被发现的感觉真不爽。加油生活！！" class="headerlink" title="嗯，好累，因为要准备一些考试，这本书就刷到这里啦！哎，小秘密被发现的感觉真不爽。加油生活！！^ _ ^ !!"></a>嗯，好累，因为要准备一些考试，这本书就刷到这里啦！哎，小秘密被发现的感觉真不爽。加油生活！！^ _ ^ !!</h2><h1 id="2019-3-17"><a href="#2019-3-17" class="headerlink" title="2019.3.17"></a>2019.3.17</h1></div><div class="article-licensing box"><div class="licensing-title"><p>《编写高质量代码(改善Java程序的151个建议)》读书笔记</p><p><a href="https://liruilongs.github.io/2018/11/22/Java/《编写高质量代码(改善Java程序的151个建议)》读书笔记/">https://liruilongs.github.io/2018/11/22/Java/《编写高质量代码(改善Java程序的151个建议)》读书笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2018-11-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2022/02/11/Java/%E3%80%90JAVA%E5%86%B7%E7%9F%A5%E8%AF%86%E3%80%91JAVA%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%8E%BB%E5%AE%9E%E7%8E%B0%E5%AE%83%E5%90%A7%EF%BC%81/" target="_blank">【JAVA冷知识】JAVA居然支持多继承吗？让我们用内部类去吧</a><br></span><span>  2.<a class="is-size-6" href="/2022/02/11/Java/%E3%80%90JAVA%E5%86%B7%E7%9F%A5%E8%AF%86%E3%80%91%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%86%E5%8F%98(contravariant)&amp;%E5%8D%8F%E5%8F%98(covariant)%EF%BC%9F%E6%95%B0%E7%BB%84%E6%94%AF%E6%8C%81%E5%8D%8F%E5%8F%98&amp;%E9%80%86%E5%8F%98%E5%90%97%EF%BC%9F%E6%B3%9B%E5%9E%8B%E5%91%A2%EF%BC%9F/" target="_blank">【JAVA冷知识】什么是逆变(contravariant)与协变(covariant)？数组支持协变&amp;逆变吗？泛型呢？</a><br></span><span>  3.<a class="is-size-6" href="/2022/02/07/Java/%E3%80%90JAVA%E5%86%B7%E7%9F%A5%E8%AF%86%E3%80%91%E6%97%A2%E7%84%B6%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB,%E9%82%A3%E4%B9%88%E7%BC%96%E8%AF%91%E5%90%8E%E7%B1%BB%E5%90%8D%E6%98%AF%E4%BB%80%E4%B9%88,%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B8%8D%E9%80%82%E5%90%88%E6%95%B0%E7%BB%84%E7%B1%BB%EF%BC%9F%E9%82%A3%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%B1%BB/" target="_blank">【JAVA冷知识】既然数组是一个类,为什么动态加载不适合数组类？那如何动态加载一个数组类？</a><br></span><span>  4.<a class="is-size-6" href="/2021/12/08/Java/%E5%85%B3%E4%BA%8E%20JAVA%20%E4%B8%ADvolatile%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/" target="_blank">关于JAVA中volatile使用的一些总结</a><br></span><span>  5.<a class="is-size-6" href="/2020/07/30/Java/Java%E4%B8%ADtry%7B%7Dcatch%E7%9A%84%E9%9A%90%E8%97%8F(%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%9D%97)/" target="_blank">Java中try{}catch的隐藏(如何优雅的实现异常块)</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2023/06/17/AI-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/AdaFace%EF%BC%9A-%E9%80%9A%E8%BF%87AdaFace%E5%AE%9E%E7%8E%B0%E4%BD%8E%E8%B4%A8%E9%87%8F%E9%9D%A2%E9%83%A8%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%B2%BE%E5%87%86%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" target="_blank">AdaFace(CVPR(2022))：通过AdaFace实现低质量面部数据集的人脸识别</a><br></span><span>  3.<a class="is-size-6" href="/2023/06/15/AI-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Nvidia%203060%20%E6%98%BE%E5%8D%A1%20CUDA%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(Ubuntu22.04+Nvidia%20510+Cuda11.6+cudnn8.8)/" target="_blank">Nvidia 3060 显卡 CUDA 环境搭建(Ubuntu22.04+Nvidia 510+Cuda11.6+cudnn8.8)</a><br></span><span>  4.<a class="is-size-6" href="/2023/05/04/AI-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/DeepFace%EF%BC%9A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%93%20DeepFace%20%E7%AE%80%E5%8D%95%E8%AE%A4%E7%9F%A5/" target="_blank">DeepFace：人脸识别库 DeepFace 简单认知</a><br></span><span>  5.<a class="is-size-6" href="/2023/12/19/AI-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Stable-Diffusion-Windows%E9%83%A8%E7%BD%B2%E7%AE%80%E7%AD%94%E8%AE%A4%E7%9F%A5/" target="_blank">Stable Diffusion 简单认知 Windows 部署</a><br></span><span>  6.<a class="is-size-6" href="/2023/07/24/AI-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E4%BD%BF%E7%94%A8-OpenCV-%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A%E5%BA%A6%E6%A3%80%E6%B5%8B-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E5%B7%AE%E6%96%B9%E6%B3%95/" target="_blank">使用 OpenCV 进行图像模糊度检测(拉普拉斯方差方法)</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/03/Java/JVM%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JVM和性能优化</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/03/01/web/%E3%80%8AAjax%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-item">《Ajax基础教程》读书笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'f216ea07c8a5ae682f57fc315afbd18e',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》"><span class="mr-2">1.1.1</span><span>时间只是供我垂钓的溪流，在我喝着溪水的时候，我看的到它的沙床，它是那么浅啊，浅浅的洗漱流去了。永恒却留在原地。我愿痛饮，我愿在天上垂钓，在天空的底层，看着石子似的星星。—————《瓦尔登湖》</span></a></li></ul></ul><li><a class="is-flex is-mobile" href="#建议"><span class="mr-2">2</span><span>建议</span></a></li><li><a class="is-flex is-mobile" href="#第一章，Java开发中通用的方法和准则"><span class="mr-2">3</span><span>第一章，Java开发中通用的方法和准则</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#20-不要只替换一个类，-发布应用系统时禁止使用类文件替换方式，整体的WAR包发布才是万全之策"><span class="mr-2">3.1.1</span><span>20. 不要只替换一个类，(发布应用系统时禁止使用类文件替换方式，整体的WAR包发布才是万全之策)</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第二章，基本类型"><span class="mr-2">4</span><span>第二章，基本类型</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#30-不要随便设置随机种子："><span class="mr-2">4.1.1</span><span>30. 不要随便设置随机种子：</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第三章，类对象及方法"><span class="mr-2">5</span><span>第三章，类对象及方法</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#51-不要主动进行垃圾回收。"><span class="mr-2">5.1.1</span><span>51. 不要主动进行垃圾回收。</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第四章，字符串"><span class="mr-2">6</span><span>第四章，字符串</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#59-对字符串排序持一种宽容的心态，如果排序不是关键算法，用Collator类即可。"><span class="mr-2">6.1.1</span><span>59. 对字符串排序持一种宽容的心态，如果排序不是关键算法，用Collator类即可。</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第五章，数组和集合"><span class="mr-2">7</span><span>第五章，数组和集合</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#82-由点几面，集合大家族："><span class="mr-2">7.1.1</span><span>82.由点几面，集合大家族：</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第六章，-枚举和注解"><span class="mr-2">8</span><span>第六章， 枚举和注解</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#92-注意-Override不同版本的区别，在1-6版本中可以在实现接口中加上-Override，而以下版本父类必须是一个类，子类方法和父类方法必须具有相同的方法名，输入参数，输出参数-允许缩小-，访问权限-允许类扩大-。"><span class="mr-2">8.1.1</span><span>92.注意@Override不同版本的区别，在1.6版本中可以在实现接口中加上@Override，而以下版本父类必须是一个类，子类方法和父类方法必须具有相同的方法名，输入参数，输出参数(允许缩小)，访问权限(允许类扩大)。</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第七章，泛型和反射"><span class="mr-2">9</span><span>第七章，泛型和反射</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#109-不需要太多的关注反射效率，"><span class="mr-2">9.1.1</span><span>109.不需要太多的关注反射效率，</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第八章-异常"><span class="mr-2">10</span><span>第八章 异常</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#122-使用线程异常处理器提升系统可靠性，在java1-5版本后在Thread类中增加了setUncaughhtExceptionHandle方法，实现了异常的捕捉和处理，"><span class="mr-2">10.1.1</span><span>122.使用线程异常处理器提升系统可靠性，在java1.5版本后在Thread类中增加了setUncaughhtExceptionHandle方法，实现了异常的捕捉和处理，</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第九章-线程安全"><span class="mr-2">11</span><span>第九章 线程安全</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#128-预防线程死锁，"><span class="mr-2">11.1.1</span><span>128.预防线程死锁，</span></a></li></ul><li><a class="is-flex is-mobile" href="#一、预定义线程池"><span class="mr-2">11.2</span><span>一、预定义线程池</span></a></li><li><a class="is-flex is-mobile" href="#二、自定义线程池"><span class="mr-2">11.3</span><span>二、自定义线程池</span></a></li><li><a class="is-flex is-mobile" href="#嗯，好累，因为要准备一些考试，这本书就刷到这里啦！哎，小秘密被发现的感觉真不爽。加油生活！！"><span class="mr-2">11.4</span><span>嗯，好累，因为要准备一些考试，这本书就刷到这里啦！哎，小秘密被发现的感觉真不爽。加油生活！！^ _ ^ !!</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#2019-3-17"><span class="mr-2">12</span><span>2019.3.17</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">439</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">144</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">191</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-13T14:50:54.000Z">2025-04-13</time></p><p class="title"><a href="/2025/04/13/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%B0%B7%E6%AD%8C68%E9%A1%B5%E7%99%BD%E7%9A%AE%E4%B9%A6%E8%A7%A3%E5%AF%86%EF%BC%9A%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%A6%82%E4%BD%95%E9%87%8D%E5%A1%91AI%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91/">谷歌68页白皮书解密：提示工程如何重塑AI交互逻辑</a></p><p class="categories"><a href="/categories/LLM/">LLM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-11T11:38:12.000Z">2025-04-11</time></p><p class="title"><a href="/2025/04/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%85%A8%E9%9D%A2%E7%9B%91%E6%8E%A7/">Linux 系统内存监控：Linux 内存调优之系统内存全面监控</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-11T11:38:12.000Z">2025-04-11</time></p><p class="title"><a href="/2025/04/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B7%B1%E5%BA%A6%E7%9B%91%E6%8E%A7/">Linux 进程内存监控：Linux 内存调优之进程内存深度监控</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T23:32:10.000Z">2025-04-08</time></p><p class="title"><a href="/2025/04/08/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%AE%A4%E8%AF%86%20Linux%20%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98/">认识 Linux 内存构成：Linux 内存调优之虚拟内存与物理内存</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-06T23:32:10.000Z">2025-04-07</time></p><p class="title"><a href="/2025/04/07/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8BCPU%E8%B0%83%E4%BC%98%E8%AE%A4%E7%9F%A5/">Linux 性能调优之CPU调优认知</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AIGC/"><span class="level-start"><span class="level-item">AIGC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/BPF/"><span class="level-start"><span class="level-item">BPF</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">98</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">55</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"><span class="tag">华为云</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLM/"><span class="tag">LLM</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mysql/"><span class="tag">Mysql</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BPF/"><span class="tag">BPF</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%BD%B1%E6%9B%9D%E5%85%89/"><span class="tag">摄影曝光</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2025 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案中</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>