<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JVM和性能优化 - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="一直对微服务和分布式这两个概念模凌两可，不是太清晰，而且接触的项目也没这么大体量，没有用到过，所以蹭现在有时间总结一下，总结很大部分来源于《从Paxos到Zookper分布式一致性原理与实践》和《微服务架构设计模式》这两本书里，博文中理解有所欠缺的小伙伴请留言,多多指教。"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://liruilong.blog.csdn.net/?t=1&amp;type=blog"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="一直对微服务和分布式这两个概念模凌两可，不是太清晰，而且接触的项目也没这么大体量，没有用到过，所以蹭现在有时间总结一下，总结很大部分来源于《从Paxos到Zookper分布式一致性原理与实践》和《微服务架构设计模式》这两本书里，博文中理解有所欠缺的小伙伴请留言,多多指教。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liruilong.blog.csdn.net/img/头像.jpg"><meta property="article:published_time" content="2020-07-03T10:37:25.000Z"><meta property="article:modified_time" content="2023-06-21T11:25:59.025Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="JVM"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2020/07/03/Java/JVM%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},"headline":"山河已无恙","image":["https://liruilongs.github.io/img/og_image.png"],"datePublished":"2020-07-03T10:37:25.000Z","dateModified":"2023-06-21T11:25:59.025Z","author":{"@type":"Person","name":"山河已无恙"},"description":"一直对微服务和分布式这两个概念模凌两可，不是太清晰，而且接触的项目也没这么大体量，没有用到过，所以蹭现在有时间总结一下，总结很大部分来源于《从Paxos到Zookper分布式一致性原理与实践》和《微服务架构设计模式》这两本书里，博文中理解有所欠缺的小伙伴请留言,多多指教。"}</script><link rel="canonical" href="https://liruilongs.github.io/2020/07/03/Java/JVM%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-07-03  <a class="commentCountImg" href="/2020/07/03/Java/JVM%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#comment-container"><span class="display-none-class">2bd396554c826440a9f57c719243f17c</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="2bd396554c826440a9f57c719243f17c">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>21.3 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM和性能优化</h1><div class="content"><p>一直对微服务和分布式这两个概念模凌两可，不是太清晰，而且接触的项目也没这么大体量，没有用到过，所以蹭现在有时间总结一下，总结很大部分来源于《从Paxos到Zookper分布式一致性原理与实践》和《微服务架构设计模式》这两本书里，博文中理解有所欠缺的小伙伴请留言,多多指教。</p>
<span id="more"></span>


<h1 id="JVM和性能优化"><a href="#JVM和性能优化" class="headerlink" title="JVM和性能优化"></a>JVM和性能优化</h1><h2 id="1、Java内存区域"><a href="#1、Java内存区域" class="headerlink" title="1、Java内存区域"></a>1、Java内存区域</h2><h3 id="虚拟机的历史"><a href="#虚拟机的历史" class="headerlink" title="虚拟机的历史"></a>虚拟机的历史</h3><h3 id="未来的Java技术一览"><a href="#未来的Java技术一览" class="headerlink" title="未来的Java技术一览"></a>未来的Java技术一览</h3><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><ul>
<li><p>各个区域的作用</p>
<ul>
<li><p>程序计数器</p>
<blockquote>
<p>当前线程执行的字节码的行号指示器，占用空间小，也无法干涉</p>
</blockquote>
</li>
<li><p>栈</p>
<blockquote>
<p>每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。<br>栈桢大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</p>
</blockquote>
</li>
<li><p>堆</p>
<blockquote>
<p>几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：<br>-Xms：堆的最小值；<br>-Xmx：堆的最大值；<br>-Xmn：新生代的大小；<br>-XX:NewSize；新生代最小值；<br>-XX:MaxNewSize：新生代最大值；<br>例如- Xmx256m</p>
</blockquote>
</li>
<li><p>方法区</p>
<blockquote>
<p>用于存储已经被虚拟机加载的类信息，常量(“zdy”,”123”等)，静态变量(static变量)等数据，可用以下参数调整：<br>jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；<br>jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize<br>jdk1.8以后大小就只受本机总内存的限制<br>如：-XX:MaxMetaspaceSize&#x3D;3M</p>
</blockquote>
</li>
<li><p>运行时常量池</p>
<ul>
<li><p>各个版本内存区域的变化</p>
<ul>
<li><p>1.6</p>
<blockquote>
<p>运行时常量池在方法区</p>
</blockquote>
</li>
<li><p>1.7</p>
<blockquote>
<p>运行时常量池在堆</p>
</blockquote>
</li>
<li><p>1.8</p>
<blockquote>
<p>运行时常量池在元数据区</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>直接内存</p>
<blockquote>
<p>不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；<br>这块内存不受java堆大小限制，但受本机总内存的限制，可以通过-XX:MaxDirectMemorySize来设置(默认与堆内存最大值一样)，所以也会出现OOM异常。</p>
</blockquote>
</li>
</ul>
<h3 id="站在线程角度来看堆和栈"><a href="#站在线程角度来看堆和栈" class="headerlink" title="站在线程角度来看堆和栈"></a>站在线程角度来看堆和栈</h3><h3 id="深入辨析堆和栈"><a href="#深入辨析堆和栈" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h3><h3 id="深入辨析堆和栈-1"><a href="#深入辨析堆和栈-1" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h3><ul>
<li>功能 <blockquote>
<ol>
<li>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量(int、short、long、byte、float、double、boolean、har等)以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>	而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中</li>
</ol>
<ul>
<li>线程独享还是共享<blockquote>
<ol>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
</ol>
<ul>
<li>空间大小<blockquote>
<p>栈的内存要远远小于堆内存</p>
</blockquote>
</li>
</ul>
<h3 id="方法的出入栈"><a href="#方法的出入栈" class="headerlink" title="方法的出入栈"></a>方法的出入栈</h3><ul>
<li><p>栈桢</p>
<blockquote>
<p>一个方法的调用，就会在栈上分配一个栈帧</p>
</blockquote>
</li>
<li><p>栈上分配</p>
<blockquote>
<p>虚拟机提供的一种优化技术，基本思想是，对于线程私有的对象，将它打散分配在栈上，而不分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。<br>栈上分配需要的技术基础，逃逸分析。逃逸分析的目的是判断对象的作用域是否会逃逸出方法体。注意，任何可以在多个线程之间共享的对象，一定都属于逃逸对象。</p>
</blockquote>
<ul>
<li>栈上分配的效果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,inty )</span></span>&#123;</span><br><span class="line">   String x = “”;</span><br><span class="line">   User u = ….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样的User的对象实例，分配100000000次，启用栈上分配，只需6ms，不启用，需要3S。</p>
</blockquote>
</li>
</ul>
<h3 id="虚拟机中的对象"><a href="#虚拟机中的对象" class="headerlink" title="虚拟机中的对象"></a>虚拟机中的对象</h3><ul>
<li><p>分配过程</p>
<blockquote>
<p>虚拟机遇到一条new指令时,先执行相应的类加载过程,<br>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。<br>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。<br>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。<br>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。<br>解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；<br>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)，如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。<br>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。<br>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满(分配指针top撞上分配极限end了)，就新申请一个TLAB。</p>
<ol start="3">
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</li>
<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。<br>对象的内存布局<br>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。<br>对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。<br>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ol>
</blockquote>
</li>
<li><p>内存布局</p>
</li>
<li><p>对象的访问定位</p>
<blockquote>
<p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。<br>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<br>如果使用直接指针访问， reference中存储的直接就是对象地址。<br>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。<br>对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p>
</blockquote>
</li>
</ul>
<h3 id="堆参数设置和内存溢出实战"><a href="#堆参数设置和内存溢出实战" class="headerlink" title="堆参数设置和内存溢出实战"></a>堆参数设置和内存溢出实战</h3><ul>
<li>Java堆溢出</li>
<li>新生代配置</li>
<li>方法区和运行时常量池溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>本机直接内存溢出</li>
</ul>
<h2 id="2、垃圾回收器和内存分配策略"><a href="#2、垃圾回收器和内存分配策略" class="headerlink" title="2、垃圾回收器和内存分配策略"></a>2、垃圾回收器和内存分配策略</h2><h3 id="GC概述"><a href="#GC概述" class="headerlink" title="GC概述"></a>GC概述</h3><h3 id="判断对象的存活"><a href="#判断对象的存活" class="headerlink" title="判断对象的存活"></a>判断对象的存活</h3><ul>
<li><p>引用计数法</p>
<blockquote>
<p>快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否改回收。</p>
</blockquote>
</li>
<li><p>可达性分析</p>
<blockquote>
<p>来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>作为GC Roots的对象包括下面几种：<br>	1. 虚拟机栈(栈帧中的本地变量表)中引用的对象。<br>	2. 方法区中类静态属性引用的对象。<br>	3. 方法区中常量引用的对象。<br>	4. 本地方法栈中JNI(即一般说的Native方法)引用的对象。</p>
</blockquote>
</li>
</ul>
<h3 id="辨析强、弱等各种引用"><a href="#辨析强、弱等各种引用" class="headerlink" title="辨析强、弱等各种引用"></a>辨析强、弱等各种引用</h3><ul>
<li><p>强引用</p>
<blockquote>
<p>一般的Object obj &#x3D; new Object() ，就属于强引用。</p>
</blockquote>
</li>
<li><p>软引用 SoftReference</p>
<blockquote>
<p>一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。</p>
</blockquote>
</li>
<li><p>弱引用 WeakReference</p>
<blockquote>
<p>一些有用(程度比软引用更低)但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。</p>
</blockquote>
</li>
<li><p>虚引用 PhantomReference</p>
<blockquote>
<p>幽灵引用，最弱，被垃圾回收的时候收到一个通知</p>
</blockquote>
</li>
</ul>
<p>###注意<br>软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。<br>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><ul>
<li><p>标记-清除算法</p>
<blockquote>
<p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
</li>
<li><p>复制算法</p>
<blockquote>
<p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原<br>来的一半。</p>
</blockquote>
</li>
<li><p>标记-整理算法</p>
<blockquote>
<p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
</blockquote>
</li>
</ul>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
<h3 id="Stop-The-World现象"><a href="#Stop-The-World现象" class="headerlink" title="Stop The World现象"></a>Stop The World现象</h3><blockquote>
<p>GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数</p>
</blockquote>
<h3 id="GC日志解读"><a href="#GC日志解读" class="headerlink" title="GC日志解读"></a>GC日志解读</h3><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><blockquote>
<p>对象优先在Eden分配，如果说Eden内存空间不足，就会发生Minor GC<br>大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组，1、导致内存有空间，还是需要提前进行垃圾回收获取连续空间来放他们，2、会进行大量的内存复制。<br>-XX:PretenureSizeThreshold 参数 ，大于这个数量直接在老年代分配，缺省为0 ，表示绝不会直接分配在老年代。<br>长期存活的对象将进入老年代，默认15岁，-XX:MaxTenuringThreshold调整<br>动态对象年龄判定，为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄<br>空间分配担保：新生代中有大量的对象存活，survivor空间不够，当出现大量对象在MinorGC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代.只要老年代的连续空间大于新生代对象的总大小或者历次晋升的平均大小，就进行Minor GC，否则FullGC。</p>
</blockquote>
<h3 id="内存泄漏和内存溢出辨析"><a href="#内存泄漏和内存溢出辨析" class="headerlink" title="内存泄漏和内存溢出辨析"></a>内存泄漏和内存溢出辨析</h3><blockquote>
<p>内存溢出：实实在在的内存空间不足导致；<br>内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下。</p>
</blockquote>
<h3 id="JDK为我们提供的工具"><a href="#JDK为我们提供的工具" class="headerlink" title="JDK为我们提供的工具"></a>JDK为我们提供的工具</h3><ul>
<li><p>jps </p>
<blockquote>
<p>列出当前机器上正在运行的虚拟机进程<br>-p  :仅仅显示VM 标示，不显示jar,class, main参数等信息.<br>-m:输出主函数传入的参数. 下的hello 就是在执行程序时从命令行输入的参数<br>-l: 输出应用程序主类完整package名称或jar完整名称.<br>-v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数</p>
</blockquote>
</li>
<li><p>jstat</p>
<blockquote>
<p>是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。<br>假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat-gc 2764 250 20<br>常用参数：<br>-class (类加载器)<br>-compiler (JIT)<br>-gc (GC堆状态)<br>-gccapacity (各区大小)<br>-gccause (最近一次GC统计和原因)<br>-gcnew (新区统计)<br>-gcnewcapacity (新区大小)<br>-gcold (老区统计)<br>-gcoldcapacity (老区大小)<br>-gcpermcapacity (永久区大小)<br>-gcutil (GC统计汇总)<br>-printcompilation (HotSpot编译统计)</p>
</blockquote>
</li>
<li><p>jinfo </p>
<blockquote>
<p>查看和修改虚拟机的参数<br>jinfo –sysprops 可以查看由System.getProperties()取得的参数<br>jinfo –flag 未被显式指定的参数的系统默认值<br>jinfo –flags(注意s)显示虚拟机的参数<br>jinfo –flag +[参数] 可以增加参数，但是仅限于由java -XX:+PrintFlagsFinal –version查询出来且<br>为manageable的参数<br>jinfo –flag -[参数] 可以去除参数</p>
</blockquote>
</li>
<li><p>jmap</p>
<blockquote>
<p>用于生成堆转储快照(一般称为heapdump或dump文件)。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux&#x2F;Solaris下使用。<br>jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin <pid><br>Sun JDK提供jhat(JVM Heap Analysis Tool)命令与jmap搭配使用，来分析jmap生成的堆转储快照。</p>
</blockquote>
</li>
<li><p>jhat</p>
<blockquote>
<p>jhat dump文件名<br>后屏幕显示“Server is ready.”的提示后，用户在浏览器中键入<a href="http://localhost：7000/就可以访问详情">http://localhost：7000/就可以访问详情</a></p>
</blockquote>
</li>
<li><p>jstack</p>
<blockquote>
<p>(Stack Trace for Java)命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。<br>在代码中可以用java.lang.Thread类的getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。</p>
</blockquote>
</li>
</ul>
<p>管理远程进程需要在远程程序的启动参数中增加：<br>-Djava.rmi.server.hostname&#x3D;…..<br>-Dcom.sun.management.jmxremote<br>-Dcom.sun.management.jmxremote.port&#x3D;8888<br>-Dcom.sun.management.jmxremote.authenticate&#x3D;false<br>-Dcom.sun.management.jmxremote.ssl&#x3D;false</p>
<h3 id="了解MAT"><a href="#了解MAT" class="headerlink" title="了解MAT"></a>了解MAT</h3><ul>
<li>浅堆和深堆<blockquote>
<p><strong>浅堆</strong> :(Shallow Heap)是指一个对象所消耗的内存。例如，在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。<br><strong>深堆</strong> ：这个对象被GC回收后，可以真实释放的内存大小，也就是只能通过对象被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象所持有的对象的集合。深堆是指对象的保留集中所有的对象的浅堆大小之和。<br>__举例__：对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内</p>
</blockquote>
</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul>
<li>把算法们都用上<blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>垃圾回收器概览</p>
<blockquote>
<p>Serial&#x2F;Serial Old、ParNew 、Parallel Scavenge(ParallerGC)&#x2F;Parallel Old、Concurrent Mark Sweep (CMS)、G1</p>
</blockquote>
</li>
<li><p>垃圾回收器工作详解</p>
</li>
<li><p>G1详解</p>
</li>
<li><p>未来的垃圾回收</p>
<blockquote>
<p>ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大我也是通过并发的时间去回收了<br>关键技术</p>
<ol>
<li><pre><code>有色指针(Colored Pointers)
</code></pre>
<ol start="2">
<li><pre><code>加载屏障(Load Barrier)
</code></pre>
</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="垃圾回收器-1"><a href="#垃圾回收器-1" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul>
<li>把算法们都用上<blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<br>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>垃圾回收器概览</p>
<blockquote>
<p>Serial&#x2F;Serial Old、ParNew 、Parallel Scavenge(ParallerGC)&#x2F;Parallel Old、Concurrent Mark Sweep (CMS)、G1</p>
</blockquote>
</li>
<li><p>垃圾回收器工作详解</p>
</li>
<li><p>G1详解</p>
</li>
<li><p>未来的垃圾回收</p>
<blockquote>
<p>ZGC通过技术手段把stw的情况控制在仅有一次，就是第一次的初始标记才会发生，这样也就不难理解为什么GC停顿时间不随着堆增大而上升了，再大我也是通过并发的时间去回收了<br>关键技术</p>
<ol>
<li><pre><code>有色指针(Colored Pointers)
</code></pre>
<ol start="2">
<li><pre><code>加载屏障(Load Barrier)
</code></pre>
</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3、JVM的执行子系统"><a href="#3、JVM的执行子系统" class="headerlink" title="3、JVM的执行子系统"></a>3、JVM的执行子系统</h2><h3 id="Class类文件本质"><a href="#Class类文件本质" class="headerlink" title="Class类文件本质"></a>Class类文件本质</h3><blockquote>
</blockquote>
<ol>
<li>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码(ByteCode)是构成平台无关性的基石，也是语言无关性的基础。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</li>
<li>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。<br>Class文件是一组以8位字节为基础单位的二进制流。</li>
</ol>
<h3 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h3><blockquote>
<p>各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。<br>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。<br>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。<br>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p>
</blockquote>
<ul>
<li>格式详解</li>
</ul>
<h4 id="Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。按顺序包括："><a href="#Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。按顺序包括：" class="headerlink" title="Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。按顺序包括："></a>Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。按顺序包括：</h4><ul>
<li><p>魔数与Class文件的版本</p>
<blockquote>
<p>每个Class文件的头4个字节称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。<br>  紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号(MinorVersion)，第7和第8个字节是主版本号(Major Version)。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</blockquote>
</li>
<li><p>常量池</p>
<blockquote>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的<br>  常量池中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References)。<br>  字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。<br>  而符号引用则属于编译原理方面的概念，包括了下面三类常量：<br>  类和接口的全限定名(Fully Qualified Name)、字段的名称和描述符(Descriptor)、方法的名称和描述符</p>
</blockquote>
</li>
<li><p>访问标志</p>
<blockquote>
<p>用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等</p>
</blockquote>
</li>
<li><p>类索引、父类索引与接口索引集合</p>
<blockquote>
<p>这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中</p>
</blockquote>
</li>
<li><p>字段表集合</p>
<blockquote>
<p>描述接口或者类中声明的变量。字段(field)包括类级变量以及实例级变量。<br>  而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。<br>  字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>
</blockquote>
</li>
<li><p>方法表集合</p>
<blockquote>
<p>描述了方法的定义，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。<br>  与字段表集合相类似的，如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”</p>
</blockquote>
</li>
<li><p>属性表集合</p>
<blockquote>
<p>存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。</p>
</blockquote>
</li>
</ul>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><ul>
<li><p>悉知</p>
<blockquote>
<p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数，Operands)而构成。<br>由于限制了Java虚拟机操作码的长度为一个字节(即0～255)，这意味着指令集的操作码总数不可能超过256条。<br>大多数的指令都包含了其操作所对应的数据类型信息。例如：<br>iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。<br>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型<br>阅读字节码作为了解Java虚拟机的基础技能，请熟练掌握。请熟悉并掌握常见指令即可。</p>
</blockquote>
</li>
<li><p>加载和存储指令</p>
<blockquote>
<p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容。<br>将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。<br>将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。<br>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。<br>扩充局部变量表的访问索引的指令：wide。</p>
</blockquote>
</li>
<li><p>运算或算术指令</p>
<blockquote>
<p>用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。<br>加法指令：iadd、ladd、fadd、dadd。<br>减法指令：isub、lsub、fsub、dsub。<br>乘法指令：imul、lmul、fmul、dmul等等</p>
</blockquote>
</li>
<li><p>类型转换指令</p>
<blockquote>
<p>可以将两种不同的数值类型进行相互转换，<br>Java虚拟机直接支持以下数值类型的宽化类型转换(即小范围类型向大范围类型的安全转换)：<br>int类型到long、float或者double类型。<br>long类型到float、double类型。<br>float类型到double类型。<br>处理窄化类型转换(Narrowing Numeric Conversions)时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p>
</blockquote>
</li>
<li><p>创建类实例的指令</p>
<blockquote>
<p>new</p>
</blockquote>
</li>
<li><p>创建数组的指令</p>
<blockquote>
<p>newarray、anewarray、multianewarray</p>
</blockquote>
</li>
<li><p>访问字段指令</p>
<blockquote>
<p>getfield、putfield、getstatic、putstatic</p>
</blockquote>
</li>
<li><p>数组存取相关指令</p>
<blockquote>
<p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。<br>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。<br>取数组长度的指令：arraylength。</p>
</blockquote>
</li>
<li><p>检查类实例类型的指令</p>
<blockquote>
<p>instanceof、checkcast</p>
</blockquote>
</li>
</ul>
<p>*操作数栈管理指令</p>
<blockquote>
<p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：将操作数栈的栈顶一个或两个元素出栈：pop、pop2。<br>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。<br>将栈最顶端的两个数值互换：swap</p>
</blockquote>
<ul>
<li><p>控制转移指令</p>
<blockquote>
<p>控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。<br>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。<br>复合条件分支：tableswitch、lookupswitch。<br>无条件分支：goto、goto_w、jsr、jsr_w、ret。</p>
</blockquote>
</li>
<li><p>方法调用指令</p>
<blockquote>
<p>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，这也是Java语言中最常见的方法分派方式。<br>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。<br>invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。<br>invokestatic指令用于调用类方法(static方法)。<br>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。<br>方法调用指令与数据类型无关。</p>
</blockquote>
</li>
<li><p>方法返回指令</p>
<blockquote>
<p>是根据返回值的类型区分的，包括ireturn(当返回值是boolean、byte、char、short和int类型时使用)、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p>
</blockquote>
</li>
<li><p>异常处理指令</p>
<blockquote>
<p>在Java程序中显式抛出异常的操作(throw语句)都由athrow指令来实现</p>
</blockquote>
</li>
<li><p>同步指令</p>
<blockquote>
<p>有monitorenter和monitorexit两条指令来支持synchronized关键字的语义</p>
</blockquote>
</li>
</ul>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><ul>
<li><p>加载过程详解</p>
<ul>
<li>概述<blockquote>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接(Linking)<br>于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：</p>
</blockquote>
</li>
</ul>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<ul>
<li><p>注意</p>
<blockquote>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。<br>常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。<br>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p>
</blockquote>
</li>
<li><p>加载阶段</p>
<blockquote>
<p>虚拟机需要完成以下3件事情：</p>
</blockquote>
</li>
</ul>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<ul>
<li><p>验证</p>
<blockquote>
<p>是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
</blockquote>
</li>
<li><p>准备阶段</p>
<blockquote>
<p>是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量(被static修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：<br>public static int value&#x3D;123；<br>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。表7-1列出了Java中所有基本数据类型的零值。<br>假设上面类变量value的定义变为：public static final int value&#x3D;123；<br>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
</blockquote>
</li>
<li><p>解析阶段</p>
<blockquote>
<p>是虚拟机将常量池内的符号引用替换为直接引用的过程</p>
</blockquote>
</li>
<li><p>类初始化阶段</p>
<blockquote>
<p>是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。＜clinit＞()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。<br>＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。<br>虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞()方法中有耗时很长的操作，就可能造成多个进程阻塞。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>类加载器</p>
<ul>
<li><p>自定义类加载对类进行加密和解密</p>
<blockquote>
<p>重写findClass方法</p>
</blockquote>
</li>
<li><p>系统的类加载器</p>
<blockquote>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<br>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。<br>在自定义ClassLoader的子类时候，我们常见的会有两种做法，一种是重写loadClass方法，另一种是重写findClass方法。其实这两种方法本质上差不多，毕竟loadClass也会调用findClass，但是从逻辑上讲我们最好不要直接修改loadClass的内部逻辑。我建议的做法是只在findClass里重写自定义类的加载方法。<br>loadClass这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p>
</blockquote>
</li>
<li><p>双亲委派模型</p>
<blockquote>
<p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。<br>启动类加载器(Bootstrap ClassLoader)：这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。<br>扩展类加载器(Extension ClassLoader)：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<br>应用程序类加载器(Application ClassLoader)：这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。<br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。<br>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Tomcat类加载机制</p>
<blockquote>
<p>Tomcat本身也是一个java项目，因此其也需要被JDK的类加载机制加载，也就必然存在引导类加载器、扩展类加载器和应用(系统)类加载器。<br>Common ClassLoader作为Catalina ClassLoader和Shared ClassLoader的parent，而Shared ClassLoader又可能存在多个children类加载器WebApp ClassLoader，一个WebApp ClassLoader实际上就对应一个Web应用，那Web应用就有可能存在Jsp页面，这些Jsp页面最终会转成class类被加载，因此也需要一个Jsp的类加载器。<br>需要注意的是，在代码层面Catalina ClassLoader、Shared ClassLoader、Common ClassLoader对应的实体类实际上都是URLClassLoader或者SecureClassLoader，一般我们只是根据加载内容的不同和加载父子顺序的关系，在逻辑上划分为这三个类加载器；而WebApp ClassLoader和JasperLoader都是存在对应的类加载器类的。<br>当tomcat启动时，会创建几种类加载器：<br>1 Bootstrap 引导类加载器 加载JVM启动所需的类，以及标准扩展类(位于jre&#x2F;lib&#x2F;ext下)<br>2 System 系统类加载器 加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME&#x2F;bin下。<br>3 Common 通用类加载器 加载tomcat使用以及应用通用的一些类，位于CATALINA_HOME&#x2F;lib下，比如servlet-api.jar<br>4 webapp 应用类加载器每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF&#x2F;lib下的jar文件中的class 和 WEB-INF&#x2F;classes下的class文件。</p>
</blockquote>
</li>
</ul>
<h3 id="栈桢详解"><a href="#栈桢详解" class="headerlink" title="栈桢详解"></a>栈桢详解</h3><h3 id="方法调用详解"><a href="#方法调用详解" class="headerlink" title="方法调用详解"></a>方法调用详解</h3><blockquote>
<p>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。<br>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
</blockquote>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><ul>
<li>基于栈的指令集与基于寄存器的指令集</li>
<li>分析代码在虚拟机中的执行情况</li>
</ul>
<h2 id="4、编写高效优雅Java程序"><a href="#4、编写高效优雅Java程序" class="headerlink" title="4、编写高效优雅Java程序"></a>4、编写高效优雅Java程序</h2><h3 id="构造器参数太多怎么办？"><a href="#构造器参数太多怎么办？" class="headerlink" title="构造器参数太多怎么办？"></a>构造器参数太多怎么办？</h3><blockquote>
<p>用builder模式，用在<br>1、5个或者5个以上的成员变量<br>2、参数不多，但是在未来，参数会增加</p>
</blockquote>
<h3 id="不需要实例化的类应该构造器私有"><a href="#不需要实例化的类应该构造器私有" class="headerlink" title="不需要实例化的类应该构造器私有"></a>不需要实例化的类应该构造器私有</h3><h3 id="不要创建不必要的对象"><a href="#不要创建不必要的对象" class="headerlink" title="不要创建不必要的对象"></a>不要创建不必要的对象</h3><ul>
<li><p>避免无意中创建的对象，如自动装箱循环内因为会自动装箱拆箱，创建无用的对象。</p>
</li>
<li><p>可以在类的多个实例之间重用的成员变量，尽量使用static。</p>
</li>
</ul>
<h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><blockquote>
<p>finalizer方法，jdk不能保证何时执行，也不能保证一定会执行。如果有确实要释放的资源应该用try&#x2F;finally。</p>
</blockquote>
<h3 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h3><blockquote>
<p>编写程序和设计架构，最重要的目标之一就是模块之间的解耦。使类和成员的可访问性最小化无疑是有效的途径之一。</p>
</blockquote>
<h3 id="使可变性最小化"><a href="#使可变性最小化" class="headerlink" title="使可变性最小化"></a>使可变性最小化</h3><blockquote>
<p>尽量使类不可变，不可变的类比可变的类更加易于设计、实现和使用，而且更不容易出错，更安全。<br>常用的手段：<br>不提供任何可以修改对象状态的方法；<br>使所有的域都是final的。<br>使所有的域都是私有的。<br>使用写时复制机制。带来的问题：会导致系统产生大量的对象，而且性能有一定的影响，需要在使用过程中小心权衡。</p>
</blockquote>
<h3 id="优先使用复合"><a href="#优先使用复合" class="headerlink" title="优先使用复合"></a>优先使用复合</h3><blockquote>
<p>继承容易破坏封装性，而且会使子类的实现依赖于父类。<br>复合则是在类中增加一个私有域，引用类的一个实例，这样的话就避免了依赖类的具体实现。<br>只有在子类确实是父类的一个子类型时，才比较适合用继承。</p>
</blockquote>
<h3 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h3><h3 id="可变参数要谨慎使用"><a href="#可变参数要谨慎使用" class="headerlink" title="可变参数要谨慎使用"></a>可变参数要谨慎使用</h3><blockquote>
<p>可变参数是允许传0个参数的<br>如果是参数个数在1~多个之间的时候，要做单独的业务控制</p>
</blockquote>
<h3 id="返回零长度的数组或集合，不要返回null"><a href="#返回零长度的数组或集合，不要返回null" class="headerlink" title="返回零长度的数组或集合，不要返回null"></a>返回零长度的数组或集合，不要返回null</h3><h3 id="优先使用标准的异常"><a href="#优先使用标准的异常" class="headerlink" title="优先使用标准的异常"></a>优先使用标准的异常</h3><blockquote>
<p>要尽量追求代码的重用，同时减少类加载的数目，提高类装载的性能。<br>常用的异常：<br>IlegalAraumentException  – 调用者传递的参数不合适<br>lllegalStateException – 接收的对象状态不对，<br>NullPointException  -空指针异常<br>UnsupportedOperationException –不支持的操作</p>
</blockquote>
<h3 id="用枚举代替int常量"><a href="#用枚举代替int常量" class="headerlink" title="用枚举代替int常量"></a>用枚举代替int常量</h3><h3 id="将局部变量的作用域最小化"><a href="#将局部变量的作用域最小化" class="headerlink" title="将局部变量的作用域最小化"></a>将局部变量的作用域最小化</h3><blockquote>
<p>1、在第一次使用的地方进行声明<br>2、局部变量都是要自行初始化，初始化条件不满足，就不要声明<br>最小化的好处，减小局部变量表的大小，提示性能；同时避免局部变量过早声明导致不正确的使用。</p>
</blockquote>
<h3 id="精确计算，避免使用float和double"><a href="#精确计算，避免使用float和double" class="headerlink" title="精确计算，避免使用float和double"></a>精确计算，避免使用float和double</h3><h3 id="当心字符串连接的性能"><a href="#当心字符串连接的性能" class="headerlink" title="当心字符串连接的性能"></a>当心字符串连接的性能</h3><blockquote>
<p>在存在大量字符串拼接或者大型字符串拼接的时候，尽量使用StringBuilder和StringBuffer</p>
</blockquote>
<h2 id="5、深入了解性能优化"><a href="#5、深入了解性能优化" class="headerlink" title="5、深入了解性能优化"></a>5、深入了解性能优化</h2><h3 id="常用的性能评价-x2F-测试指标"><a href="#常用的性能评价-x2F-测试指标" class="headerlink" title="常用的性能评价&#x2F;测试指标"></a>常用的性能评价&#x2F;测试指标</h3><ul>
<li><p>响应时间</p>
<ul>
<li>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。<br>常用操作的响应时间列表：<table>
  <tr>
      <td>操作</td>
      <td>响应时间</td>
  </tr>
   <tr>
      <td>打开一个站点</td>
      <td>几秒</td>
  </tr>
   <tr>
      <td>数据库查询一条记录(有索引)</td>
      <td>十几毫秒</td>
  </tr>
   <tr>
      <td>机械磁盘一次寻址定位</td>
      <td>4毫秒</td>
  </tr>     
   <tr>
      <td>从机械磁盘顺序读取1M数据
      </td>
      <td>2毫秒</td>
  </tr>     
   <tr>
      <td>从SSD磁盘顺序读取1M数据</td>
      <td>0.3毫秒</td>
  </tr>     
  <tr>
      <td>从远程分布式换成Redis读取一个数据</td>
      <td>0.5毫秒</td>
  </tr>     
  <tr>
      <td>从内存读取1M数据</td>
      <td>十几微妙</td>
  </tr>     
  <tr>
      <td>Java程序本地方法调用</td>
      <td>几微妙</td>
  </tr>     
  <tr>
      <td>网络传输2Kb数据</td>
      <td>1微妙</td>
  </tr></li>
</ul>
</table>
</li>
<li><p>并发数</p>
<blockquote>
<p>同一时刻，对服务器有实际交互的请求数。<br>和网站在线用户数的关联：1000个同时在线用户数，可以估计并发数在5%到15%之间，也就是同时并发数在50~150之间。</p>
</blockquote>
</li>
<li><p>吞吐量</p>
<blockquote>
<p>对单位时间内完成的工作量(请求)的量度</p>
</blockquote>
</li>
<li><p>相互之间的关系</p>
<ul>
<li>系统吞吐量和系统并发数以及响应时间的关系：<blockquote>
<p>理解为高速公路的通行状况：<br>吞吐量是每天通过收费站的车辆数目(可以换算成收费站收取的高速费)，<br>并发数是高速公路上的正在行驶的车辆数目，<br>响应时间是车速。<br>车辆很少时，车速很快。但是收到的高速费也相应较少；随着高速公路上车辆数目的增多，车速略受影响，但是收到的高速费增加很快；<br>随着车辆的继续增加，车速变得越来越慢，高速公路越来越堵，收费不增反降；<br>如果车流量继续增加，超过某个极限后，任务偶然因素都会导致高速全部瘫痪，车走不动，当然后也收不着，而高速公路成了停车场(资源耗尽)。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="常用的性能优化手段"><a href="#常用的性能优化手段" class="headerlink" title="常用的性能优化手段"></a>常用的性能优化手段</h3><ul>
<li><p>总原则</p>
<ul>
<li><p>避免过早优化</p>
<blockquote>
<p>不应该把大量的时间耗费在小的性能改进上，过早考虑优化是所有噩梦的根源。<br>所以，我们应该编写清晰，直接，易读和易理解的代码，真正的优化应该留到以后，等到性能分析表明优化措施有巨大的收益时再进行。<br>但是过早优化，不表示我们应该编写已经知道的对性能不好的的代码结构。</p>
</blockquote>
</li>
<li><p>进行系统性能测试</p>
<blockquote>
<p>所有的性能调优，都有应该建立在性能测试的基础上，直觉很重要，但是要用数据说话，可以推测，但是要通过测试求证。</p>
</blockquote>
</li>
<li><p>寻找系统瓶颈，分而治之，逐步优化 </p>
<blockquote>
<p>性能测试后，对整个请求经历的各个环节进行分析，排查出现性能瓶颈的地方，定位问题，分析影响性能的的主要因素是什么？内存、磁盘IO、网络、CPU，还是代码问题？架构设计不足？或者确实是系统资源不足？</p>
</blockquote>
</li>
</ul>
</li>
<li><p>前端优化手段</p>
</li>
</ul>
<h3 id="浏览器-x2F-App"><a href="#浏览器-x2F-App" class="headerlink" title="浏览器&#x2F;App"></a>浏览器&#x2F;App</h3><ul>
<li><p>减少请求数；</p>
<blockquote>
<p>合并CSS，Js，图片</p>
</blockquote>
</li>
<li><p>使用客户端缓冲；</p>
<blockquote>
<p>静态资源文件缓存在浏览器中，有关的属性Cache-Control和Expires<br>  如果文件发生了变化，需要更新，则通过改变文件名来解决。</p>
</blockquote>
</li>
<li><p>启用压缩</p>
<blockquote>
<p>减少网络传输量，但会给浏览器和服务器带来性能的压力，需要权衡使用。</p>
</blockquote>
</li>
<li><p>资源文件加载顺序</p>
<blockquote>
<p>css放在页面最上面，js放在最下面</p>
</blockquote>
</li>
<li><p>减少Cookie传输</p>
<blockquote>
<p>cookie包含在每次的请求和响应中，因此哪些数据写入cookie需要慎重考虑</p>
</blockquote>
</li>
<li><p>给用户一个提示</p>
<blockquote>
<p>有时候在前端给用户一个提示，就能收到良好的效果。毕竟用户需要的是不要不理他。</p>
</blockquote>
</li>
</ul>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><blockquote>
<p>CDN，又称内容分发网络，本质仍然是一个缓存，而且是将数据缓存在用户最近的地方。无法自行实现CDN的时候，可以考虑商用CDN服务。</p>
</blockquote>
<h3 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h3><blockquote>
<p>将静态资源文件缓存在反向代理服务器上，一般是Nginx。</p>
</blockquote>
<h3 id="WEB组件分离"><a href="#WEB组件分离" class="headerlink" title="WEB组件分离"></a>WEB组件分离</h3><blockquote>
<p>将js，css和图片文件放在不同的域名下。可以提高浏览器在下载web组件的并发数。因为浏览器在下载同一个域名的的数据存在并发数限制。</p>
</blockquote>
<ul>
<li><p>应用服务性能优化</p>
</li>
<li><p>存储性能优化</p>
<ul>
<li><p>选择合适的数据结构</p>
<blockquote>
<p>选择ArrayList和LinkedList对我们的程序性能影响很大，为什么？因为ArrayList内部是数组实现，存在着不停的扩容和数据复制。</p>
</blockquote>
</li>
<li><p>选择更优的算法</p>
<blockquote>
<p>举个例子，最大子列和问题：<br>给定一个整数序列，a0, a1, a2, …… , an(项可以为负数)，求其中最大的子序列和。<br>如果所有整数都是负数，那么最大子序列和为0；<br>例如(a[1],a[2],a[3],a[4],a[5],a[6])&#x3D;(-2,11,-4,13,-5,-2)时，<br>最大子段和为20，子段为a[2],a[3],a[4]。<br>最坏的算法：穷举法，所需要的的计算时间是O(n^3).<br>一般的算法：分治法的计算时间复杂度为O(nlogn).<br>最好的算法：最大子段和的动态规划算法，计算时间复杂度为O(n)<br>n越大，时间就相差越大，比如10000个元素，最坏的算法和最好的算法之间的差距绝非多线程或者集群化能轻松解决的。</p>
</blockquote>
</li>
<li><p>编写更少的代码</p>
<blockquote>
<p>同样正确的程序，小程序比大程序要快，这点无关乎编程语言。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="详细了解应用服务性能优化"><a href="#详细了解应用服务性能优化" class="headerlink" title="详细了解应用服务性能优化"></a>详细了解应用服务性能优化</h3><ul>
<li><p>缓存</p>
<ul>
<li><p>缓存的基本原理和本质</p>
<blockquote>
<p>缓存是将数据存在访问速度较高的介质中。可以减少数据访问的时间，同时避免重复计算。</p>
</blockquote>
</li>
<li><p>合理使用缓冲的准则</p>
<blockquote>
<p>频繁修改的数据，尽量不要缓存，读写比2:1以上才有缓存的价值。<br>缓存一定是热点数据。<br>应用需要容忍一定时间的数据不一致。<br>缓存可用性问题，一般通过热备或者集群来解决。<br>缓存预热，新启动的缓存系统没有任何数据，可以考虑将一些热点数据提前加载到缓存系统。<br>解决缓存击穿：<br>1、布隆过滤器，或者2、把不存在的数据也缓存起来 ，比如有请求总是访问key &#x3D; 23的数据，但是这个key &#x3D; 23的数据在系统中不存在，可以考虑在缓存中构建一个( key&#x3D;23 value &#x3D; null)的数据。</p>
</blockquote>
</li>
<li><p>分布式缓存与一致性哈希</p>
<ul>
<li>以集群的方式提供缓存服务，有两种实现；<blockquote>
<ol>
<li>需要更新同步的分布式缓存，所有的服务器保存相同的缓存数据，带来的问题就是，缓存的数据量受限制，其次，数据要在所有的机器上同步，代价很大。</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>每台机器只缓存一部分数据，然后通过一定的算法选择缓存服务器。常见的余数hash算法存在当有服务器上下线的时候，大量缓存数据重建的问题。所以提出了一致性哈希算法。</li>
</ol>
<ul>
<li>一致性哈希<blockquote>
<ol>
<li>首先求出服务器(节点)的哈希值，并将其配置到0～232的圆(continuum)上。</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上。<br>一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。<br>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题，此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器ip或主机名的后面增加编号来实现。例如，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</li>
</ol>
</li>
</ul>
</li>
<li><p>集群</p>
</li>
<li><p>异步</p>
<ul>
<li><p>同步和异步，阻塞和非阻塞</p>
<h3 id="同步和异步关注的是结果消息的通信机制"><a href="#同步和异步关注的是结果消息的通信机制" class="headerlink" title="同步和异步关注的是结果消息的通信机制"></a>同步和异步关注的是结果消息的通信机制</h3><blockquote>
<ul>
<li>同步<blockquote>
<p>同步的意思就是调用方需要主动等待结果的返回</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>异步<blockquote>
<p>异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="阻塞和非阻塞主要关注的是等待结果返回调用方的状态"><a href="#阻塞和非阻塞主要关注的是等待结果返回调用方的状态" class="headerlink" title="阻塞和非阻塞主要关注的是等待结果返回调用方的状态"></a>阻塞和非阻塞主要关注的是等待结果返回调用方的状态</h3><blockquote>
<ul>
<li>阻塞<blockquote>
<p>是指结果返回之前，当前线程被挂起，不做任何事</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>非阻塞<blockquote>
<p>是指结果在返回之前，线程可以做一些其他事，不会被挂起。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>同步阻塞<blockquote>
<p>同步阻塞基本也是编程中最常见的模型，打个比方你去商店买衣服，你去了之后发现衣服卖完了，那你就在店里面一直等，期间不做任何事(包括看手机)，等着商家进货，直到有货为止，这个效率很低。jdk里的BIO就属于 同步阻塞</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>同步非阻塞<blockquote>
<p>同步非阻塞在编程中可以抽象为一个轮询模式，你去了商店之后，发现衣服卖完了，这个时候不需要傻傻的等着，你可以去其他地方比如奶茶店，买杯水，但是你还是需要时不时的去商店问老板新衣服到了吗。jdk里的NIO就属于 同步非阻塞</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>异步阻塞<blockquote>
<p>异步阻塞这个编程里面用的较少，有点类似你写了个线程池,submit然后马上future.get()，这样线程其实还是挂起的。有点像你去商店买衣服，这个时候发现衣服没有了，这个时候你就给老板留给电话，说衣服到了就给我打电话，然后你就守着这个电话，一直等着他响什么事也不做。这样感觉的确有点傻，所以这个模式用得比较少。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>异步非阻塞<blockquote>
<p>好比你去商店买衣服，衣服没了，你只需要给老板说这是我的电话，衣服到了就打。然后你就随心所欲的去玩，也不用操心衣服什么时候到，衣服一到，电话一响就可以去买衣服了。jdk里的AIO就属于异步</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>常见异步的手段</p>
<ul>
<li><p>Servlet异步</p>
<blockquote>
<p>servlet3中才有，支持的web容器在tomcat7和jetty8以后。</p>
</blockquote>
</li>
<li><p>多线程</p>
</li>
<li><p>消息队列</p>
</li>
<li><p>集群</p>
<blockquote>
<p>可以很好的将用户的请求分配到多个机器处理，对总体性能有很大的提升</p>
</blockquote>
</li>
<li><p>程序代码级别</p>
<blockquote>
<p>一个应用的性能归根结底取决于代码是如何编写的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>应用相关</p>
<ul>
<li><p>代码级别</p>
<h3 id="一个应用的性能归根结底取决于代码是如何编写的。"><a href="#一个应用的性能归根结底取决于代码是如何编写的。" class="headerlink" title="一个应用的性能归根结底取决于代码是如何编写的。"></a>一个应用的性能归根结底取决于代码是如何编写的。</h3><blockquote>
<ul>
<li>选择合适的数据结构<blockquote>
<p>选择ArrayList和LinkedList对我们的程序性能影响很大，为什么？因为ArrayList内部是数组实现，存在着不停的扩容和数据复制。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>选择更优的算法<blockquote>
<p>举个例子，最大子列和问题：<br>给定一个整数序列，a0, a1, a2, …… , an(项可以为负数)，求其中最大的子序列和。<br>如果所有整数都是负数，那么最大子序列和为0；<br>例如(a[1],a[2],a[3],a[4],a[5],a[6])&#x3D;(-2,11,-4,13,-5,-2)时，<br>最大子段和为20，子段为a[2],a[3],a[4]。<br>最坏的算法：穷举法，所需要的的计算时间是O(n^3).<br>一般的算法：分治法的计算时间复杂度为O(nlogn).<br>最好的算法：最大子段和的动态规划算法，计算时间复杂度为O(n)<br>n越大，时间就相差越大，比如10000个元素，最坏的算法和最好的算法之间的差距绝非多线程或者集群化能轻松解决的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>编写更少的代码<blockquote>
<p>同样正确的程序，小程序比大程序要快，这点无关乎编程语言。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>并发编程</p>
<blockquote>
<ol>
<li>充分利用CPU多核，</li>
<li>实现线程安全的类，避免线程安全问题</li>
<li>同步下减少锁的竞争</li>
</ol>
</blockquote>
</li>
<li><p>资源的复用</p>
<blockquote>
<p>目的是减少开销很大的系统资源的创建和销毁，比如数据库连接，网络通信连接，线程资源等等。</p>
</blockquote>
</li>
<li><p>JVM</p>
<ul>
<li><p>与JIT编译器相关的优化</p>
<ul>
<li><p>热点编译的概念</p>
<blockquote>
<p>对于程序来说，通常只有一部分代码被经常执行，这些关键代码被称为应用的热点，执行的越多就认为是越热。将这些代码编译为本地机器特定的二进制码，可以有效提高应用性能。</p>
</blockquote>
</li>
<li><p>选择编译器类型</p>
<blockquote>
<p>-server，更晚编译，但是编译后的优化更多，性能更高<br>-client，很早就开始编译</p>
</blockquote>
</li>
<li><p>代码缓存相关</p>
<blockquote>
<p> 在编译后，会有一个代码缓存保存编译后的代码，一旦这个缓存满了，jvm将无法继续编译代码。<br>当jvm提示：  CodeCache is full，就表示需要增加代码缓存大小。<br>–XX:ReservedCodeCacheSize&#x3D;N可以用来调整这个大小。</p>
</blockquote>
</li>
<li><p>编译阈值</p>
<blockquote>
<p>代码是否进行编译，取决于代码执行的频度，是否到达编译阈值。<br>计数器有两种：方法调用计数器和方法里的循环回边计数器<br>一个方法是否达到编译阈值取决于方法中的两种计数器之和。编译阈值调整的参数为：-XX:CompileThreshold&#x3D;N<br>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(Counter Decay)，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)。进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外，可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。<br>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。</p>
</blockquote>
</li>
<li><p>编译线程</p>
<blockquote>
<p>进行代码编译的时候，是采用多线程进行编译的。</p>
</blockquote>
</li>
<li><p>方法内联</p>
<blockquote>
<p>内联默认开启，-XX:-Inline，可以关闭，但是不要关闭，一旦关闭对性能有巨大影响。<br>方法是否内联取决于方法有多热和方法的大小，<br>很热的方法如果方法字节码小于325字节才会内联，这个大小由参数 -XX:MaxFreqInlinesSzie&#x3D;N 调整，但是这个很热与热点编译不同，没有任何参数可以调整热度。<br>方法小于35个字节码，一定会内联，这个大小可以通过参数-XX:MaxInlinesSzie&#x3D;N 调整。</p>
</blockquote>
</li>
<li><p>逃逸分析</p>
<blockquote>
<p>是JVM所做的最激进的优化，最好不要调整相关的参数。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>GC调优</p>
<ul>
<li><p>目的</p>
<blockquote>
<p>GC的时间够小<br>GC的次数够少<br>发生Full GC的周期足够的长，时间合理，最好是不发生。</p>
</blockquote>
</li>
<li><p>调优的原则和步骤</p>
<blockquote>
<ol>
<li>大多数的java应用不需要GC调优</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>大部分需要GC调优的的，不是参数问题，是代码问题</li>
<li>在实际使用中，分析GC情况优化代码比优化GC参数要多得多；</li>
<li>GC调优是最后的手段<br>GC调优的最重要的三个选项：<br>第一位：选择合适的GC回收器<br>第二位：选择合适的堆大小<br>第三位：选择年轻代在堆中的比重</li>
</ol>
<p>###步骤<br>1.监控GC的状态</p>
<blockquote>
<p>使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；</p>
</blockquote>
<p>2.分析结果，判断是否需要优化</p>
<blockquote>
<p>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；<br>注：如果满足下面的指标，则一般不需要进行GC：<br>   Minor GC执行时间不到50ms；<br>   Minor GC执行不频繁，约10秒一次；<br>   Full GC执行时间不到1s；<br>   Full GC执行频率不算频繁，不低于10分钟1次；</p>
</blockquote>
<p>3.调整GC类型和内存分配</p>
<blockquote>
<p>如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；</p>
</blockquote>
<p>4.不断的分析和调整</p>
<blockquote>
<p>通过不断的试验和试错，分析并找到最合适的参数</p>
</blockquote>
<p>5.全面应用参数</p>
<blockquote>
<p>如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。</p>
</blockquote>
</li>
<li><p>JVM调优实战</p>
<p>###推荐策略</p>
<ul>
<li>年轻代大小选择<blockquote>
<ol>
<li>响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象.</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>吞吐量优先的应用:尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.</li>
<li>避免设置过小.当新生代设置过小时会导致:1.YGC次数更加频繁 2.可能导致YGC对象直接进入旧生代,如果此时旧生代满了,会触发FGC.</li>
</ol>
<ul>
<li>年老代大小选择<blockquote>
<ol>
<li>响应时间优先的应用:年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得:</li>
</ol>
</blockquote>
</li>
</ul>
<ol start="2">
<li>并发垃圾收集信息、持久代并发收集次数、传统GC信息、花在年轻代和年老代回收上的时间比例。</li>
<li>吞吐量优先的应用一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象</li>
</ol>
</li>
</ul>
</li>
<li><p>存储性能优化</p>
<blockquote>
<ol>
<li>尽量使用SSD</li>
<li>定时清理数据或者按数据的性质分开存放</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><em>XMind - Trial Version</em></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JVM和性能优化</p><p><a href="https://liruilongs.github.io/2020/07/03/Java/JVM和性能优化/">https://liruilongs.github.io/2020/07/03/Java/JVM和性能优化/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2023/06/17/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/AdaFace%EF%BC%9A-%E9%80%9A%E8%BF%87AdaFace%E5%AE%9E%E7%8E%B0%E4%BD%8E%E8%B4%A8%E9%87%8F%E9%9D%A2%E9%83%A8%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%B2%BE%E5%87%86%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" target="_blank">AdaFace(CVPR(2022))：通过AdaFace实现低质量面部数据集的人脸识别</a><br></span><span>  3.<a class="is-size-6" href="/2023/05/04/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/DeepFace%EF%BC%9A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%93%20DeepFace%20%E7%AE%80%E5%8D%95%E8%AE%A4%E7%9F%A5/" target="_blank">DeepFace：人脸识别库 DeepFace 简单认知</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/24/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E4%BD%BF%E7%94%A8-OpenCV-%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A%E5%BA%A6%E6%A3%80%E6%B5%8B-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E5%B7%AE%E6%96%B9%E6%B3%95/" target="_blank">使用 OpenCV 进行图像模糊度检测(拉普拉斯方差方法)</a><br></span><span>  5.<a class="is-size-6" href="/2023/06/15/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Nvidia%203060%20%E6%98%BE%E5%8D%A1%20CUDA%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(Ubuntu22.04+Nvidia%20510+Cuda11.6+cudnn8.8)/" target="_blank">Nvidia 3060 显卡 CUDA 环境搭建(Ubuntu22.04+Nvidia 510+Cuda11.6+cudnn8.8)</a><br></span><span>  6.<a class="is-size-6" href="/2023/05/17/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E5%85%B3%E4%BA%8EOpenCv%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%8C%85-imutils-%E7%AE%80%E5%8D%95%E8%AE%A4%E7%9F%A5/" target="_blank">关于 OpenCV 图像处理工具包 imutils 简单认知</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/30/Java/Java%E4%B8%ADtry%7B%7Dcatch%E7%9A%84%E9%9A%90%E8%97%8F(%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%9D%97)/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java中try{}catch的隐藏(如何优雅的实现异常块)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/11/22/Java/%E3%80%8A%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81(%E6%94%B9%E5%96%84Java%E7%A8%8B%E5%BA%8F%E7%9A%84151%E4%B8%AA%E5%BB%BA%E8%AE%AE)%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-item">《编写高质量代码(改善Java程序的151个建议)》读书笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '2bd396554c826440a9f57c719243f17c',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">320</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">102</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">153</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-18T20:39:30.000Z">2023-12-19</time></p><p class="title"><a href="/2023/12/19/%E5%BE%85%E5%8F%91%E5%B8%83/Stable-Diffusion-Windows%E9%83%A8%E7%BD%B2%E7%AE%80%E7%AD%94%E8%AE%A4%E7%9F%A5/">Stable Diffusion 简单认知 Windows 部署</a></p><p class="categories"><a href="/categories/test3/">test3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-19T19:40:00.000Z">2023-11-20</time></p><p class="title"><a href="/2023/11/20/%E5%BE%85%E5%8F%91%E5%B8%83/Golang%20VScode%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Golang VScode 开发环境搭建</a></p><p class="categories"><a href="/categories/GO/">GO</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-15T12:44:37.000Z">2023-11-15</time></p><p class="title"><a href="/2023/11/15/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%9F%BA%E4%BA%8E%20selenium%20%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E9%87%87%E9%9B%86/">基于 selenium 实现网站图片采集</a></p><p class="categories"><a href="/categories/selenium/">selenium</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-13T20:29:38.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%85%B3%E4%BA%8E-Kubernetes%E4%B8%ADAdmission-Controllers-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/">关于 Kubernetes中Admission Controllers(准入控制器) 认知的一些笔记</a></p><p class="categories"><a href="/categories/Kubernetes/">Kubernetes</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-13T19:52:18.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/%E5%BE%85%E5%8F%91%E5%B8%83/K8s%20Pod%20%E5%88%9B%E5%BB%BA%E5%9F%8B%E7%82%B9%E5%A4%84%E7%90%86(Mutating%20%20Admission%20Webhook)/">K8s Pod 创建埋点处理(Mutating  Admission Webhook)</a></p><p class="categories"><a href="/categories/test3/">test3</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DAD-3DHeads/"><span class="level-start"><span class="level-item">DAD-3DHeads</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DNS/"><span class="level-start"><span class="level-item">DNS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">91</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">34</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%B9%E5%99%A8/"><span class="tag">容器</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CKA/"><span class="tag">CKA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO/"><span class="tag">GO</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ISCSI/"><span class="tag">ISCSI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NFS/"><span class="tag">NFS</span><span class="tag is-grey-lightest">3</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2024 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案号</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>