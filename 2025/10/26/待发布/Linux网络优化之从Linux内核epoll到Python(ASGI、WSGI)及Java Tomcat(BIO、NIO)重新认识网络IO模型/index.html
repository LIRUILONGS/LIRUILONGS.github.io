<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="google-adsense-account" content="ca-pub-5805170532312625"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>：Linux网络优化之从Linux内核epoll/io_uring 到Python(ASGI/WSGI)及Java Tomcat(BIO/NIO)网络IO模型认知 - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。所有其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧 ——赫尔曼·黑塞《德米安》"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。所有其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧 ——赫尔曼·黑塞《德米安》"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mp.weixin.qq.com/img/头像.jpg"><meta property="article:published_time" content="2025-10-25T20:27:41.000Z"><meta property="article:modified_time" content="2025-11-21T12:19:28.125Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="Linux"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2025/10/26/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%8ELinux%E5%86%85%E6%A0%B8epoll%E5%88%B0Python(ASGI%E3%80%81WSGI)%E5%8F%8AJava%20Tomcat(BIO%E3%80%81NIO)%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"},"headline":"山河已无恙","image":["https://liruilongs.github.io/img/og_image.png"],"datePublished":"2025-10-25T20:27:41.000Z","dateModified":"2025-11-21T12:19:28.125Z","author":{"@type":"Person","name":"山河已无恙"},"description":"对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。所有其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧 ——赫尔曼·黑塞《德米安》"}</script><link rel="canonical" href="https://liruilongs.github.io/2025/10/26/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%8ELinux%E5%86%85%E6%A0%B8epoll%E5%88%B0Python(ASGI%E3%80%81WSGI)%E5%8F%8AJava%20Tomcat(BIO%E3%80%81NIO)%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2025-10-26  <a class="commentCountImg" href="/2025/10/26/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%8ELinux%E5%86%85%E6%A0%B8epoll%E5%88%B0Python(ASGI%E3%80%81WSGI)%E5%8F%8AJava%20Tomcat(BIO%E3%80%81NIO)%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/#comment-container"><span class="display-none-class">701fe6e8181938abac7bc50a2fa8cc46</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="701fe6e8181938abac7bc50a2fa8cc46">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>15.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">：Linux网络优化之从Linux内核epoll/io_uring 到Python(ASGI/WSGI)及Java Tomcat(BIO/NIO)网络IO模型认知</h1><div class="content"><p><strong><font color="009688"> 对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。所有其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧 ——赫尔曼·黑塞《德米安》</strong></font></p>
<span id="more"></span>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><hr>
<ul>
<li>一直想简单整理一下这部分内容，但是因为知识的广度不够，同时时间关系一直没整理，开发的项目大部分是后端系统</li>
<li>从最开始刚入行的疑问，对于 <code>Java</code> 来说 <code>Tomcat</code> 是什么？有了 <code>Web</code> 框架为什么还需要 <code>Tomcat</code>？</li>
<li>在到后来做一些 <code>AI</code> 项目，思考 <code>Python Web</code> 规范 <code>ASGI/WSGI</code> 那个适合 <code>IO/CPU</code> 密集型</li>
<li>以及后来研究 <code>Linux</code>，传输层的数据包在内核态和用户态如何流转的，为何修改一些缓存区的阈值会影响性能。</li>
<li>这些问题一直模糊不清，今天和小伙伴围绕这些问题聊聊网络IO模型，浅尝辄止，没有深入太多</li>
<li>本篇博客是Linux 网络性能调优系列之一，理解不足小伙伴帮忙指正</li>
</ul>
<p><strong><font color="009688"> 对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。所有其它的路都是不完整的，是人的逃避方式，是对大众理想的懦弱回归，是随波逐流，是对内心的恐惧 ——赫尔曼·黑塞《德米安》</strong></font></p>
<hr>
<p>技术的接触往往是先学会如何用，然后才慢慢了解起原理，但是为了由浅及深的讲解，本文反过来，先介绍基本原理从 <code>Linux内核</code> 出发，解析<code>阻塞IO</code>与<code>epoll</code>、<code>io_uring</code>的本质，再延伸至<code>高级语言框架</code>的<code>IO模型设计</code>，所以对于前面讲到的问题，最少有个大概认知才适合阅读本文。</p>
<p><code>网络IO模型</code> 是所有后端服务的基础，它决定了程序如何<code>处理网络请求</code>、<code>利用系统资源</code>以及<code>支撑并发</code>的能力。从<code>Linux内核</code>的底层实现到<code>Python的WSGI/ASGI</code>规范，再到<code>Java Tomcat</code>的线程模型，每一层抽象都蕴含着对<code>IO效率</code>的极致追求。</p>
<h2 id="一、为什么网络IO模型如此重要？"><a href="#一、为什么网络IO模型如此重要？" class="headerlink" title="一、为什么网络IO模型如此重要？"></a>一、为什么网络IO模型如此重要？</h2><p>在后端开发中，我们不用<code>深入网络 IO 模型</code>也能写出可运行的代码，核心是 Web 服务器( Tomcat、Nginx、Uvicorn等)已经封装了底层网络IO 逻辑，帮我们处理了 “如何高效监听连接、接收数据、调度进程” 这些复杂问题，让开发者直接使用Web框架聚焦业务逻辑。</p>
<p>但是我们可能会面临这样的问题：</p>
<ul>
<li>为什么同样的硬件配置，有些服务能轻松支撑10万并发，而有些却在几千连接下就崩溃？</li>
<li>为什么同样的代码，同样的web框架，使用了不同的Web服务器，高并发下，有些会阻赛一个请求处理中无法处理下一个，有些会都吞下去把自己撑死。</li>
</ul>
<p>答案的核心在于<strong>网络IO模型</strong>——它决定了程序如何与操作系统协作处理网络数据，直接影响<code>CPU利用率</code>、<code>内存消耗</code>和<code>响应延迟</code>的请求的吞吐量。</p>
<p>以一个简单的Web请求为例，从用户发起起到到服务端返回响应，数据需要经历：</p>
<ul>
<li>网卡接收数据（硬件中断+软中断）</li>
<li>内核协议栈处理（TCP&#x2F;IP解析）</li>
<li>用户态程序读取数据（数据拷贝+系统调用）</li>
<li>业务逻辑处理（如数据库查询）</li>
<li>数据返回（用户态→内核态→网卡）</li>
</ul>
<p>每一个环节的效率都与IO模型密切相关。低效的模型会让<code>CPU在进程上下文切换、等待IO</code>中浪费大量时间；而高效的模型能让<code>CPU专注于业务处理，最大化资源利用率</code>。我们先从最基础的内核网络IO开始，这是一切的基石</p>
<h2 id="二、Linux内核IO模型：阻塞与多路复用、异步IO的底层逻辑"><a href="#二、Linux内核IO模型：阻塞与多路复用、异步IO的底层逻辑" class="headerlink" title="二、Linux内核IO模型：阻塞与多路复用、异步IO的底层逻辑"></a>二、Linux内核IO模型：阻塞与多路复用、异步IO的底层逻辑</h2><p>所有高级语言的IO操作最终都依赖操作系统内核实现，理解 Linux 内核的IO机制，是掌握高级框架设计原理的基础。</p>
<p>在具体的了解之前，需要对一些名词有基本的认知：</p>
<p><code>网络IO阻塞</code>:进程因为等待某个事件而主动让出CPU挂起的操作。在网络IO中，当进程等待 socket 上的数据时，如果数据还没有到来，那就把当前进程状态从<code>TASKRUNNKNG</code>修改为<code>TASKINTERRUPTIPLE</code>，然后<code>主动让出CPU</code>。由调度器来调度下一个就绪状态的进程来执行。</p>
<p><code>Web 服务器</code>: 专门处理 HTTP 请求的软件，负责网络通信层面的工作，监听网络端口（80&#x2F;443）接收和解析 HTTP 请求等, 比如 Tomcat、Jetty、WebLogic、Gunicorn、Uvicorn 等，<code>epoll 特性主要在 Web 服务器 层面被使用</code></p>
<p><code>Web 框架</code>:  为 Web 应用开发提供结构和工具的软件库,路由管理（URL 映射） ,请求处理，数据库交互，会话管理等，比如  Spring Boot、 Spring MVC 、Quarkus 、Tornado、FastAPI、Django、Flask 等</p>
<h3 id="socket在内核中的数据结构"><a href="#socket在内核中的数据结构" class="headerlink" title="socket在内核中的数据结构"></a>socket在内核中的数据结构</h3><p>在用户态，我们通过 <code>socket()</code> 函数创建的是一个整数句柄，但内核中实际构建了一套复杂的对象体系。这些结构的设计直接影响了后续IO操作的效率。</p>
<p><strong>核心数据结构关系</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的socket内核结构关系</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>       <span class="comment">// 关联的文件对象（内核用文件系统统一管理资源）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span>         <span class="comment">// 核心套接字对象（包含协议相关状态）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span>   <span class="comment">// 协议操作集（如TCP的连接、读写方法）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">sk_prot</span>;</span>   <span class="comment">// 协议处理函数（如TCP的发送/接收逻辑）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">sk_receive_queue</span>;</span>  <span class="comment">// 接收队列（存储待处理的数据包）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">sk_wq</span>;</span> <span class="comment">// 等待队列（阻塞时进程挂起的地方）</span></span><br><span class="line">    <span class="keyword">void</span> (*sk_data_ready)(struct sock *sk， <span class="keyword">int</span> len); <span class="comment">// 数据就绪回调函数</span></span><br><span class="line">    <span class="comment">// 其他字段：状态（如ESTABLISHED）、窗口大小、超时时间等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体描述：</p>
<ul>
<li><code>struct socket</code>：用户态与内核态交互的桥梁，关联文件对象和核心套接字</li>
<li><code>struct sock</code>：包含TCP&#x2F;UDP等协议的核心状态，是IO操作的实际载体</li>
<li><code>proto_ops</code>与<code>proto</code>：封装了协议相关的操作方法（多态设计，支持不同协议）</li>
</ul>
<p><strong>socket 创建的源码流程</strong></p>
<p>下面是一个py 写的TCP 客户端，AF_INET：表示 ipv4，SOCK_STREAM: tcp传输协议</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> socket <span class="keyword">import</span> socket， AF_INET， SOCK_STREAM</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = socket(AF_INET， SOCK_STREAM)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.connect((<span class="string">&#x27;localhost&#x27;</span>， <span class="number">20000</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.send(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.recv(<span class="number">8192</span>)</span><br><span class="line"><span class="string">b&#x27;Hello&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>当调用<code>socket(AF_INET， SOCK_STREAM， 0)</code>时，内核执行以下步骤：</p>
<ol>
<li><strong>系统调用入口</strong>：<code>SYSCALL_DEFINE3(socket， ...)</code>（<code>net/socket.c</code>）</li>
<li><strong>创建socket对象</strong>：<code>sock_create()</code> → <code>__sock_create()</code><ul>
<li>调用<code>sock_alloc()</code>分配<code>struct socket</code></li>
<li>根据协议族（如AF_INET）获取<code>net_proto_family</code>（协议族操作集）</li>
</ul>
</li>
<li><strong>协议族初始化</strong>：调用<code>pf-&gt;create</code>（如AF_INET对应<code>inet_create</code>）<ul>
<li>根据<code>sock_type</code>（如SOCK_STREAM）查找<code>inetsw_array</code>中的TCP配置</li>
<li>绑定<code>socket-&gt;ops = &amp;inet_stream_ops</code>（TCP的操作方法）</li>
<li>分配<code>struct sock</code>并绑定<code>sk-&gt;sk_prot = &amp;tcp_prot</code>（TCP的协议处理函数）</li>
</ul>
</li>
<li><strong>初始化回调</strong>：<code>sock_init_data()</code>设置<code>sk-&gt;sk_data_ready = sock_def_readable</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inet_create关键代码（net/ipv4/af_inet.c）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历协议表，找到SOCK_STREAM对应的TCP配置</span></span><br><span class="line">    list_for_each_entry_rcu(answer， &amp;inetsw[sock-&gt;type]， <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">            sock-&gt;ops = answer-&gt;ops;  <span class="comment">// 绑定inet_stream_ops</span></span><br><span class="line">            answer_prot = answer-&gt;prot;  <span class="comment">// 绑定tcp_prot</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配并初始化sock对象</span></span><br><span class="line">    sk = sk_alloc(net， PF_INET， GFP_KERNEL， answer_prot);</span><br><span class="line">    sock_init_data(sock， sk);  <span class="comment">// 设置sk_data_ready等回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些初始化工作为后续的<code>connect</code>、<code>recv</code>等操作奠定了基础，尤其是<code>sk_data_ready</code>回调，将在数据到达时触发进程唤醒。</p>
<h3 id="同步阻塞IO：进程等待的低效模型"><a href="#同步阻塞IO：进程等待的低效模型" class="headerlink" title="同步阻塞IO：进程等待的低效模型"></a>同步阻塞IO：进程等待的低效模型</h3><p>同步阻塞IO（BIO）是最直观的IO模型：用户进程调用<code>recv</code>后，如果数据未到达，就进入阻塞状态，直到数据就绪才被唤醒。这种模型实现简单，但在高并发场景下性能极差。</p>
<p>下面是一个 python 写的BIO Demo</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> BaseRequestHandler， TCPServer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span>(<span class="params">BaseRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Got connection from&#x27;</span>， self.client_address)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment">#接收客户端发送的数据， 这次接收数据的最大字节数是8192</span></span><br><span class="line">            msg = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="comment"># 接收的到数据在发送回去</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.request.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 20000端口，默认IP为本地IP，监听到消息交个EchoHandler处理器</span></span><br><span class="line">    serv = TCPServer((<span class="string">&#x27;&#x27;</span>， <span class="number">20000</span>)， EchoHandler)</span><br><span class="line">    serv.serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>同步阻塞IO模型</code>也分为 <code>单线程和多线程阻塞IO模型</code>，上面的 <code>Demo</code> 是单线程，同一时间只能处理一个客户端连接，新连接会被放入监听队列等待，直到当前连接处理完成。处理连接时（handle 方法执行期间），服务器会阻塞在 recv 调用上（等待客户端发送数据），期间无法接受新连接。</p>
<h4 id="同步阻塞的核心流程"><a href="#同步阻塞的核心流程" class="headerlink" title="同步阻塞的核心流程"></a>同步阻塞的核心流程</h4><p>以<code>recvfrom</code>系统调用为例，其内核处理流程如下：</p>
<ol>
<li><strong>系统调用陷入内核态</strong>：<code>SYSCALL_DEFINE6(recvfrom， ...)</code>（<code>net/socket.c</code>）</li>
<li><strong>查找socket对象</strong>：通过文件描述符找到对应的<code>struct socket</code></li>
<li><strong>调用协议接收方法</strong>：<code>sock_recvmsg()</code> → <code>socket-&gt;ops-&gt;recvmsg</code>（即<code>inet_recvmsg</code>）<ul>
<li>最终调用<code>sk-&gt;sk_prot-&gt;recvmsg</code>（即<code>tcp_recvmsg</code>，<code>net/ipv4/tcp.c</code>）</li>
</ul>
</li>
<li><strong>检查接收队列</strong>：<ul>
<li>若<code>sk-&gt;sk_receive_queue</code>有数据，直接拷贝到用户态缓冲区</li>
<li>若无数据，调用<code>sk_wait_data()</code>进入阻塞</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_recvmsg</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> copied = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target = len;  <span class="comment">// len是用户传入的期望读取量（如8192）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历接收队列，拷贝所有可用数据（不超过target）</span></span><br><span class="line">        skb_queue_walk(&amp;sk-&gt;sk_receive_queue， skb) &#123;</span><br><span class="line">            <span class="keyword">int</span> chunk = min(skb-&gt;len， target - copied);  <span class="comment">// 本次拷贝的字节数（不超过剩余需求）</span></span><br><span class="line">            <span class="built_in">memcpy</span>(buf， skb-&gt;data， chunk);  <span class="comment">// 拷贝到用户态缓冲区</span></span><br><span class="line">            copied += chunk;</span><br><span class="line">            skb_pull(skb， chunk);  <span class="comment">// 从skb中移除已拷贝的数据</span></span><br><span class="line">            <span class="keyword">if</span> (copied &gt;= target) <span class="keyword">break</span>;  <span class="comment">// 达到期望量，退出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键判断：若已收到FIN包（发送方关闭），即使数据不足也退出</span></span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE_WAIT || sk-&gt;sk_state == TCP_CLOSED) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 无更多数据，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若未收到FIN，且数据不足，才阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> (copied &lt; target) &#123;</span><br><span class="line">            sk_wait_data(sk， &amp;timeo);  <span class="comment">// 阻塞等待新数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (copied &lt; target &amp;&amp; !timeo_expired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copied;  <span class="comment">// 返回实际拷贝的字节数（如100）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进程阻塞的底层实现</strong></p>
<p><code>sk_wait_data()</code>通过以下步骤将进程挂起：</p>
<ol>
<li><strong>定义等待队列项</strong>：<code>DEFINE_WAIT(wait)</code>创建一个关联当前进程的等待项<ul>
<li>等待项的<code>private</code>字段指向当前进程（<code>current</code>）</li>
<li>回调函数设为<code>autoremove_wake_function</code></li>
</ul>
</li>
<li><strong>加入等待队列</strong>：<code>prepare_to_wait(sk_sleep(sk),&amp;wait,TASK_INTERRUPTIBLE)</code><ul>
<li>将等待项加入<code>sock-&gt;sk_wq-&gt;wait</code>队列</li>
<li>进程状态从<code>TASK_RUNNING</code>改为<code>TASK_INTERRUPTIBLE</code>（可中断睡眠）</li>
</ul>
</li>
<li><strong>让出CPU</strong>：<code>schedule_timeout()</code>触发进程调度,当前进程进入睡眠</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sk_wait_data核心代码（net/core/sock.c）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sk_wait_data</span><span class="params">(struct sock *sk, <span class="keyword">long</span> *timeo)</span> </span>&#123;</span><br><span class="line">    DEFINE_WAIT(wait);  <span class="comment">// 初始化等待项,关联current</span></span><br><span class="line">    prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">    <span class="comment">// 检查是否有数据,若无则让出CPU</span></span><br><span class="line">    rc = sk_wait_event(sk, timeo, !skb_queue_empty(&amp;sk-&gt;sk_receive_queue));</span><br><span class="line">    finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，进程不再占用CPU，直到数据到达后被唤醒。</p>
<p><strong>数据到达后的唤醒流程</strong></p>
<p>当网卡收到数据并经内核处理后，数据会被放入<code>sock</code>的接收队列，随后触发唤醒：</p>
<ol>
<li><strong>软中断处理</strong>：网卡通过DMA将数据写入内存后触发硬中断，硬中断唤醒<code>ksoftirqd</code>内核线程处理软中断</li>
<li><strong>协议栈处理</strong>：<code>tcp_v4_rcv()</code>解析TCP包，找到对应的<code>sock</code>对象，调用<code>tcp_rcv_established()</code></li>
<li><strong>数据入队</strong>：<code>tcp_queue_rcv()</code>将数据包（<code>sk_buff</code>）加入<code>sk-&gt;sk_receive_queue</code></li>
<li><strong>触发回调</strong>：调用<code>sk-&gt;sk_data_ready(sk， 0)</code>（即<code>sock_def_readable</code> 初始化回调的时候绑定）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp_rcv_established中的唤醒逻辑（net/ipv4/tcp_input.c）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_established</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据入队</span></span><br><span class="line">    eaten = tcp_queue_rcv(sk， skb， ...);</span><br><span class="line">    <span class="comment">// 触发数据就绪回调</span></span><br><span class="line">    sk-&gt;sk_data_ready(sk， <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sock_def_readable</code>会遍历<code>sock</code>的等待队列，唤醒阻塞的进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sock_def_readable</span><span class="params">(struct sock *sk， <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> *<span class="title">wq</span> =</span> rcu_dereference(sk-&gt;sk_wq);</span><br><span class="line">    <span class="keyword">if</span> (wq_has_sleeper(wq)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒等待队列上的进程</span></span><br><span class="line">        wake_up_interruptible_sync_poll(&amp;wq-&gt;wait， POLL_IN | POLLPRI | ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wake_up_interruptible_sync_poll</code>最终调用<code>try_to_wake_up()</code>，将进程状态改回<code>TASK_RUNNING</code>，使其重新参与CPU调度。</p>
<h4 id="同步阻塞IO的性能瓶颈"><a href="#同步阻塞IO的性能瓶颈" class="headerlink" title="同步阻塞IO的性能瓶颈"></a>同步阻塞IO的性能瓶颈</h4><p>同步阻塞IO的低效源于三个核心问题：</p>
<ol>
<li><strong>进程上下文切换开销</strong>：阻塞时放弃CPU一次切换，唤醒时获取CPU又一次切换，每次切换耗时3-5μs</li>
<li><strong>资源浪费</strong>：一个连接占用一个进程（或线程），高并发下需要大量进程，每个进程占用1-8MB内存</li>
<li><strong>CPU利用率低</strong>：进程大部分时间在等待IO，而非处理业务逻辑</li>
</ol>
<p>不管是单线程还是多线程，在高并发场景（如10万连接）中，同步阻塞模型完全不可行——系统资源会被进程管理耗尽，或者请求完全陷入阻赛。</p>
<h3 id="多路复用IO：epoll的高效实现"><a href="#多路复用IO：epoll的高效实现" class="headerlink" title="多路复用IO：epoll的高效实现"></a>多路复用IO：epoll的高效实现</h3><p>epoll 是 Linux 为解决高并发IO设计的多路复用机制，它让一个进程能同时管理成千上万的连接，大幅降低了进程切换开销。</p>
<p>epoll 的核心流程主要分三部分：</p>
<ul>
<li><code>epoll_create</code> 初始化 <code>eventpoll</code> 对象（红黑树 + 就绪链表 + 等待队列），返回 epfd。</li>
<li><code>epoll_ctl</code> 通过红黑树维护监控关系，并注册回调，确保 fd 就绪时自动加入就绪链表。</li>
<li><code>epoll_wait</code> 高效获取就绪链表中的事件（O (1) 复杂度），无事件时阻塞等待，避免轮询开销。</li>
</ul>
<p>下面是一个 py 写的Demo</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建监听套接字</span></span><br><span class="line">server = socket.socket(socket.AF_INET， socket.SOCK_STREAM)</span><br><span class="line">server.setsockopt(socket.SOL_SOCKET， socket.SO_REUSEADDR， <span class="number">1</span>)</span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>， <span class="number">8888</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)  <span class="comment"># 设置非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 epoll 对象</span></span><br><span class="line">epoll = select.epoll()</span><br><span class="line">epoll.register(server.fileno()， select.EPOLLIN)  <span class="comment"># 监听服务器套接字的读事件</span></span><br><span class="line"></span><br><span class="line">connections = &#123;&#125;  <span class="comment"># 保存客户端连接 &#123;文件描述符: 套接字&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 等待事件发生 (阻塞，直到有事件)</span></span><br><span class="line">        events = epoll.poll()</span><br><span class="line">        <span class="keyword">for</span> fileno， event <span class="keyword">in</span> events:</span><br><span class="line">            <span class="comment"># 服务器套接字描述符有读事件 (新连接)</span></span><br><span class="line">            <span class="keyword">if</span> fileno == server.fileno():</span><br><span class="line">                client， addr = server.accept()</span><br><span class="line">                client.setblocking(<span class="literal">False</span>)</span><br><span class="line">                epoll.register(client.fileno()， select.EPOLLIN)  <span class="comment"># 注册客户端读事件</span></span><br><span class="line">                connections[client.fileno()] = client</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;新连接: <span class="subst">&#123;addr&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 客户端有读事件 (发来了数据)</span></span><br><span class="line">            <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">                client = connections[fileno]</span><br><span class="line">                data = client.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;收到 <span class="subst">&#123;client.getpeername()&#125;</span>: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line">                    client.send(<span class="string">f&quot;已收到: <span class="subst">&#123;data&#125;</span>&quot;</span>.encode())  <span class="comment"># 回传数据</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 客户端断开</span></span><br><span class="line">                    epoll.unregister(fileno)</span><br><span class="line">                    client.close()</span><br><span class="line">                    <span class="keyword">del</span> connections[fileno]</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;连接断开: <span class="subst">&#123;client.getpeername()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    epoll.unregister(server.fileno())</span><br><span class="line">    epoll.close()</span><br><span class="line">    server.close()</span><br></pre></td></tr></table></figure>

<p><strong>epoll的核心数据结构</strong></p>
<p>调用<code>epoll_create()</code>时，内核创建<code>struct eventpoll</code>对象，作为 <code>epoll</code> 的核心管理结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wq;       <span class="comment">// epoll_wait 的等待队列（进程阻塞在这里）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span>   <span class="comment">// 就绪事件链表（已准备好的socket）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span>         <span class="comment">// 红黑树（管理所有注册的socket）</span></span><br><span class="line">    <span class="comment">// 其他字段：唤醒掩码、用户态地址等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>wq</code>：当没有就绪事件时，调用<code>epoll_wait</code>的进程会阻塞在此队列</li>
<li><code>rdllist</code>：存储已就绪的事件，避免遍历整个红黑树</li>
<li><code>rbr</code>：通过红黑树高效管理注册的socket（支持O(logN)的插入&#x2F;删除&#x2F;查找）</li>
</ul>
<p>每个注册到 <code>epoll</code> 的 <code>socket</code> 对应一个 <code>struct epitem</code>（红黑树节点）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span>         <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span>    <span class="comment">// 关联的文件描述符（socket）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>       <span class="comment">// 所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span>   <span class="comment">// 就绪链表的节点（用于加入rdllist）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span>   <span class="comment">// 等待队列项链表（关联socket的等待队列）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="epoll-的核心流程"><a href="#epoll-的核心流程" class="headerlink" title="epoll 的核心流程"></a>epoll 的核心流程</h4><p>首先建立好的 <code>socket</code> 需要注册到 <code>epoll</code> 对象的红黑树里面</p>
<p><strong>epoll_ctl：注册socket的过程</strong></p>
<p><code>epoll_ctl(EPOLL_CTL_ADD)</code>用于将 socket 注册到 epoll，核心步骤如下：</p>
<ol>
<li><strong>创建epitem</strong>：为 socket 分配 <code>struct epitem</code>，初始化其关联的<code>eventpoll</code>和文件描述符</li>
<li><strong>设置回调</strong>：为 socket 的等待队列添加一个等待项，回调函数设为<code>ep_poll_callback</code></li>
<li><strong>插入红黑树</strong>：将epitem插入<code>eventpoll-&gt;rbr</code>，完成注册</li>
</ol>
<p>所有的注册过程都是在 <code>ep_insert</code> 核心函数完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ep_insert核心代码（fs/eventpoll.c）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_insert</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配epitem</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> kmem_cache_alloc(epi_cache, GFP_KERNEL);</span><br><span class="line">    epi-&gt;ep = ep;  <span class="comment">// 关联eventpoll</span></span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);  <span class="comment">// 关联socket的文件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket等待队列的回调</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);  <span class="comment">// 回调设为ep_ptable_queue_proc</span></span><br><span class="line">    revents = ep_item_poll(epi, &amp;epq.pt);  <span class="comment">// 触发回调注册</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入红黑树</span></span><br><span class="line">    ep_rbtree_insert(ep, epi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ep_ptable_queue_proc</code>会创建一个<code>struct eppoll_entry</code>（等待队列项），将其回调设为<code>ep_poll_callback</code>，并加入socket的等待队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span> =</span> kmem_cache_alloc(pwq_cache, GFP_KERNEL);</span><br><span class="line">    init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);  <span class="comment">// 回调设为ep_poll_callback</span></span><br><span class="line">    add_wait_queue(whead, &amp;pwq-&gt;wait);  <span class="comment">// 加入socket的等待队列</span></span><br><span class="line">    list_add(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);  <span class="comment">// 关联epitem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，socket 的等待队列中不仅有<code>ep_poll_callback</code>，还可能有其他等待项（如阻塞IO的进程），但 <code>epoll</code> 通过回调机制实现了高效的事件通知。</p>
<p><strong>epoll_wait：等待就绪事件</strong></p>
<p><code>epoll_wait</code>的逻辑是检查就绪链表，若无就绪事件则阻塞：</p>
<ol>
<li><strong>检查就绪事件</strong>：<code>ep_events_available(ep)</code>判断<code>rdllist</code>是否为空<ul>
<li>若不为空，直接收集事件并返回给用户态</li>
<li>若为空，将进程加入<code>eventpoll-&gt;wq</code>并阻塞</li>
</ul>
</li>
</ol>
<p>对应的核心方法为 <code>ep_poll</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ep_poll核心代码（fs/eventpoll.c）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    fetch_events:</span><br><span class="line">    <span class="keyword">if</span> (!ep_events_available(ep)) &#123;  <span class="comment">// 无就绪事件</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait， current);  <span class="comment">// 等待项关联当前进程</span></span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq， &amp;wait);  <span class="comment">// 加入eventpoll的等待队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);  <span class="comment">// 设为可中断睡眠</span></span><br><span class="line">            <span class="keyword">if</span> (ep_events_available(ep)) <span class="keyword">break</span>;  <span class="comment">// 有事件则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!schedule_hrtimeout_range(...)) <span class="keyword">break</span>;  <span class="comment">// 超时退出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq， &amp;wait);  <span class="comment">// 从等待队列移除</span></span><br><span class="line">        set_current_state(TASK_RUNNING);  <span class="comment">// 恢复运行状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集就绪事件并返回</span></span><br><span class="line">    <span class="keyword">return</span> ep_send_events(ep， events， maxevents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ep_send_events</code>会遍历<code>rdllist</code>，将就绪的socket信息拷贝到用户态缓冲区，完成一次事件通知。</p>
<p><strong>数据到达：epoll的回调与唤醒</strong></p>
<p>当 socket 收到数据时，触发流程与阻塞模型不同，关键在于<code>ep_poll_callback</code>：</p>
<ol>
<li><strong>数据入队</strong>：和同阻塞模型一样，数据被放入<code>sk-&gt;sk_receive_queue</code></li>
<li><strong>触发回调</strong>：<code>sock_def_readable</code>唤醒 socket 等待队列上的回调，包括 <code>ep_poll_callback</code></li>
<li><strong>加入就绪链表</strong>：<code>ep_poll_callback</code>将<code>epitem</code>加入<code>eventpoll-&gt;rdllist</code></li>
<li><strong>唤醒进程</strong>：若<code>eventpoll-&gt;wq</code>有等待的进程（即<code>epoll_wait</code>阻塞的进程），则唤醒它</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ep_poll_callback核心代码（fs/eventpoll.c）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将epitem加入就绪链表</span></span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink， &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒阻塞在epoll_wait的进程</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程的高效之处在于：数据到达时不会直接唤醒用户进程，而是先将事件加入就绪链表，等<code>epoll_wait</code>检查时一次性处理，减少了进程唤醒次数。</p>
<p>先通过 <code>epoll_create ()</code> 创建个 “总管家” struct eventpoll，它有三个关键部分：</p>
<ul>
<li>存所有客户端连接的<code>红黑树 rbr</code></li>
<li>放待处理连接的<code>就绪链表 rdllist</code></li>
<li>没活时进程休息的<code>等待队列 wq</code></li>
</ul>
<p>用通俗的话来讲：每个客户端 socket 连接会对应一个 <code>struct epitem</code>，类似观察者设计模式中的 <code>观测订阅</code>模式一样，用 <code>epoll_ctl (EPOLL_CTL_ADD)</code> 注册 socket 链接，这里核心是 <code>ep_insert</code> 函数：会先给连接建立 <code>epitem</code>同时再设 <code>ep_poll_callback</code> 回调，最后把 <code>epitem</code> 插进对应的存放订阅 socket 的数据结构红黑树 <code>rbr</code>里面。</p>
<p>之后用 <code>epoll_wait</code>（核心是 ep_poll 函数）等活干：先看 <code>rdllist</code> 有没有待处理连接，有就直接拿给用户态；没有就把进程放进 wq 休息。这里对应我们上面 py 代码里面的 <code>events = epoll.poll()</code>，进程及用户态操作 <code>socket</code> 的进程</p>
<p>等客户端发数据了，先把数据存起来，再触发 <code>ep_poll_callback</code> 回调，把对应 <code>epitem</code> 放进 <code>rdllist</code>，要是 wq 里有休息的进程，就叫醒它来处理，这样不用频繁唤醒进程，效率很高。</p>
<p>每个 <code>socket</code> 注册到 <code>epoll</code> 实例时，会关联到该实例的红黑树 <code>rbr</code>，而 <code>epoll</code> 实例又关联着自己的等待队列 wq（存放监听它的进程）。当 <code>epoll</code> 为单线程或者单进程拥有，那么 wq 里面只有<code>一个线程或者进程</code>，当存在多个的时候，即对应的 epoll 为<code>多个线程或者进程共享 epoll 实例</code>。</p>
<h4 id="epoll的优势-多路复用为什么快"><a href="#epoll的优势-多路复用为什么快" class="headerlink" title="epoll的优势:多路复用为什么快"></a>epoll的优势:多路复用为什么快</h4><p>epoll 相比同步阻塞IO的核心优势：</p>
<ol>
<li><strong>多路复用</strong>：一个进程管理多个连接，减少进程数量和切换开销，极⼤程度地减少了⽆⽤的进程上下⽂切换。</li>
<li><strong>事件驱动</strong>：仅在事件就绪时处理，避免无效等待，让进程更专注地处理⽹络请求。</li>
<li><strong>高效查找</strong>：通过就绪链表（O(1)）获取就绪事件，无需遍历所有连接</li>
<li><strong>灵活触发</strong>：支持水平触发（LT）和边缘触发（ET），适应不同场景</li>
</ol>
<p>这些特性使 <code>epoll</code> 能轻松支撑百万级并发连接，成为高性能服务的首选 <code>IO模型</code>，前面三个我们上文中已经描述，第四个这里的<code>水平触发和边缘触发</code>，是指<code>内核监控文件描述符（如 socket）</code>，当有数据可读&#x2F;可写时，通知应用程序处理。两者的差异只在 <code>通知的规则</code> 上。</p>
<ul>
<li><code>水平触发（LT，Level Trigger）</code>：默认模式，“不处理完就一直提醒”，绝大多数常规场景（如 Web 服务器、数据库连接），尤其是对编程复杂度敏感、无需极致性能的场景（比如 Nginx 默认用 LT 模式）。</li>
<li><code>边缘触发（ET，Edge Trigger）</code>：高效模式，“只提醒一次，过时不候”，极致性能需求的高并发场景（如百万连接的服务器、实时通信系统），比如 Redis、高吞吐的网关服务（需开发者自己处理好数据读取逻辑，避免遗漏）。</li>
</ul>
<h3 id="异步IO：-io-uring-统一异步-I-x2F-O-框架"><a href="#异步IO：-io-uring-统一异步-I-x2F-O-框架" class="headerlink" title="异步IO： io_uring 统一异步 I&#x2F;O 框架"></a>异步IO： io_uring 统一异步 I&#x2F;O 框架</h3><p><code>io_uring</code> 是一个由 Linux 内核提供的高性能、异步 I&#x2F;O 框架。它的设计目标是<code>解决传统异步 I/O 接口（如 aio）的缺陷</code>，为 <code>存储IO</code> 和 <code>网络IO</code> 提供一个真正高效、可扩展的解决方案。通过一个<code>共享的环形缓冲区（Ring Buffer）</code> 在内核和用户空间之间进行通信，<code>极大地减少了系统调用的开销和内存拷贝</code>。</p>
<p>对比上面的 多路复用 <code>epoll</code> 只解决了 <code>就绪通知</code> 问题，没有解决 <code>I/O 执行</code> 问题。 应用程序仍然需要调用 <code>read/write</code> 系统调用来处理数据，这在高负载下仍然是性能瓶颈。 而 Linux 原本的 异步 I&#x2F;O AIO 对网络 I&#x2F;O 的支持不完整且问题多，接口设计笨拙，使用复杂。而 <code>io_uring 通过其批量和异步的提交/完成机制</code>，从根本上解决了这个问题。</p>
<p><strong>共享环形队列架构</strong>: <code>io_uring</code> 的核心设计是基于两个在内核态和用户态之间共享的环形队列：</p>
<ul>
<li><code>提交队列（Submission Queue, SQ）</code>：用户程序向此队列提交 I&#x2F;O 请求,应用程序将希望执行的 I&#x2F;O 操作（如读取、写入）封装成一个 SQE（Submission Queue Entry），放入 SQ 中。</li>
<li><code>完成队列（Completion Queue, CQ）</code>：内核在此队列中放置已完成的 I&#x2F;O 操作结果,当内核完成一个 I&#x2F;O 操作后，会生成一个 CQE（Completion Queue Entry），放入 CQ 中。应用程序从 CQ 中取回结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">应用程序（Application）</span><br><span class="line">  ├─ 将新请求放入提交队列的队尾</span><br><span class="line">  └─ 从完成队列的队头获取响应</span><br><span class="line">       队头（head）                                             队头（head）</span><br><span class="line">提交队列（Submission Queue）   共享内存（Shared Memory）     完成队列（Completion Queue）</span><br><span class="line">       队尾（tail）                                             队尾（tail）</span><br><span class="line">  </span><br><span class="line">内核（Kernel）</span><br><span class="line">  ├─ 从提交队列的队头获取任务并执行</span><br><span class="line">  └─ 将响应结果放入完成队列的队尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两个队列通过<code>内存映射（mmap）</code>方式实现共享，避免了传统 I&#x2F;O 模型中的<code>数据拷贝开销</code>。</p>
<p><strong>无锁设计</strong>:队列采用单生产者 - 单消费者模型：</p>
<ul>
<li><code>SQ</code>：用户程序是生产者，内核是消费者</li>
<li><code>CQ</code>：内核是生产者，用户程序是消费者</li>
</ul>
<p>这种设计使得队列访问<code>无需加锁</code>，仅使用<code>内存屏障（memory barriers）进行同步</code>，极大提高了性能。</p>
<p>系统调用优化,<code>io_uring</code> 仅提供三个核心系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 io_uring 实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_setup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> entries, struct io_uring_params *params)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 I/O 请求并/或等待完成事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_enter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, u32 to_submit, u32 min_complete, u32 flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册资源（文件描述符、缓冲区等）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">io_uring_register</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">int</span> opcode, <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>基本流程：</p>
<ol>
<li>应用将 SQE 放入 SQ。</li>
<li>应用通过一次 <code>io_uring_enter</code> 系统调用，通知内核有新的任务需要处理（或者内核通过轮询模式直接获取，实现零系统调用）。</li>
<li>内核从 SQ 中取出 SQE 并执行 I&#x2F;O 操作。</li>
<li>操作完成后，内核将 CQE 放入 CQ。</li>
<li>应用从 CQ 中取出 CQE，确认操作完成状态。</li>
</ol>
<p><code>liburing</code> 库为 <code>io_uring</code> 的使用提供了便捷方式：它隐藏了部分底层复杂度，并提供各类函数用于准备所有类型的 I&#x2F;O 操作，以便提交执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#用户进程创建 io_uring 的代码示例如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">io_uring_queue_init(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//向 io_uring 提交队列提交操作的代码示例：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span> =</span> io_uring_get_sqe(&amp;ring);</span><br><span class="line">io_uring_prep_readv(sqe, client_socket, iov, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">io_uring_sqe_set_data(sqe, user_data);</span><br><span class="line">io_uring_submit(&amp;ring);</span><br><span class="line"><span class="comment">//进程等待操作完成的代码示例：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line"><span class="comment">//获取并处理响应结果的代码示例：</span></span><br><span class="line">user_data = io_uring_cqe_get_data(cqe);</span><br><span class="line"><span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">&#125;</span><br><span class="line">io_uring_cqe_seen(&amp;ring, cqe);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.redhat.com/articles/2023/04/12/why-you-should-use-iouring-network-io">通过编写一个简单的回声服务器，使用liburing API来实现网络I&#x2F;O。然后我们将了解如何最小化高速率并发工作负载所需的系统调用数量</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developers.redhat.com/articles/2023/04/12/why-you-should-use-iouring-network-io">https://developers.redhat.com/articles/2023/04/12/why-you-should-use-iouring-network-io</a></p>
<p>伯克利软件发行版（Berkeley Software Distribution，简称 BSD）Unix 中经典的回声服务器代码大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">client_fd = accept(listen_fd, &amp;client_addr, &amp;client_addrlen);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    numRead = read(client_fd, buf, BUF_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (numRead &lt;= <span class="number">0</span>)   <span class="comment">// 遇到 EOF 或错误时退出循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(client_fd, buf, numRead) != numRead)</span><br><span class="line">        <span class="comment">// 处理写操作错误</span></span><br><span class="line">&#125;</span><br><span class="line">close(client_fd);</span><br></pre></td></tr></table></figure>

<p>处理每个客户端会话至少需要 5 次系统调用：<code>accept（接收连接）</code>、<code>read（读数据）</code>、<code>write（写数据）</code>、再次 <code>read（检测 EOF）</code>，以及最终的<code>close（关闭连接）</code>。</p>
<p>若直接将上述逻辑迁移到 <code>io_uring</code>，会得到一个 “异步服务器”—— 它每次仅提交一个操作，等待该操作完成后再提交下一个。以下是基于 <code>io_uring</code> 的服务器伪代码（省略了基础初始化代码和错误处理逻辑）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">add_accept_request(listen_socket, &amp;client_addr, &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 见了连接一次提交</span></span><br><span class="line">io_uring_submit(&amp;ring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> (struct request *) cqe-&gt;user_data;</span><br><span class="line">    <span class="keyword">switch</span> (req-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ACCEPT:</span><br><span class="line">        add_accept_request(listen_socket,</span><br><span class="line">                          &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">        add_read_request(cqe-&gt;res);</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ:</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            add_close_request(req);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add_write_request(req);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WRITE:</span><br><span class="line">        add_read_request(req-&gt;socket);</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CLOSE:</span><br><span class="line">        free_request(req);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unexpected req type %d\n&quot;</span>, req-&gt;type);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个 <code>io_uring</code> 示例中，服务器处理每个新客户端仍需至少 4 次系统调用<code>(io_uring_submit(&amp;ring) -&gt;io_uring_enter )</code></p>
<p>需要说明 add_accept_request(封装了 <code>io_uring_prep_accept</code> 等 liburing 函数，将 accept 操作封装为提交队列项（SQE）） <strong>本身并不会触发系统调用</strong> ——它只是一个“准备请求”的库函数（属于 liburing 库），作用是填充 <code>io_uring</code> 的提交队列项（SQE）结构体，为后续提交异步 <code>accept</code> 操作做准备。</p>
<ol>
<li><strong><code>io_uring_prep_accept</code> 的本质</strong><br>它是 liburing 提供的辅助函数，功能是：<ul>
<li>初始化一个 <code>io_uring_sqe</code>（提交队列项）结构体；</li>
<li>设置操作类型为 <code>IORING_OP_ACCEPT</code>（或 <code>IORING_OP_ACCEPT_MULTISHOT</code>）；</li>
<li>填充 <code>accept</code> 所需的参数（如监听套接字、客户端地址结构体指针等）；</li>
<li>将该 SQE 加入 <code>io_uring</code> 的提交队列（SQ）中。</li>
</ul>
</li>
</ol>
<p>这个过程完全在<strong>用户空间</strong>完成，不涉及内核态切换，因此没有系统调用开销。</p>
<p><strong>真正触发系统调用的时机</strong>  </p>
<p>只有当调用 <code>io_uring_submit</code>（或底层的 <code>io_uring_enter</code> 系统调用）时，才会将提交队列（SQ）中已准备好的所有请求（包括通过 <code>io_uring_prep_accept</code> 准备的 <code>accept</code> 请求）批量提交给内核，此时才会触发<strong>一次系统调用</strong>（<code>io_uring_enter</code>）。</p>
<p>借助 <code>io_uring</code> 的 “固定文件”（fixed file）新特性，将 “接收连接（accept）” 与 “读操作（read）” 串联；但实际上，我们已经能将 “读请求” 与 “新的接收连接请求” 一起提交，因此这种串联可能不会带来明显收益。</p>
<p>我们可以同时提交多个独立操作—— 例如，将 “写操作” 与后续的 “读操作” 合并提交。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> submissions = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span> =</span> (struct request *) cqe-&gt;user_data;</span><br><span class="line">        <span class="keyword">switch</span> (req-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACCEPT:</span><br><span class="line">            add_accept_request(listen_socket,</span><br><span class="line">                              &amp;client_addr, &amp;client_addr_len);</span><br><span class="line">            add_read_request(cqe-&gt;res);</span><br><span class="line">            submissions += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> READ:</span><br><span class="line">            <span class="keyword">if</span> (cqe-&gt;res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                add_close_request(req);</span><br><span class="line">                submissions += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add_write_request(req);</span><br><span class="line">                add_read_request(req-&gt;socket);</span><br><span class="line">                submissions += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WRITE:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLOSE:</span><br><span class="line">            free_request(req);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unexpected req type %d\n&quot;</span>, req-&gt;type);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        io_uring_cqe_seen(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (io_uring_sq_space_left(&amp;ring) &lt; MAX_SQE_PER_LOOP) &#123;</span><br><span class="line">            <span class="keyword">break</span>;     <span class="comment">// 提交队列已满</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = io_uring_peek_cqe(&amp;ring, &amp;cqe);</span><br><span class="line">        <span class="keyword">if</span> (ret == -EAGAIN) &#123;</span><br><span class="line">            <span class="keyword">break</span>;     <span class="comment">// 完成队列中无剩余待处理任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (submissions &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        io_uring_submit(&amp;ring);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，处理每个客户端请求所需的系统调用次数可减少至 3 次,这里是关键区别：传统 <code>accept</code>** 每次调用都会触发一次系统调用，直接进入内核处理； <strong><code>io_uring_prep_accept + io_uring_submit</code></strong> 在<code>prep</code> 阶段仅在用户空间准备请求，<code>submit</code> 阶段批量提交多个请求（如同时提交 <code>accept</code>、<code>read</code>、<code>write</code> 等），仅触发<strong>一次系统调用</strong>即可处理多个操作。</p>
<h3 id="内核IO模型对比"><a href="#内核IO模型对比" class="headerlink" title="内核IO模型对比"></a>内核IO模型对比</h3><p>除了<code>阻塞IO</code>和<code>epoll</code>，Linux还支持<code>select、poll</code>等多路复用模型。以下是主要模型的对比：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>最大连接数</th>
<th>就绪事件查找</th>
<th>重复注册</th>
<th>内核用户拷贝</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>1024（FD_SETSIZE）</td>
<td>遍历（O(N)）</td>
<td>需要</td>
<td>有</td>
<td>跨平台、低并发</td>
</tr>
<tr>
<td>poll</td>
<td>无限制</td>
<td>遍历（O(N)）</td>
<td>需要</td>
<td>有</td>
<td>跨平台、中低并发</td>
</tr>
<tr>
<td>epoll</td>
<td>无限制</td>
<td>就绪链表（O(1)）</td>
<td>无需</td>
<td>可选（零拷贝）</td>
<td>高并发、Linux专属</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>有限（进程数）</td>
<td>无</td>
<td>无</td>
<td>有</td>
<td>低并发、简单场景</td>
</tr>
<tr>
<td>io_uring</td>
<td>无限制（队列深度 SQ&#x2F;CQ 大小）</td>
<td>完成队列遍历（批量处理）</td>
<td>可选（注册文件&#x2F;缓冲区）</td>
<td>可选（固定缓冲区零拷贝&#x2F;零拷贝）</td>
<td>高并发、高吞吐量、Linux专属（文件&#x2F;网络混合I&#x2F;O）</td>
</tr>
</tbody></table>
<p><code>select</code> 与 <code>poll</code> 两者都是 Linux 早期的多路复用 IO 机制，核心作用是让单个进程管理多个连接，解决传统阻塞 IO <code>一连接一线程</code>的<code>资源浪费</code>问题，但性能和特性有明显局限，任然需要大量的内存数据拷贝，而且 select 对管理的连接数也有限制</p>
<p>epoll 的优势在高并发场景下尤为明显，这也是为什么现代高性能服务（如Nginx、Redis）都采用 <code>epoll</code>作为IO模型。</p>
<p>简单介绍了 epoll ，回到我们最开始的关于Linux内核的问题，传输层的数据包在内核态和用户态如何流转的? 为何修改一些缓存区的阈值会影响性能？</p>
<p>关于第一个问题，小伙伴可以看我前几篇博文，这里简单介绍：</p>
<p>对于<code>发送端</code>来说，传输层的数据包会由<code>用户态</code>复制到<code>内核态</code>，然后通过<code>网卡</code>发送，大部分的时间消耗在用户进程<code>内核态协议栈解析以及内存拷贝</code>，发包需要关注的：</p>
<ul>
<li>一是<code>数据包拷贝问题</code>，需要进行一次深拷贝（用户态到内核态），一次浅拷贝（拷贝元数据，TCP重传留痕），一次可选的拷贝（数据包超过MTU进行切包进行的深拷贝，实际发生在网络层）</li>
<li>二是<code>中断问题</code>，数据包在发生过程中如果一直持有CPU，那么数据会顺利发送，如果超出CPU时间片，那么会触发软中断，由内核线程 <code>ksoftirqd</code> 继续发送，在网卡发送完数据之后会触发硬中断清空 <code>RingBuffer</code>。</li>
</ul>
<p>对于<code>接收端</code>来说，当<code>poll</code>函数（或类似I&#x2F;O多路复用机制）触发时，内核协议栈会将待处理的<code>sk_buff</code>（套接字缓冲区）交给传输层。内核态会先通过协议栈逐层解析数据包（从网络层到传输层），再按序将socket缓冲区中的数据拷贝到用户态。这一过程中，有两个关键点需要关注：</p>
<ul>
<li><code>中断处理机制</code> 数据包到达时，首先由网卡触发 <strong>硬中断</strong>，硬中断完成初步处理后会唤醒 <strong>软中断</strong>，最终由内核线程<code>ksoftirqd</code>负责后续的数据包处理（如协议解析、缓冲区管理等），由于接收端需要持续处理外部涌入的数据包，其软中断的触发频率通常远高于发送端。</li>
<li><code>数据包过滤与捕获逻辑</code> Netfilter（及基于其实现的iptables等）的过滤规则主要在网络层(或者网络层之前)生效，用于决定数据包是否允许进入上层协议或转发或者进行一些DNAT的配置。部分抓包工具是在<strong>设备层</strong>（接近网卡驱动的位置）通过钩子捕获数据包，因此即使数据包被iptables规则阻断，仍可能被这类工具捕获到。</li>
</ul>
<p>关于第二问题，内核为socket的接收 &#x2F; 发送缓冲区设置了默认大小和最大阈值（可通过<code>net.ipv4.tcp_rmem/tcp_wmem</code>等参数调整），这些阈值会直接影响<code>数据流转效率</code>，主要原因<code>套接字缓冲区</code>与<code>带宽延迟积（BDP）</code>需要协同</p>
<p>缓冲区阈值与BDP不匹配：</p>
<ul>
<li><code>若阈值过小（rmem_max/wmem_max远小于实际 BDP 时）</code>：当数据包涌入速度超过用户态读取速度时，内核接收缓冲区易满，导致 TCP 触发 “窗口关闭”（接收窗口为 0），发送端暂停发送，降低吞吐量，带宽利用率仅能达到理论值的 30%~50%；</li>
<li><code>若阈值过大（若远大于 BDP）</code>：虽能缓冲更多突发数据，但会占用过多内核内存，可能导致系统整体内存紧张，且用户态读取时单次拷贝数据量过大，可能增加延迟。</li>
</ul>
<p>系统内存限制失衡：<code>tcp_mem/udp_mem的min、pressure、max</code>设置不合理，要么因内存不足导致网络连接建立失败，要么因内存过度分配引发系统 OOM，中断数据流转。</p>
<p>关于设计到的内核参数，小伙伴可以看看我之前的博文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@developer ~]<span class="comment"># sysctl -a | grep mem</span></span><br><span class="line">....</span><br><span class="line">net.core.optmem_max = 81920  <span class="comment"># 套接字选项缓冲区的最大大小（字节），用于存储套接字选项相关数据，超过此值会返回错误</span></span><br><span class="line">net.core.rmem_default = 212992  <span class="comment"># 所有协议（如TCP、UDP）的默认接收缓冲区大小（字节），新建套接字默认使用此值</span></span><br><span class="line">net.core.rmem_max = 212992  <span class="comment"># 所有协议的最大接收缓冲区大小（字节），应用程序可设置的接收缓冲区上限（不能超过此值）</span></span><br><span class="line">net.core.wmem_default = 212992  <span class="comment"># 所有协议的默认发送缓冲区大小（字节），新建套接字默认使用此值</span></span><br><span class="line">net.core.wmem_max = 212992  <span class="comment"># 所有协议的最大发送缓冲区大小（字节），应用程序可设置的发送缓冲区上限（不能超过此值）</span></span><br><span class="line">net.ipv4.tcp_mem = 78777105039157554  <span class="comment"># TCP协议的整体内存管理阈值（单位：页，1页=4KB），三个值分别为：最小内存页、压力模式阈值、最大内存页。内核会根据TCP总内存使用量动态调整行为（如触发内存回收）</span></span><br><span class="line">net.ipv4.tcp_rmem = 40961310726291456  <span class="comment"># TCP接收缓冲区的内存范围（字节），三个值分别为：最小大小、默认大小、最大大小。应用程序可在范围内调整，内核也可能根据拥塞控制动态调整</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096163844194304  <span class="comment"># TCP发送缓冲区的内存范围（字节），三个值分别为：最小大小、默认大小、最大大小。作用类似tcp_rmem，用于控制发送缓冲区的动态调整范围</span></span><br><span class="line">net.ipv4.udp_mem = 157557210078315114  <span class="comment"># UDP协议的整体内存管理阈值（单位：页），三个值分别为：最小内存页、压力模式阈值、最大内存页。控制UDP总内存使用量，避免占用过多系统内存</span></span><br><span class="line">net.ipv4.udp_rmem_min = 4096  <span class="comment"># UDP接收缓冲区的最小大小（字节），应用程序设置的接收缓冲区不能小于此值</span></span><br><span class="line">net.ipv4.udp_wmem_min = 4096  <span class="comment"># UDP发送缓冲区的最小大小（字节），应用程序设置的发送缓冲区不能小于此值</span></span><br><span class="line">[root@developer ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h2 id="三、Python-Web框架：从WSGI到ASGI的IO模型演进"><a href="#三、Python-Web框架：从WSGI到ASGI的IO模型演进" class="headerlink" title="三、Python Web框架：从WSGI到ASGI的IO模型演进"></a>三、Python Web框架：从WSGI到ASGI的IO模型演进</h2><p>Python 的 Web 框架经历了从同步到异步的演进，其底层IO模型的变化直接影响了框架的性能和并发能力。WSGI 规范基于同步阻塞IO，而 ASGI 则引入了<code>异步IO和事件循环</code>，适配<code>epoll</code>等高效内核机制。</p>
<h3 id="WSGI：同步阻塞的时代"><a href="#WSGI：同步阻塞的时代" class="headerlink" title="WSGI：同步阻塞的时代"></a>WSGI：同步阻塞的时代</h3><p><code>WSGI（Web Server Gateway Interface）</code>是Python Web框架的标准接口，定义了Web服务器与应用程序之间的交互方式。它诞生于2003年，基于同步阻塞IO模型，至今仍是许多框架（如Django、Flask）的基础。</p>
<p>什么是 WSGI ？: <a target="_blank" rel="noopener" href="https://wsgi.readthedocs.io/en/latest/what.html">https://wsgi.readthedocs.io/en/latest/what.html</a></p>
<p>WSGI规范定义了两个核心角色：</p>
<ul>
<li><strong>服务器（Server）</strong>：接收HTTP请求，将其转换为WSGI环境，调用应用程序</li>
<li><strong>应用（Application）</strong>：一个可调用对象（函数&#x2F;类），接收<code>environ</code>（请求信息）和<code>start_response</code>（响应回调），返回响应体</li>
</ul>
<p>下面是一个 WSGI应用示例 的Demo</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@File    :   app.py</span></span><br><span class="line"><span class="string">@Time    :   2022/05/03 14:43:56</span></span><br><span class="line"><span class="string">@Author  :   Li Ruilong</span></span><br><span class="line"><span class="string">@Version :   1.0</span></span><br><span class="line"><span class="string">@Contact :   1224965096@qq.com</span></span><br><span class="line"><span class="string">@Desc    :   None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># here put the import lib</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notfound_404</span>(<span class="params">environ， start_response</span>):</span></span><br><span class="line">    start_response(<span class="string">&#x27;404 Not Found&#x27;</span>， [(<span class="string">&#x27;Content-type&#x27;</span>， <span class="string">&#x27;text/plain&#x27;</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;Not Found&#x27;</span>]</span><br><span class="line"><span class="comment"># 核心控制器，用于路由注册</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathDispatcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 映射字典</span></span><br><span class="line">        self.pathmap = &#123;&#125;</span><br><span class="line">    <span class="comment"># 核心控制器的回调</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self， environ， start_response</span>):</span></span><br><span class="line">        <span class="comment"># 获取路由</span></span><br><span class="line">        path = environ[<span class="string">&#x27;PATH_INFO&#x27;</span>]</span><br><span class="line">        <span class="comment"># 获取请求参数</span></span><br><span class="line">        params = cgi.FieldStorage(environ[<span class="string">&#x27;wsgi.input&#x27;</span>]，</span><br><span class="line">                                  environ=environ)</span><br><span class="line">        <span class="comment"># 获取请求方法</span></span><br><span class="line">        method = environ[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>].lower()</span><br><span class="line">        environ[<span class="string">&#x27;params&#x27;</span>] = &#123;key: params.getvalue(key) <span class="keyword">for</span> key <span class="keyword">in</span> params&#125;</span><br><span class="line">        <span class="comment"># 找到映射的函数</span></span><br><span class="line">        handler = self.pathmap.get((method， path)， notfound_404)</span><br><span class="line">        <span class="comment"># 返回函数</span></span><br><span class="line">        <span class="keyword">return</span> handler(environ， start_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self， method， path， function</span>):</span></span><br><span class="line">        <span class="comment"># 请求方法和路由作为K，执行函数为V</span></span><br><span class="line">        self.pathmap[method.lower()， path] = function</span><br><span class="line">        <span class="keyword">return</span> function</span><br><span class="line"></span><br><span class="line">_hello_resp = <span class="string">&quot;wo jiao &#123;name&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">environ， start_response</span>):</span></span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>， [(<span class="string">&#x27;Content-type&#x27;</span>， <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    params = environ[<span class="string">&#x27;params&#x27;</span>]</span><br><span class="line">    resp = _hello_resp.<span class="built_in">format</span>(name=params.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">    <span class="keyword">yield</span> resp.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_localtime_resp = <span class="string">&quot;dang qian shjian &#123;t&#125;&quot;</span></span><br><span class="line"><span class="comment"># 路由的回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">localtime</span>(<span class="params">environ， start_response</span>):</span></span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>， [(<span class="string">&#x27;Content-type&#x27;</span>， <span class="string">&#x27;application/xml&#x27;</span>)])</span><br><span class="line">    resp = _localtime_resp.<span class="built_in">format</span>(t=time.localtime())</span><br><span class="line">    <span class="keyword">yield</span> resp.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line">    <span class="comment"># 创建一个核心控制器，用于路由注册</span></span><br><span class="line">    dispatcher = PathDispatcher()</span><br><span class="line">    <span class="comment"># 注册路由，对应的回调方法</span></span><br><span class="line">    dispatcher.register(<span class="string">&#x27;GET&#x27;</span>， <span class="string">&#x27;/hello&#x27;</span>， hello_world)</span><br><span class="line">    dispatcher.register(<span class="string">&#x27;GET&#x27;</span>， <span class="string">&#x27;/localtime&#x27;</span>， localtime)</span><br><span class="line">    <span class="comment"># Launch a basic server 监听8080端口，注入核心控制器</span></span><br><span class="line">    httpd = make_server(<span class="string">&#x27;&#x27;</span>， <span class="number">8080</span>， dispatcher)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Serving on port 8080...&#x27;</span>)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<p>服务器与应用的交互流程：</p>
<ol>
<li>服务器接收请求，构建<code>environ</code>字典（包含HTTP方法、路径、 headers等）</li>
<li>服务器调用应用程序，传入<code>environ</code>和<code>start_response</code></li>
<li>应用程序处理业务逻辑，调用<code>start_response</code>设置状态码和响应头</li>
<li>应用程序返回响应体（迭代器），服务器将其发送给客户端</li>
</ol>
<p><strong>WSGI的IO模型限制</strong></p>
<p>WSGI基于同步阻塞IO，其服务器（如Gunicorn、uWSGI）通常采用”预派生子进程+线程池”的模型：<strong>Gunicorn的worker模式</strong>：</p>
<ul>
<li><code>sync</code>：每个请求由一个线程处理，阻塞IO（默认）</li>
<li><code>gevent</code>：基于协程的异步模式</li>
<li><code>eventlet</code>：类似gevent，依赖协程</li>
</ul>
<p>同步模式下，每个请求会占用一个线程，直到处理完成。当请求涉及IO操作（如数据库查询、网络调用）时，线程会阻塞等待，导致资源浪费。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flask（WSGI框架）的同步阻塞示例</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟IO阻塞（如数据库查询）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello， Flask&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()  <span class="comment"># 内置服务器使用同步模型，单线程处理请求</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>time.sleep(1)</code>会阻塞整个线程，期间无法处理其他请求。若同时有10个请求，总耗时约10秒（串行处理）。</p>
<p><strong>WSGI服务器的并发瓶颈</strong></p>
<p>WSGI服务器的并发能力受限于线程&#x2F;进程数量：</p>
<ul>
<li>进程&#x2F;线程数量有限（如Gunicorn默认1-4个worker，每个worker 10-20个线程）</li>
<li>每个线程&#x2F;进程占用内存（约几MB），数量过多会导致内存耗尽</li>
<li>IO阻塞时线程&#x2F;进程闲置，CPU利用率低</li>
</ul>
<p>例如，<code>Gunicorn</code> 的 <code>sync</code> worker 在处理 1000 个并发请求时，需要 1000 个线程，这会导致大量的上下文切换和内存消耗，性能急剧下降。</p>
<h3 id="ASGI：异步非阻塞的革新"><a href="#ASGI：异步非阻塞的革新" class="headerlink" title="ASGI：异步非阻塞的革新"></a>ASGI：异步非阻塞的革新</h3><p><code>ASGI（Asynchronous Server Gateway Interface）</code>是<code>Python 3.5+</code>推出的异步Web接口，旨在解决WSGI的同步限制，支持异步IO和长连接（如WebSocket）。它兼容WSGI，并引入了<code>事件循环和异步处理机制</code>。</p>
<p>ASGI引入了三个核心角色：</p>
<ul>
<li><strong>服务器（Server）</strong>：接收请求，管理连接生命周期，驱动事件循环</li>
<li><strong>应用（Application）</strong>：异步可调用对象，处理请求并返回响应</li>
<li><strong>中间件（Middleware）</strong>：位于服务器和应用之间，处理请求&#x2F;响应的转换</li>
</ul>
<p>与WSGI的主要区别：</p>
<ul>
<li>支持异步函数（<code>async def</code>）</li>
<li>基于事件循环（如<code>uvloop</code>，封装epoll&#x2F;kqueue）</li>
<li>支持双向通信（如<code>WebSocket</code>）</li>
<li>分阶段处理请求（连接建立、请求接收、响应发送）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ASGI应用示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">application</span>(<span class="params">scope， receive， send</span>):</span></span><br><span class="line">    <span class="comment"># scope：连接元数据（如类型、方法、路径）</span></span><br><span class="line">    <span class="comment"># receive：异步函数，接收事件（如请求体）</span></span><br><span class="line">    <span class="comment"># send：异步函数，发送事件（如响应）</span></span><br><span class="line">    <span class="keyword">await</span> send(&#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;http.response.start&#x27;</span>，</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>: <span class="number">200</span>，</span><br><span class="line">        <span class="string">&#x27;headers&#x27;</span>: [(<span class="string">b&#x27;content-type&#x27;</span>， <span class="string">b&#x27;text/plain&#x27;</span>)]，</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> send(&#123;</span><br><span class="line">        <span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;http.response.body&#x27;</span>，</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: <span class="string">b&#x27;Hello， ASGI&#x27;</span>，</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>ASGI的事件循环与IO模型</strong></p>
<p><code>ASGI服务器（如</code>Uvicorn、Hypercorn<code>）</code>基于异步事件循环，底层使用<code>epoll（Linux）、kqueue（BSD）</code>等高效IO多路复用机制：</p>
<ul>
<li><strong>事件循环</strong>：单线程（或多线程）中的无限循环，处理IO事件和任务调度</li>
<li><strong>协程（Coroutine）</strong>：轻量级”线程”，由事件循环调度，IO操作时主动让出CPU</li>
<li><strong>非阻塞IO</strong>：所有IO操作（如网络、文件）均为非阻塞，通过回调或Future通知完成</li>
</ul>
<p>下面的Demo中，<code>await asyncio.sleep(1)</code>会让协程让出CPU，事件循环可以同时处理其他请求。10个并发请求的总耗时约1秒（并行处理），效率远高于WSGI。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FastAPI（ASGI框架）的异步示例</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 异步IO操作（非阻塞）</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello， FastAPI&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app)  <span class="comment"># Uvicorn使用事件循环和epoll</span></span><br></pre></td></tr></table></figure>

<p>以 Uvicorn 为例，其工作流程，当 <code>Uvicorn</code> 启动时，会创建一个基于 <code>epoll</code> 的事件循环（通常使用 uvloop 实现），<code>epoll 事件循环</code>负责底层的 IO 事件检测和进程唤醒，<code>Uvicorn 的事件循环</code>负责上层的协程调度和业务逻辑处理。整个工作流程如下：</p>
<p>1 <strong>初始化阶段</strong>：Uvicorn 创建事件循环（运行在用户空间），创建服务器 socket 并绑定端口，将 socket 注册到 epoll（通过系统调用），事件循环进入等待状态<br>2 <strong>请求处理阶段</strong>：客户端发送 HTTP 请求到服务器，网络设备接收数据包并写入 socket 缓冲区，<strong>epoll 检测到 socket 可读</strong>，将其加入就绪列表，<strong>epoll 唤醒等待的 Uvicorn 事件循环进程</strong>，事件循环从就绪列表获取 socket，触发连接回调，创建协程来处理这个 HTTP 请求<br>3 <strong>异步处理阶段</strong>：协程开始处理请求头、请求体，当遇到 <code>await async_db_query()</code> 等 IO 操作时：，协程让出控制权给事件循环，事件循环将数据库查询的文件描述符注册到 epoll，事件循环继续调度其他就绪的协程<br>4 <strong>IO 完成阶段</strong>：数据库查询完成，数据准备就绪，<strong>epoll 检测到数据库连接可读</strong>，唤醒事件循环，事件循环找到对应的挂起协程并恢复执行，协程继续处理数据，生成 HTTP 响应，发送响应给客户端，完成请求处理<br>5 <strong>循环复用阶段</strong>：连接关闭或保持（HTTP&#x2F;11 keep-alive），事件循环继续等待下一个 epoll 事件，整个过程不断循环，高效处理并发请求</p>
<p><strong>ASGI对epoll的封装</strong></p>
<p>ASGI服务器的事件循环（如uvloop）直接封装了内核的epoll机制：</p>
<ol>
<li><strong>注册事件</strong>：服务器启动时，将监听socket注册到epoll，关注<code>EPOLLIN</code>事件（新连接）</li>
<li><strong>等待事件</strong>：调用<code>epoll_wait</code>等待事件就绪（非阻塞或超时）</li>
<li><strong>处理事件</strong>：<ul>
<li>新连接事件：调用<code>accept</code>获取客户端socket，注册到epoll（关注<code>EPOLLIN</code>）</li>
<li>数据可读事件：读取请求数据，创建协程处理</li>
<li>数据可写事件：发送响应数据</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简化的事件循环伪代码（模拟uvloop）</span></span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">epoll = select.epoll()</span><br><span class="line">server_socket = ...  <span class="comment"># 监听socket</span></span><br><span class="line">epoll.register(server_socket.fileno()， select.EPOLLIN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = epoll.poll()  <span class="comment"># 等待事件（epoll_wait）</span></span><br><span class="line">    <span class="keyword">for</span> fileno， event <span class="keyword">in</span> events:</span><br><span class="line">        <span class="keyword">if</span> fileno == server_socket.fileno():</span><br><span class="line">            <span class="comment"># 新连接</span></span><br><span class="line">            client_socket， addr = server_socket.accept()</span><br><span class="line">            epoll.register(client_socket.fileno()， select.EPOLLIN)</span><br><span class="line">        <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">            <span class="comment"># 数据可读</span></span><br><span class="line">            data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="comment"># 创建协程处理请求</span></span><br><span class="line">            loop.create_task(handle_request(client_socket， data))</span><br></pre></td></tr></table></figure>

<p>ASGI相比WSGI的核心优势：</p>
<ol>
<li><strong>更高的并发量</strong>：单个事件循环线程可处理数万连接（基于epoll）</li>
<li><strong>更低的资源消耗</strong>：协程比线程&#x2F;进程轻量（内存占用约KB级）</li>
<li><strong>更好的响应延迟</strong>：IO操作时不阻塞线程，资源利用率更高</li>
<li><strong>支持长连接</strong>：原生支持WebSocket、HTTP&#x2F;2等双向通信协议</li>
</ol>
<p>这里同样看下最开始的那个问题，<code>Python Web</code> 规范 <code>ASGI/WSGI</code> 那个适合 <code>IO/CPU</code> 密集型？</p>
<p><code>网络IO 密集型</code>和 <code>CPU 密集型</code>是两个不同的概念， ASGI 更多的是面向 <code>网络/IO 密集型的非阻塞处理</code>，他不适用 CPU 密集型，如果你的请求是一个CPU 密集型，那么还是会阻赛，所以 <code>CPU 密集型任务</code>更适合用 WSGI（或 ASGI 配合多进程&#x2F;线程池）,避免异步调度开销，核心原因在于两者的调度机制与任务特性的匹配度不同。具体来说：</p>
<ul>
<li><code>WSGI</code> 是同步阻塞的规范，每个请求会占用一个工作进程&#x2F;线程，直到处理完成，对于 CPU 密集型任务（如大量计算、数据处理），其阻塞特性本身不会加剧 CPU 负担，CPU 密集型任务的核心瓶颈是计算能力，所以只是无法高效复用进程&#x2F;线程，在高并发场景下吞服量比较小，并不是说资源利用率低。而且WSGI 的阻塞模式在此场景下不会比 ASGI 表现更差（甚至可能因减少异步调度开销而略优），需要持续的CPU占用，所以不会发生频繁的上下文切换。</li>
<li><code>ASGI</code> 是异步非阻塞的规范，基于事件循环机制，能在单线程内高效处理大量并发的网络 IO 操作（如数据库查询、网络请求等）。其优势在于当一个请求陷入 IO 等待时，可切换到其他请求继续处理，大幅提升 IO 密集型场景的吞吐量。但对于 CPU 密集型任务，由于 Python 的 GIL（全局解释器锁）限制，单线程内的 CPU 密集型任务会阻塞事件循环，导致其他请求无法被处理，反而降低整体性能。此时，ASGI 通常需要配合多进程或线程池来处理 CPU 密集型任务，本质上还是通过并行计算绕过 GIL 限制，而非 ASGI 自身的异步特性起作用。</li>
</ul>
<p>异步不等于快，吞吐量不等于处理速度，网络IO密集型和 CUP 密集型是两种不同场景，即使通过队列等方式做了处理，解决的也只是吞吐量，和处理速度没有关系。往往看上去处理完了，会发现程序内部积累了大量的协程，吃进去了，但是消化不了。</p>
<h2 id="四、Java-Tomcat：从BIO到NIO的线程模型演进"><a href="#四、Java-Tomcat：从BIO到NIO的线程模型演进" class="headerlink" title="四、Java Tomcat：从BIO到NIO的线程模型演进"></a>四、Java Tomcat：从BIO到NIO的线程模型演进</h2><p>Tomcat 是 Java生态中最流行的 <code>Web服务器</code>，其性能优化历程伴随着IO模型的演进。从最初的<code>BIO（阻塞IO）</code>到<code>NIO（非阻塞IO）</code>，再到<code>APR（Apache Portable Runtime）</code></p>
<p>Tomcat的核心组件包括：</p>
<ul>
<li><strong>Connector</strong>：处理网络连接，负责接收请求和发送响应</li>
<li><strong>Engine</strong>：处理请求的核心引擎，包含Host、Context等容器</li>
<li><strong>Container</strong>：管理Servlet的生命周期，处理业务逻辑</li>
</ul>
<p>其中，<strong>Connector</strong>是IO模型的核心实现者，不同的IO模型对应不同的Connector配置：</p>
<ul>
<li><code>BIO</code>：阻塞IO模型（Tomcat 7及之前默认）</li>
<li><code>NIO</code>：非阻塞IO模型（Tomcat 8及之后默认）</li>
<li><code>NIO2</code>：异步IO模型（Java NIO.2的AIO）</li>
<li><code>APR</code>：基于原生库的IO模型（最高性能,Tomcat10.0 废弃）</li>
</ul>
<h3 id="BIO模型：同步阻塞的局限性"><a href="#BIO模型：同步阻塞的局限性" class="headerlink" title="BIO模型：同步阻塞的局限性"></a>BIO模型：同步阻塞的局限性</h3><p>BIO（Blocking IO）是Tomcat最早采用的IO模型，基于同步阻塞IO实现。BIO Connector的核心组件：</p>
<ul>
<li><strong>Acceptor线程</strong>：监听端口，接收新连接，将Socket交给Worker线程</li>
<li><strong>Worker线程池</strong>：处理连接的读写和Servlet调用，每个连接占用一个线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BIO模型的简化流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioConnector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService workerPool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// Acceptor线程：接收新连接</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();  <span class="comment">// 阻塞等待新连接</span></span><br><span class="line">                <span class="comment">// 提交给Worker线程池处理</span></span><br><span class="line">                workerPool.submit(() -&gt; handle(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = socket.getInputStream();</span><br><span class="line">             OutputStream out = socket.getOutputStream()) &#123;</span><br><span class="line">            <span class="comment">// 读取请求（阻塞）</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            in.read(buffer);  <span class="comment">// 阻塞等待数据</span></span><br><span class="line">            <span class="comment">// 处理请求（调用Servlet）</span></span><br><span class="line">            String response = <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length: 5\r\n\r\nHello&quot;</span>;</span><br><span class="line">            <span class="comment">// 发送响应（阻塞）</span></span><br><span class="line">            out.write(response.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能瓶颈</strong> BIO模型的问题与Linux的同步阻塞IO类似：</p>
<ul>
<li>每个连接占用一个线程，高并发下需要大量线程（如10万连接需10万线程）</li>
<li>线程切换开销大（JVM线程切换约1-2μs&#x2F;次）</li>
<li>IO阻塞时线程闲置，CPU利用率低</li>
</ul>
<p>Tomcat的BIO模型在并发量超过1000时就会出现明显的性能下降，甚至OOM（内存溢出）。</p>
<h3 id="NIO模型：非阻塞与多路复用"><a href="#NIO模型：非阻塞与多路复用" class="headerlink" title="NIO模型：非阻塞与多路复用"></a>NIO模型：非阻塞与多路复用</h3><p>NIO（Non-blocking IO）是Tomcat 8引入的默认模型，基于Java NIO实现，底层依赖Linux的epoll（或Windows的IOCP）。</p>
<p><strong>核心组件与工作原理</strong></p>
<p>NIO Connector的核心组件：</p>
<ul>
<li><strong>Acceptor线程</strong>：接收新连接，注册到Selector</li>
<li><strong>Selector线程</strong>：多路复用器，监控注册的Channel（Socket）的IO事件</li>
<li><strong>Worker线程池</strong>：处理就绪事件（读写）和业务逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO模型的简化流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioConnector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService workerPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);  <span class="comment">// 非阻塞模式</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);  <span class="comment">// 注册接受事件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Selector线程：监控IO事件</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();  <span class="comment">// 阻塞等待事件（底层epoll_wait）</span></span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                    <span class="keyword">for</span> (Iterator&lt;SelectionKey&gt; it = keys.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">                        SelectionKey key = it.next();</span><br><span class="line">                        it.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="comment">// 处理新连接</span></span><br><span class="line">                            accept(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 处理读事件</span></span><br><span class="line">                            workerPool.submit(() -&gt; read(key));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">        SocketChannel client = server.accept();  <span class="comment">// 非阻塞,立即返回</span></span><br><span class="line">        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 注册读事件</span></span><br><span class="line">        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel channel = (SocketChannel) key.channel()) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            channel.read(buffer);  <span class="comment">// 非阻塞读</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 处理请求...</span></span><br><span class="line">            String response = <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length: 5\r\n\r\nHello&quot;</span>;</span><br><span class="line">            channel.write(ByteBuffer.wrap(response.getBytes()));  <span class="comment">// 非阻塞写</span></span><br><span class="line">            key.cancel();  <span class="comment">// 关闭连接</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NIO对epoll的封装"><a href="#NIO对epoll的封装" class="headerlink" title="NIO对epoll的封装"></a>NIO对epoll的封装</h4><p>Java NIO 的 <code>Selector</code> 在 Linux 上默认通过 epoll 实现：</p>
<ul>
<li><code>Selector.open()</code> → 创建<code>EPollSelectorImpl</code></li>
<li><code>channel.register(selector, OP_READ)</code> → 调用<code>epoll_ctl(EPOLL_CTL_ADD)</code></li>
<li><code>selector.select()</code> → 调用<code>epoll_wait</code>等待事件</li>
</ul>
<p>这种封装让Java开发者无需直接操作epoll,即可享受多路复用的高效性。</p>
<p><strong>性能提升</strong></p>
<p>NIO模型相比BIO的优势：</p>
<ul>
<li>单Selector线程可处理数万连接（基于epoll）</li>
<li>线程数量大幅减少（Worker线程池大小通常为CPU核心数*2）</li>
<li>IO操作非阻塞，线程利用率高</li>
</ul>
<h3 id="NIO2（AIO）模型：异步IO的尝试"><a href="#NIO2（AIO）模型：异步IO的尝试" class="headerlink" title="NIO2（AIO）模型：异步IO的尝试"></a>NIO2（AIO）模型：异步IO的尝试</h3><p>NIO2（Asynchronous IO）是Java 7引入的异步IO模型，基于回调机制，无需Selector监控事件。工作原理,NIO2的核心是<code>AsynchronousServerSocketChannel</code>，通过回调或<code>Future</code>处理IO事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO2模型的简化流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nio2Connector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        <span class="comment">// 接受连接,指定回调</span></span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span> </span>&#123;</span><br><span class="line">                server.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);  <span class="comment">// 继续接受新连接</span></span><br><span class="line">                <span class="comment">// 读取数据,指定回调</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                client.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer bytesRead, ByteBuffer buf)</span> </span>&#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        <span class="comment">// 处理请求...</span></span><br><span class="line">                        String response = <span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Length: 5\r\n\r\nHello&quot;</span>;</span><br><span class="line">                        client.write(ByteBuffer.wrap(response.getBytes()));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer buf)</span> </span>&#123;</span><br><span class="line">                        exc.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Void attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些类似上面我们讲的 python的一些事件驱动框架 FastAPI 之类基于协程异步处理，NIO2在Tomcat中并未成为主流，目前，Tomcat的NIO2 Connector使用较少，大多数场景下NIO仍是更优选择。</p>
<h3 id="APR模型：原生库的极致性能"><a href="#APR模型：原生库的极致性能" class="headerlink" title="APR模型：原生库的极致性能"></a>APR模型：原生库的极致性能</h3><p>APR（Apache Portable Runtime）是Tomcat的高性能IO模型，基于原生C库实现，绕过JVM的IO层，直接操作操作系统内核，同时也意味着内存使用的是堆外本地内存，不归 JVM 内存模型管理，避免了数据从内核空间到 JVM 堆空间的额外一次拷贝</p>
<p><strong>工作原理</strong>: APR的核心组件：</p>
<ul>
<li><strong>原生Socket</strong>：使用C语言的<code>socket</code>、<code>epoll</code>等系统调用</li>
<li><strong>内存池</strong>：高效的内存管理，减少JVM GC开销</li>
<li><strong>OpenSSL集成</strong>：原生支持HTTPS，性能优于Java实现</li>
</ul>
<p>需要说明：APR&#x2F;Native Connector 将在 Tomcat 10.1.x 及更高版本中移除。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-10.0-doc/api/org/apache/coyote/http11/Http11AprProtocol.html">Deprecated.<br>The APR&#x2F;Native Connector will be removed in Tomcat 10.1.x onwards.</a></p>
</blockquote>
<p><strong>性能优势</strong>: 某些场景下(本地库优势&#x2F;零拷贝技术) <code>APR</code>相比<code>NIO</code>的拥有极致的性能，其优势主要为：</p>
<ul>
<li>减少JVM与内核的交互开销（原生库直接调用系统调用）</li>
<li>更高效的内存管理（避免JVM堆外内存拷贝）</li>
<li>HTTPS场景下性能提升显著（原生OpenSSL）</li>
</ul>
<h3 id="Tomcat线程模型对比"><a href="#Tomcat线程模型对比" class="headerlink" title="Tomcat线程模型对比"></a>Tomcat线程模型对比</h3><table>
<thead>
<tr>
<th>模型</th>
<th>底层机制</th>
<th>线程数量</th>
<th>并发能力</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>同步阻塞IO</td>
<td>每连接一线程</td>
<td>低</td>
<td>低并发、调试环境</td>
</tr>
<tr>
<td>NIO</td>
<td>Java NIO（epoll）</td>
<td>固定线程池</td>
<td>中高</td>
<td>常规Web服务、高并发API</td>
</tr>
<tr>
<td>NIO2</td>
<td>异步IO（AIO）</td>
<td>回调线程池</td>
<td>中</td>
<td>特定异步场景</td>
</tr>
<tr>
<td>APR</td>
<td>原生C库（epoll）</td>
<td>固定线程池</td>
<td>高</td>
<td>极致性能需求、HTTPS服务</td>
</tr>
</tbody></table>
<p>Tomcat 10默认仍使用NIO模型，因其在兼容性和性能之间取得了最佳平衡。</p>
<p>关于 Tomcat 的网络IO 模型简单介绍到这里，回到我们最开始的那个问题，对于 <code>Java</code> 来说 <code>Tomcat</code> 是什么？有了 <code>Web</code> 框架为什么还需要 <code>Tomcat</code>？</p>
<p>其实上面已经给出了答案，对于 Java 来说， <code>Tomcat</code> 是一个 <code>Web</code> 服务器，或者说是 java  Web Servlet 容器，或者说是 Java Web 应用的运行环境，关于第二个问题，Web 框架（如 Spring MVC）和 Tomcat Web 服务器 解决的是不同层面的问题，Web 框架聚焦 “业务逻辑”，Tomcat 聚焦 “底层通信与容器管理”,我们上面讲的IO模型，就是由Tomcat 利用系统特性实现的。</p>
<h2 id="博文部分内容参考"><a href="#博文部分内容参考" class="headerlink" title="博文部分内容参考"></a>博文部分内容参考</h2><p>© 文中涉及参考链接内容版权归原作者所有，如有侵权请告知 :)</p>
<hr>
<p>《深入理解Linux网络： 修炼底层内功，掌握高性能原理 (张彦飞)》</p>
<p>《Tomcat内核设计剖析（汪建）》</p>
<p><a target="_blank" rel="noopener" href="https://developers.redhat.com/articles/2023/04/12/why-you-should-use-iouring-network-io">https://developers.redhat.com/articles/2023/04/12/why-you-should-use-iouring-network-io</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7476273893821988879">https://juejin.cn/post/7476273893821988879</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268140269">https://zhuanlan.zhihu.com/p/268140269</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2442120">https://cloud.tencent.com/developer/article/2442120</a></p>
<p><a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-10.0-doc/api/org/apache/coyote/http11/Http11AprProtocol.html">https://tomcat.apache.org/tomcat-10.0-doc/api/org/apache/coyote/http11/Http11AprProtocol.html</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/63169865/how-to-do-multiprocessing-in-fastapi/63171013#63171013">https://stackoverflow.com/questions/63169865/how-to-do-multiprocessing-in-fastapi/63171013#63171013</a></p>
<hr>
<p>© 2018-至今 <a href="mailto:&#x6c;&#x69;&#x72;&#117;&#x69;&#x6c;&#111;&#110;&#103;&#x65;&#114;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#x6c;&#x69;&#x72;&#117;&#x69;&#x6c;&#111;&#110;&#103;&#x65;&#114;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a>， All rights reserved. 保持署名-非商用-相同方式共享(CC BY-NC-SA 4.0)</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>：Linux网络优化之从Linux内核epoll/io_uring 到Python(ASGI/WSGI)及Java Tomcat(BIO/NIO)网络IO模型认知</p><p><a href="https://liruilongs.github.io/2025/10/26/待发布/Linux网络优化之从Linux内核epoll到Python(ASGI、WSGI)及Java Tomcat(BIO、NIO)重新认识网络IO模型/">https://liruilongs.github.io/2025/10/26/待发布/Linux网络优化之从Linux内核epoll到Python(ASGI、WSGI)及Java Tomcat(BIO、NIO)重新认识网络IO模型/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-10-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-11-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2025/10/06/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85%E8%AE%A4%E7%9F%A5/" target="_blank">Linux网络调优之内核网络栈发包收包认知</a><br></span><span>  2.<a class="is-size-6" href="/2025/08/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%20OOM%20Killer%20%E7%9A%84%E8%AE%A4%E7%9F%A5%E4%B8%8E%E8%A7%82%E6%B5%8B/" target="_blank">Linux 性能调优之 OOM Killer 的认知与观测</a><br></span><span>  3.<a class="is-size-6" href="/2025/06/30/%E5%BE%85%E5%8F%91%E5%B8%83/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8(RSS)%E4%B8%8D%E5%81%9C%E5%A2%9E%E9%95%BF%EF%BC%9F%E5%88%A9%E7%94%A8%20BPF%20%E8%B7%9F%E8%B8%AA%E3%80%81%E7%BB%9F%E8%AE%A1%20Linux%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/" target="_blank">为什么进程的物理内存占用(RSS)不停增长？ 利用 BPF 跟踪、统计 Linux 缺页异常</a><br></span><span>  4.<a class="is-size-6" href="/2025/06/18/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-BPF-%E7%9B%91%E6%8E%A7-Linux-%E7%94%A8%E6%88%B7%E6%80%81%E5%B0%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B-BPF-%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E6%80%81%E5%B0%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" target="_blank">如何使用 BPF 监控 Linux 用户态小内存分配：Linux 内存调优之 BPF 分析用户态小内存分配</a><br></span><span>  5.<a class="is-size-6" href="/2025/06/16/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-BPF-%E7%9B%91%E6%8E%A7-Linux-%E7%94%A8%E6%88%B7%E6%80%81%E5%A4%A7%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B-BPF-%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E6%80%81%E5%A4%A7%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" target="_blank">Linux 内存调优之 BPF 分析用户态 mmap 大内存分配</a><br></span><span>  6.<a class="is-size-6" href="/2025/05/26/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-BPF-%E5%88%86%E6%9E%90-Linux-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8CLinux-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B-BPF-%E5%88%86%E6%9E%90%E5%86%85%E6%A0%B8%E6%80%81%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" target="_blank">如何使用 BPF 分析 Linux 内存泄漏，Linux 性能调优之 BPF 分析内核态、用户态内存泄漏</a><br></span><span>  7.<a class="is-size-6" href="/2025/04/18/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%AE%A4%E8%AF%86%20Linux%20%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E9%A1%B5%E8%A1%A8%E3%80%81TLB%E3%80%81%E5%A4%A7%E9%A1%B5%E8%AE%A4%E7%9F%A5/" target="_blank">认识 Linux 内存构成：Linux 内存调优之页表、TLB、缺页异常、大页认知</a><br></span><span>  8.<a class="is-size-6" href="/2025/04/15/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90/" target="_blank">Linux 内存调优之如何限制进程、系统级别内存资源</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2024/10/10/Git/Git-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81-reference-broken-%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" target="_blank">Git 提交代码 reference broken 问题处理</a><br></span><span>  3.<a class="is-size-6" href="/2022/11/19/Git/%E5%85%B3%E4%BA%8E-Git-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于 Git 重写历史的一些笔记</a><br></span><span>  4.<a class="is-size-6" href="/2022/08/02/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支变基操作的一些笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/07/26/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支基础知识的一些笔记</a><br></span><span>  6.<a class="is-size-6" href="/2022/08/02/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支工作流的一些笔记</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/10/06/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85%E8%AE%A4%E7%9F%A5/"><span class="level-item">Linux网络调优之内核网络栈发包收包认知</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '701fe6e8181938abac7bc50a2fa8cc46',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#一、为什么网络IO模型如此重要？"><span class="mr-2">2</span><span>一、为什么网络IO模型如此重要？</span></a></li><li><a class="is-flex is-mobile" href="#二、Linux内核IO模型：阻塞与多路复用、异步IO的底层逻辑"><span class="mr-2">3</span><span>二、Linux内核IO模型：阻塞与多路复用、异步IO的底层逻辑</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#socket在内核中的数据结构"><span class="mr-2">3.1</span><span>socket在内核中的数据结构</span></a></li><li><a class="is-flex is-mobile" href="#同步阻塞IO：进程等待的低效模型"><span class="mr-2">3.2</span><span>同步阻塞IO：进程等待的低效模型</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#同步阻塞的核心流程"><span class="mr-2">3.2.1</span><span>同步阻塞的核心流程</span></a></li><li><a class="is-flex is-mobile" href="#同步阻塞IO的性能瓶颈"><span class="mr-2">3.2.2</span><span>同步阻塞IO的性能瓶颈</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#多路复用IO：epoll的高效实现"><span class="mr-2">3.3</span><span>多路复用IO：epoll的高效实现</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#epoll-的核心流程"><span class="mr-2">3.3.1</span><span>epoll 的核心流程</span></a></li><li><a class="is-flex is-mobile" href="#epoll的优势-多路复用为什么快"><span class="mr-2">3.3.2</span><span>epoll的优势:多路复用为什么快</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#异步IO：-io-uring-统一异步-I-x2F-O-框架"><span class="mr-2">3.4</span><span>异步IO： io_uring 统一异步 I/O 框架</span></a></li><li><a class="is-flex is-mobile" href="#内核IO模型对比"><span class="mr-2">3.5</span><span>内核IO模型对比</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#三、Python-Web框架：从WSGI到ASGI的IO模型演进"><span class="mr-2">4</span><span>三、Python Web框架：从WSGI到ASGI的IO模型演进</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#WSGI：同步阻塞的时代"><span class="mr-2">4.1</span><span>WSGI：同步阻塞的时代</span></a></li><li><a class="is-flex is-mobile" href="#ASGI：异步非阻塞的革新"><span class="mr-2">4.2</span><span>ASGI：异步非阻塞的革新</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#四、Java-Tomcat：从BIO到NIO的线程模型演进"><span class="mr-2">5</span><span>四、Java Tomcat：从BIO到NIO的线程模型演进</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#BIO模型：同步阻塞的局限性"><span class="mr-2">5.1</span><span>BIO模型：同步阻塞的局限性</span></a></li><li><a class="is-flex is-mobile" href="#NIO模型：非阻塞与多路复用"><span class="mr-2">5.2</span><span>NIO模型：非阻塞与多路复用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#NIO对epoll的封装"><span class="mr-2">5.2.1</span><span>NIO对epoll的封装</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#NIO2（AIO）模型：异步IO的尝试"><span class="mr-2">5.3</span><span>NIO2（AIO）模型：异步IO的尝试</span></a></li><li><a class="is-flex is-mobile" href="#APR模型：原生库的极致性能"><span class="mr-2">5.4</span><span>APR模型：原生库的极致性能</span></a></li><li><a class="is-flex is-mobile" href="#Tomcat线程模型对比"><span class="mr-2">5.5</span><span>Tomcat线程模型对比</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#博文部分内容参考"><span class="mr-2">6</span><span>博文部分内容参考</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">452</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">145</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">192</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-25T20:27:41.000Z">2025-10-26</time></p><p class="title"><a href="/2025/10/26/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BB%8ELinux%E5%86%85%E6%A0%B8epoll%E5%88%B0Python(ASGI%E3%80%81WSGI)%E5%8F%8AJava%20Tomcat(BIO%E3%80%81NIO)%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%BD%91%E7%BB%9CIO%E6%A8%A1%E5%9E%8B/">：Linux网络优化之从Linux内核epoll/io_uring 到Python(ASGI/WSGI)及Java Tomcat(BIO/NIO)网络IO模型认知</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-10-06T06:01:02.000Z">2025-10-06</time></p><p class="title"><a href="/2025/10/06/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85%E8%AE%A4%E7%9F%A5/">Linux网络调优之内核网络栈发包收包认知</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-11T02:11:26.000Z">2025-08-11</time></p><p class="title"><a href="/2025/08/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%20OOM%20Killer%20%E7%9A%84%E8%AE%A4%E7%9F%A5%E4%B8%8E%E8%A7%82%E6%B5%8B/">Linux 性能调优之 OOM Killer 的认知与观测</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-30T10:24:20.000Z">2025-06-30</time></p><p class="title"><a href="/2025/06/30/%E5%BE%85%E5%8F%91%E5%B8%83/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8(RSS)%E4%B8%8D%E5%81%9C%E5%A2%9E%E9%95%BF%EF%BC%9F%E5%88%A9%E7%94%A8%20BPF%20%E8%B7%9F%E8%B8%AA%E3%80%81%E7%BB%9F%E8%AE%A1%20Linux%20%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8/">为什么进程的物理内存占用(RSS)不停增长？ 利用 BPF 跟踪、统计 Linux 缺页异常</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-06-18T02:08:06.000Z">2025-06-18</time></p><p class="title"><a href="/2025/06/18/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-BPF-%E7%9B%91%E6%8E%A7-Linux-%E7%94%A8%E6%88%B7%E6%80%81%E5%B0%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B-BPF-%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E6%80%81%E5%B0%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">如何使用 BPF 监控 Linux 用户态小内存分配：Linux 内存调优之 BPF 分析用户态小内存分配</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AIGC/"><span class="level-start"><span class="level-item">AIGC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/BPF/"><span class="level-start"><span class="level-item">BPF</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/10/"><span class="level-start"><span class="level-item">十月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/08/"><span class="level-start"><span class="level-item">八月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/06/"><span class="level-start"><span class="level-item">六月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">98</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">66</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"><span class="tag">华为云</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BPF/"><span class="tag">BPF</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mysql/"><span class="tag">Mysql</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLM/"><span class="tag">LLM</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%BD%B1%E6%9B%9D%E5%85%89/"><span class="tag">摄影曝光</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2025 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案中</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>