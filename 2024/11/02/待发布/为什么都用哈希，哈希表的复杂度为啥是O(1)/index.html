<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>为什么都用哈希,Hash 表的时间复杂度为什么是 O(1)？ - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="生如夏花之灿烂,死如秋叶之静美。—— 泰戈尔 《生如夏花》"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="生如夏花之灿烂,死如秋叶之静美。—— 泰戈尔 《生如夏花》"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mp.weixin.qq.com/img/头像.jpg"><meta property="article:published_time" content="2024-11-02T15:32:37.000Z"><meta property="article:modified_time" content="2024-11-22T02:20:25.610Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="Hash"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2024/11/02/%E5%BE%85%E5%8F%91%E5%B8%83/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%BD%E7%94%A8%E5%93%88%E5%B8%8C%EF%BC%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E5%95%A5%E6%98%AFO(1)/"},"headline":"山河已无恙","image":["https://liruilongs.github.io/img/og_image.png"],"datePublished":"2024-11-02T15:32:37.000Z","dateModified":"2024-11-22T02:20:25.610Z","author":{"@type":"Person","name":"山河已无恙"},"description":"生如夏花之灿烂,死如秋叶之静美。—— 泰戈尔 《生如夏花》"}</script><link rel="canonical" href="https://liruilongs.github.io/2024/11/02/%E5%BE%85%E5%8F%91%E5%B8%83/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%BD%E7%94%A8%E5%93%88%E5%B8%8C%EF%BC%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E5%95%A5%E6%98%AFO(1)/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-11-02  <a class="commentCountImg" href="/2024/11/02/%E5%BE%85%E5%8F%91%E5%B8%83/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%83%BD%E7%94%A8%E5%93%88%E5%B8%8C%EF%BC%8C%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%E5%95%A5%E6%98%AFO(1)/#comment-container"><span class="display-none-class">42d1fed0b8b745863395d80cbec05504</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="42d1fed0b8b745863395d80cbec05504">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>6.8 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">为什么都用哈希,Hash 表的时间复杂度为什么是 O(1)？</h1><div class="content"><p><strong><font color="009688">生如夏花之灿烂,死如秋叶之静美。—— 泰戈尔 《生如夏花》</strong></font></p>
<span id="more"></span>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><hr>
<ul>
<li>博文内容为哈希表的简单认知</li>
<li>涉及Hash表的索引计算，长度计算，以及如何减少哈希冲突，一致性哈希认知</li>
<li>理解不足小伙伴帮忙指正 :),生活加油</li>
</ul>
<p><strong><font color="009688">生如夏花之灿烂,死如秋叶之静美。—— 泰戈尔 《生如夏花》</strong></font></p>
<hr>
<h2 id="Hash-表的时间复杂度为什么是-O-1"><a href="#Hash-表的时间复杂度为什么是-O-1" class="headerlink" title="Hash 表的时间复杂度为什么是 O(1)"></a>Hash 表的时间复杂度为什么是 O(1)</h2><p>讲 Hash 之前，简单聊聊数组(直接寻址表)</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是内存中一块连续的空间，并且数组中必须存放相同的类型，所以存放数组只需要记住 首地址的位置就可以，而且数组的长度必须是定长。</p>
<p>以 int 数据类型为例，每个 int 占 4 字节内存空间，所以对一个一个长度单位为 5 的整形数组，所占用的字节为 4*5&#x3D;20 字节，知道首地址，数组每个元素定长，可以轻易算出每个数据的内存下标地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------+------------+------------+------------+------------+</span><br><span class="line">| arr[0]     | arr[1]     | arr[2]     | arr[3]     | arr[4]     |</span><br><span class="line">+------------+------------+------------+------------+------------+</span><br><span class="line">| 内存地址 1  | 内存地址 2   | 内存地址 3  | 内存地址 4  | 内存地址 5   |</span><br><span class="line">+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>arr[0]</code> 存储在内存地址1，<code>arr[1]</code> 存储在内存地址2，依此类推。每个元素之间的间隔是4个字节（一个整数的大小）。</p>
<p>这样，通过首地址和元素的大小，我们可以计算出数组中任意元素的内存地址。</p>
<p>数组的首地址假设为 <code>base_address</code> &#x3D; 1000，那么：</p>
<ul>
<li>arr[0] 的地址是 <code>base_address</code></li>
<li>arr[1] 的地址是 <code>base_address + 4</code></li>
<li>arr[2] 的地址是 <code>base_address + 8</code></li>
<li>arr[3] 的地址是 <code>base_address + 12</code></li>
<li>arr[4] 的地址是 <code>base_address + 16</code></li>
</ul>
<p>所以只读取数组元素的时候，可以直接通过下标，也就是索引进行读取，即我们常讲的直接寻址，时间复杂度为 <code>O(1)</code>. 所以在算法导论中也会把数组称为<code>直接寻址表</code></p>
<p><code>随机快速读写</code>是数组的一个特性，在 Java 中有个 标志性接口 <code>RandomAccess</code> 用于表示此类特性，比如我们经常用的 <code>ArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是常讲 对于 <code>ArrayList</code>  来说 通过<code>索引访问要优于通过迭代器访问</code>。知道索引下标后，下标乘以元素大小，再加上数组的首地址，就可以获得目标访问地址，直接获取数据。通过迭代器方法，需要通过方法先获取索引，中间多了一步，并且最好指定<code>初始容量</code>，数组定长，所以<code>每一次的扩容都要进行一次数组拷贝</code></p>
<p>在数组的情况下，由于元素是连续存储的，<code>序列化过程可以直接将整个内存块复制到磁盘或网络中，这样可以减少 CPU 的开销，提高效率</code>。所以数组尤其适合于需要高性能数据传输的场景。</p>
<p>相比在链表中，由于节点是分散存储的，<code>序列化时必须遍历每一个节点，将其值逐个写入到连续的内存中</code>，这样不仅需要更多的计算时间，还可能在内存分配上引入额外的开销。</p>
<h3 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h3><p>回头来看 <code>Hash</code> 表，数组可以<code>直接寻址</code>，但是缺点很明显，必须<code>定长</code>，元素大小相等,实际中使用的时候，往往可能不知道需要多长，希望是一个动态集合。</p>
<p>这个时候可以定义一个<code>很大的数组</code>，但是存在一种情况，<code>当要存放的元素远远小于定义某个长度的数组的时候</code>，就会造成资源浪费。</p>
<p>所以我们需要一种数据结构来实现上面的功能，可以根据要放的元素动态的定义数组的大小，这也就是<code>哈希表</code>，算法导论中也叫<code>散列表</code>。</p>
<h4 id="索引计算"><a href="#索引计算" class="headerlink" title="索引计算"></a>索引计算</h4><p><code>哈希表</code>会通过<code>哈希函数</code>把要放的元素转换为一个<code>哈希值</code>，往往是一个 Int 型 的数值，如何得到索引，最简单的方法就是<code>余数法</code>，使用 Hash 表的数组长度对哈希值求余， 余数即为 Hash 表数组的下标,使用这个下标就可以直接访问得到 Hash 表中存储的数据。。每次读写元素的时候会<code>计算哈希值</code>得到<code>索引</code>然后读写。</p>
<p>因为<code>哈希函数</code>的执行时间是<code>常量</code>，数组的<code>随机访问</code>也是<code>常量</code>，时间复杂度就是 <code>O(1)</code>。</p>
<p>在编程语言中，为了避免哈希冲突，会对哈希函数的数据做进一步处理，对于 Java 来讲，<code>HashMap</code> 的 <code>hash</code> 方法接收一个 <code>Object</code> 类型的 <code>key</code> 参数，然后根据 <code>key</code> 的 <code>hashCode()</code> 方法计算出的哈希值 <code>h</code>。</p>
<p>然后会执行位运算 <code>h &gt;&gt;&gt; 16</code>（将 <code>h</code> 的高 16 位右移 16 位），然后将结果与原始哈希值 <code>h</code> 进行异或操作（<code>^</code>），最后返回计算得到的哈希值。</p>
<p>Java 的 <code>HashSet</code> 也是基于 <code>HashMap</code> 的只是 <code>Val</code> 做了单独处理。</p>
<p>下面为 <code>HashMap</code> 的扰动函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Object 的 哈希函数是一个原生的方法，即由 JVM 提供，可能通过 C 或者 C++ 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;    </span><br></pre></td></tr></table></figure>

<p>通过一个具体的例子来解释 Java 中 <code>HashMap</code> 的 <code>hash</code> 方法是如何工作的，以及为什么通过对原始哈希值的高 16 位和低 16 位进行异或操作可以减少哈希冲突</p>
<p>假设我们有一个字符串键 <code>&quot;example&quot;</code>，其 <code>hashCode()</code> 方法返回的原始哈希值为 <code>1047298352</code> 一个 int 值.</p>
<p>即4字节32 位： <code>0011 1110 0110 1100 1000 0001 0011 0000</code></p>
<p><strong>原始哈希值</strong>：<code>h = 1047298352</code></p>
<ul>
<li>高 16 位：<code>0011 1110 0110 1100</code>（二进制）</li>
<li>低 16 位：<code>1000 0001 0011 0000</code>（二进制）</li>
</ul>
<p><strong>右移操作</strong>：<code>h &gt;&gt;&gt; 16</code>，高位填0，原来的高位变低位</p>
<ul>
<li>结果：<code>0000 0000 0000 0000 0011 1110 0110 1100</code>（二进制）</li>
<li>这个操作将原始哈希值的高位信息“复制”到了低位。</li>
</ul>
<p><strong>异或操作</strong>：<code>h ^ (h &gt;&gt;&gt; 16)</code></p>
<ul>
<li>结果：<code>1047298352 ^ 15980 = 1047560497</code>（十进制）&#x3D;<code>00111110011011001011111101011100</code> （二进制）</li>
<li>异或操作将高位的信息混合到了低位，使得高位的变化能够影响到低位。</li>
</ul>
<p>通过对原始哈希值的高 16 位和低 16 位进行异或操作，<code>HashMap</code> 的 <code>hash</code> 方法试图达到以下目的：</p>
<ul>
<li><strong>均匀分布</strong>：这种混合操作有助于在哈希表中更均匀地分布键，因为高位的变化现在能够影响到低位，从而减少了只依赖低位导致的分布不均。</li>
<li><strong>减少冲突</strong>：由于高位信息现在也被考虑在内，因此具有相似高位但不同低位的键更有可能产生不同的哈希值，从而减少了哈希冲突的可能性。</li>
</ul>
<p>当调用 <code>putVal</code> 方法插入键值对时，会传入通过 <code>hash</code> 方法计算得到的哈希值作为 <code>hash</code> 参数,然后计算索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>这里的 n 为数组的长度，那么数组长度如何确定？</p>
<h4 id="长度计算"><a href="#长度计算" class="headerlink" title="长度计算"></a>长度计算</h4><p>索引的问题解决了，那么长度是如何解决的，我们知道既然使用数组，那么一定是<code>定长</code>才行</p>
<p>和 <code>ArrayList</code> 类似，在Java中，<code>Hash</code> 表的长度是有一个一个默认长度的，当负载因子超过阈值时会自动扩容，扩容同样涉及数组拷贝，哈希值计算。所以一般也需要指定初始容量。</p>
<p>所以 Java 中在创建 <code>HashMap</code> 时，会根据<code>初始容量</code>和<code>负载因子</code>来确定实际的对象数组大小。需要注意 <code>HashMap</code> 的内部实现会确保实际容量为最接近且大于或等于给定初始容量的 2 的幂次方。这样可以充分利用位运算的优势，提高哈希表的性能。</p>
<p>实际中指定初始容量后还会进行进一步的运算，例如，如果初始容量为 16，实际对象数组大小将为 16；如果初始容量为 17，实际对象数组大小将为 32（最接近且大于 17 的 2 的幂次方）。</p>
<p>计算方式通过下面的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到长度之后，通过下面的方式获取索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash_value &amp; (table_size - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到在 Java 中，这里使用了位运算，而不是之前我们讲的取模运算，</p>
<p><code>位与运算（bitwise AND）</code>和<code>取模运算（modulo operation，使用</code>%<code>符号）</code>都可以用来将哈希值映射到哈希表的索引范围内，但它们的工作原理和适用场景有所不同。</p>
<p>位与运算（bitwise AND） ，<code>当哈希表的大小是2的幂时，可以使用位与运算来计算索引，这种方法的优点是速度快，因为它只涉及一次位运算</code>。但是，它要求哈希表的大小必须是2的幂。</p>
<p>取模运算（modulo operation），取模运算可以用于任何大小的哈希表，不仅限于2的幂：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash_value % table_size</span><br></pre></td></tr></table></figure>

<p>这也是上面为什么要容量是2的幂，除法运算通常比位运算慢，位运算可以直接映射到硬件层面操作。</p>
<p>那么位运算又是如何计算出索引的？这里的原理是基于二进制的特性以及位运算的规则。</p>
<p>首先，数组的大小是 2 的幂次方，例如 16（2^4）。当数组大小为 2 的幂次方时，它的二进制表示形式中只有一个位为 1，其余位为 0。例如，16 的二进制表示为 <code>10000</code>。</p>
<p>使用按位与运算（&amp;）计算索引。</p>
<p>对哈希码和数组大小减 1（例如 15，见上面的公式）进行按位与运算时，实际上是在将哈希码的二进制表示中的高位全部置为 0，只保留低位的数值。这是因为数组大小减 1 的二进制表示形式中，所有低位都为 1，而高位都为 0。例如，15 的二进制表示为 <code>01111</code>。</p>
<p>使用上面Demo中的数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0011 1110 0110 1100 1000 0001 0011 0000(2)    1047298352(扰动前哈希值)</span><br><span class="line">0011 1110 0110 1100 1011 1111 0101 1100(2)    1047560497(扰动后哈希值 h &gt;&gt;&gt; 16)</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1111(2)    15(哈希表容量-1)</span><br><span class="line">&amp; ---------------------------------------</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0000(2)    0 (扰动前计算的索引)</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1100(2)    12(扰动后计算的索引)</span><br></pre></td></tr></table></figure>

<p>通过按位与运算，我们可以得到哈希码的低 4 位（在这个例子中），这些低 4 位就是我们要找的索引值。这个过程相当于对哈希码进行模运算（取余数），使用位运算来实现会更高效。这里也可以看到扰动函数的作用，利用高位影响低位。</p>
<p>在Java 中当哈希表的元素个数超过容量乘以加载因子（默认为0.75）时，会触发扩容，扩容会重新计算大小，扩容后的大小为。<code>newCap = oldCap &lt;&lt; 1</code> ,即左移一位，增加当前容量的一倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 如果扩容后的容量小于最大容量，并且当前容量大于等于默认初始容量</span></span><br><span class="line">        oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 将阈值也扩容为原来的两倍</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>实际上在 Java 中，，如果类实现了哈希方法，会使用自己覆盖的哈希方法，如果关键字是字符串，会使用 <code>BKDR</code> 哈希算法将其转换为自然数，再，对它进行求余，就得到了数组下标。</p>
<p>下面为 字符串类 <code>String</code> 覆写的 哈希函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>当多个不同的元素通过哈希函数生成的哈希值后计算的索引一样，就会触发哈希冲突</p>
<p>我们看一个生产的 Demo，下面为两个楼宇编码，需要批量生成每栋楼房间的锁号，这里我们通过楼宇编码生成哈希值，拼接到锁号最前面当楼宇标识。</p>
<ul>
<li><code>西辅楼</code>： RLD836092851942064128</li>
<li><code>西平房</code>： RLD836132304567926784</li>
</ul>
<p>这里我们有 8 栋楼宇，所以长度为8.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        String b1 = <span class="string">&quot;RLD836092851942064128&quot;</span>;</span><br><span class="line">        String b2 = <span class="string">&quot;RLD836132304567926784&quot;</span>;</span><br><span class="line"></span><br><span class="line">        int b1i = b1.hashCode() &amp; (8 - 1);</span><br><span class="line">        int b2i = b2.hashCode() &amp; (8 - 1);</span><br><span class="line">        System.out.println(b1.hashCode()+<span class="string">&quot;|  &quot;</span>+b1i);</span><br><span class="line">        System.out.println(b2.hashCode()+<span class="string">&quot;|  &quot;</span>+b2i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然哈希值不一样，但是算完的索引一样，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-652344316|  4</span><br><span class="line">1275548884|  4</span><br></pre></td></tr></table></figure>

<p>这两个字符串都会落到下标 4 中，这就产生了冲突。就会促发哈希冲突，解决办法一般有两种：</p>
<p><strong>链接法（Separate Chaining）</strong>：</p>
<p>落到数组同一个位置中的多个数据，通过链表串在一起。使用哈希函数查找到这个位置后，再使用链表遍历的方式查找数据。Java 中的哈希表就使用链接法解决冲突。在 Java8 之后，链表节点超过8个自动转为红黑树，小于6个会自动转为链表。</p>
<p>链表法即把冲突的元素放到一个链表里面，链表第一个元素地址放到哈希表索引的元素位置。</p>
<p>所以说最坏的情况下，即所有的元素都哈希冲突，时间复杂度为链表的时间复杂度 <code>O(n)</code>.</p>
<ul>
<li><strong>优点</strong>：<ul>
<li>实现简单，容易处理动态扩容。</li>
<li>允许负载因子大于1，能够处理更多的元素。</li>
<li>可以灵活应对哈希冲突，即使哈希表中的桶很少也能保持性能。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要额外的内存用于指针存储，因此每个桶可能需要额外的空间，这导致内存使用不连续。</li>
<li>在序列化时，指针和内存的不连续性会导致效率降低，尤其是在需要将整个哈希表序列化并存储到文件时，可能需要更多的时间来处理指针和数据结构。</li>
<li>空桶可能会浪费空间。</li>
</ul>
</li>
</ul>
<p><strong>开放寻址法</strong></p>
<p>插入时若发现对应的位置已经占用，或者查询时发现该位置上的数据与查询关键字不同，开放寻址法会按既定规则变换哈希函数（例如哈希函数设为 H(key,i)，顺序地把参数 i 加 1），计算出下一个数组下标，继续在哈希表中探查正确的位置，</p>
<ul>
<li><strong>优点</strong>：<ul>
<li>所有的元素都存储在数组中，避免了指针导致的内存不连续问题。</li>
<li>序列化效率较高，可以直接将内存中的数组映射到磁盘（如 Linux 的 <code>mmap</code> 机制），这对于大规模数据的备份非常高效。</li>
<li>操作系统的内存映射机制自动处理数据的同步，但为了保证数据一致性和准确性，可能还需要显式调用 <code>msync</code> 来确保内存内容被写入磁盘。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要考虑负载因子，如果填充太满，性能会显著下降，特别是插入和删除操作可能会退化为线性时间。</li>
<li>如果哈希表太大，扩展时可能会涉及到大量数据的重新计算和复制。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hash(key);</span><br><span class="line">        <span class="keyword">while</span> (table[index] != <span class="keyword">null</span>) &#123; <span class="comment">// 线性探测</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity; <span class="comment">// 循环处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际中可能还要做容量检测，避免死循环。在选择冲突解决策略时，需要综合考虑以下因素：</p>
<p><strong>内存使用</strong>：如果内存连续性和序列化效率是关键，开放寻址法可能更适合，尤其是在需要高效序列化的情况下。链接法虽然更灵活，但可能会因为指针和内存不连续性导致序列化和备份成本增加。</p>
<p><strong>数据大小和存储</strong>：对于大型哈希表，应该关注内存布局和存储策略，采用分块、压缩或稀疏存储等方式来优化序列化过程。</p>
<p><strong>性能和一致性</strong>：在使用内存映射等技术时，确保数据的一致性和完整性依然是关键，可能需要额外的同步操作。</p>
<h4 id="如何减少哈希冲突"><a href="#如何减少哈希冲突" class="headerlink" title="如何减少哈希冲突"></a>如何减少哈希冲突</h4><p>理论上频繁发生哈希冲突时，会直接影响时间复杂度，所以检索速度会急剧降低，通过哪些手段减少冲突概率？</p>
<ul>
<li>一是<code>调优哈希函数</code></li>
<li>二是<code>扩容</code></li>
</ul>
<p><strong>扩容</strong></p>
<p><code>装载因子（当前元素个数/数组容量）</code>越接近于 1，冲突概率就会越大。不能改变元素的数量，只能通过<code>扩容</code>提升<code>哈希桶的数量</code>，减少冲突。</p>
<p>哈希表的扩容会导致所有元素在新数组中的位置发生变化，因此必须在扩容过程中同时保留旧哈希表和新哈希表。扩容时，需要遍历旧哈希表中的所有元素，并使用新的哈希函数将它们重新放入合适的新哈希桶中。</p>
<p>上面我们讲到 <code>Java</code>  中 <code>HashMap</code> 会在数组元素个数超过数组容量的 <code>0.75</code> 进行扩容， 扩容机制与上面类似，扩容后的容量始终为 2的幂，</p>
<p>比如如何 <code>HashMap</code> 的初始容量设置为 <code>100</code>，那么扩容后的容量将按照以下公式计算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = oldCapacity * 2`</span><br></pre></td></tr></table></figure>

<p>在这种情况下，oldCapacity 是初始容量 100。但是，HashMap 的容量始终是 2 的幂次方，因此实际的初始容量会被调整为大于或等于 <code>100</code> 的最小的 2 的幂次方，即 <code>128（2^7）</code>。</p>
<p>当 <code>HashMap</code> 需要扩容时，新的容量将是当前容量的两倍。因此，如果初始容量为 128，扩容后的新容量将是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newCapacity = 128 * 2 = 256（2^8）</span><br></pre></td></tr></table></figure>

<p>所以，初始容量设置为 100，扩容后的容量将为 256。这一过程涉及大量数据操作，扩容是一个极其耗时的操作，尤其在元素数量达到亿级时。</p>
<p>所以在<code>初始化的时候制定容量</code>很有必要，会避免多次扩容，同时可以考虑其他的扩容手段，比如<code>渐进式扩容</code>和<code>双缓存技术</code>.</p>
<p><strong>调优哈希函数</strong></p>
<p>上面我们讲到 Java 中 String 类通过 BKDR 哈希算法计算哈希值，这里的 <code>31</code> 为基数，哈希函数为什么基数必须是素数，欢迎小伙伴们留言讨论 ^_^</p>
<p>它的计算量很小：<code>n*31</code> ，实际上可以通过先把 n 左移 5 位，再减去 n 的方式替换，即（<code>n*31 == n&lt;&lt;5 - n）</code>，因为理论上位运算通常比乘法运算更快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = n&lt;&lt;<span class="number">5</span> - n + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也可以在除以一个质数，这里 <code>prime</code> 是一个大质数，用于减少哈希冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BKDRHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">31</span>; <span class="comment">// 基数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIME = <span class="number">1000000007</span>; <span class="comment">// 质数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            hash = (hash * BASE + str.charAt(i)) % PRIME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>其他的哈希算法</code>，或者<code>双重哈希处理</code>，在分布式场景通过 <code>一致性哈希</code> 来处理数据的均匀分布,分散数据，降低局部密度，提交分布均匀性，减少冲突的概率。</p>
<h3 id="一致性哈希（Consistent-Hashing）算法"><a href="#一致性哈希（Consistent-Hashing）算法" class="headerlink" title="一致性哈希（Consistent Hashing）算法"></a>一致性哈希（Consistent Hashing）算法</h3><p>分布式系统中数据分布和负载均衡会经常使用一种叫 <code>一致性哈希（Consistent Hashing）</code>的技术。用于解决在<code>集群节点变化（如添加或移除节点）</code>时，如何最小化数据迁移的问题(<code>Ceph,Redis</code> )。以及在网络协议层流量负载均衡如何选择合适的后端节点(<code>haproxy</code>)。</p>
<p>一致性哈希由 <code>哈希环，数据映射，负载均衡</code> 组成</p>
<p><strong>哈希环</strong>：</p>
<p>一致性哈希将整个哈希值空间视为一个虚拟的环。每个节点（如服务器）和数据项（如缓存中的数据）都通过哈希函数映射到这个环上。</p>
<p>比如 <code>Redis Cluster</code> 将整个数据集划分为 16384 个哈希槽。每个键通过哈希函数（CRC16）计算出一个哈希值，然后对 16384 取模，得到该键对应的哈希槽。每个节点负责一部分哈希槽。</p>
<p><strong>节点和数据映射</strong>：</p>
<p>节点和数据项都被哈希到这个环上。数据项被存储在顺时针方向的第一个节点上。例如，如果数据项 <code>A</code> 被哈希到位置 <code>x</code>，而节点 <code>N1</code> 在 <code>x</code> 的顺时针方向上，那么 <code>A</code> 就存储在 <code>N1</code> 上。</p>
<p><strong>负载均衡</strong>：</p>
<p>通过将数据均匀地分布在环上，可以实现负载均衡。即使添加或删除节点，也只会影响到少量数据项的迁移。总体的哈希容量不变，所以计算完的哈希值不会变，只是对 Hash 空间细划。</p>
<p><strong>一致性哈希的优势</strong></p>
<p><strong>最小化数据迁移</strong>：当节点加入或离开时，只需重新映射少量数据项，而不是重新分配所有数据。这使得系统在扩展或缩减时更为高效。</p>
<p><strong>动态扩展</strong>：系统可以在不影响现有数据的情况下动态扩展，增加新的节点或移除旧的节点。</p>
<ul>
<li>当需要增加新的节点时，只需要将新节点插入到环中的适当位置，并将原节点的一部分数据（即一部分哈希空间）迁移到新节点上。</li>
<li>同样地，当需要移除节点时，该节点负责的数据可以迁移到其顺时针方向的下游节点上</li>
</ul>
<p><strong>容错性</strong>：一致性哈希能够容忍节点的故障，数据可以在节点故障后快速恢复。</p>
<p>实现步骤</p>
<ol>
<li><strong>选择哈希函数</strong>：选择一个合适的哈希函数，将节点和数据项映射到哈希环上。</li>
<li><strong>构建哈希环</strong>：使用哈希函数生成节点和数据项的哈希值，并将它们放置在环上。</li>
<li><strong>数据存储</strong>：当存储数据时，计算数据项的哈希值，并在环上找到顺时针方向的第一个节点，将数据存储在该节点上。</li>
<li><strong>节点变动</strong>：当节点加入或离开时，重新计算受影响的数据项，进行必要的迁移。</li>
</ol>
<p>以下是一个简单的一致性哈希的 Python 示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashing</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ring = &#123;&#125; <span class="comment">#键和节点的映射</span></span><br><span class="line">        self.sorted_keys = [] <span class="comment"># 哈希环，于存储已经排序好的哈希键值</span></span><br><span class="line">        self.nodes_with_weights = &#123;&#125;  <span class="comment"># 用于存储节点及其权重信息</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_hash</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        对给定的键进行哈希处理，返回一个整数形式的哈希值。</span></span><br><span class="line"><span class="string">        :param key: 要进行哈希的键，可以是节点名称或者数据项名称等。</span></span><br><span class="line"><span class="string">        :return: 整数形式的哈希值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(hashlib.md5(key.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node, weight=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        向哈希环中添加一个节点。</span></span><br><span class="line"><span class="string">        :param node: 要添加的节点名称。</span></span><br><span class="line"><span class="string">        :param weight: 节点的权重，默认为1，权重越高，在哈希环上对应的副本数量越多。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        replicas = weight * <span class="number">3</span>  <span class="comment"># 简单根据权重设定副本数量，这里可根据实际需求调整倍数关系</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(replicas):</span><br><span class="line">            key = <span class="string">f&quot;<span class="subst">&#123;node&#125;</span>:<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            hashed_key = self._<span class="built_in">hash</span>(key)</span><br><span class="line">            self.ring[hashed_key] = node</span><br><span class="line">            self.sorted_keys.append(hashed_key)</span><br><span class="line">        self.nodes_with_weights[node] = weight</span><br><span class="line">        self.sorted_keys.sort()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从哈希环中删除一个节点。</span></span><br><span class="line"><span class="string">        :param node: 要删除的节点名称。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        weight = self.nodes_with_weights.get(node, <span class="number">1</span>)</span><br><span class="line">        replicas = weight * <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(replicas):</span><br><span class="line">            key = <span class="string">f&quot;<span class="subst">&#123;node&#125;</span>:<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">            hashed_key = self._<span class="built_in">hash</span>(key)</span><br><span class="line">            <span class="keyword">del</span> self.ring[hashed_key]</span><br><span class="line">            self.sorted_keys.remove(hashed_key)</span><br><span class="line">        <span class="keyword">del</span> self.nodes_with_weights[node]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        确定一个数据项应该映射到哪个节点上。</span></span><br><span class="line"><span class="string">        :param key: 数据项的名称。</span></span><br><span class="line"><span class="string">        :return: 数据项映射到的节点名称，如果哈希环为空则返回 None。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.ring:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        hashed_key = self._<span class="built_in">hash</span>(key)</span><br><span class="line">        <span class="keyword">for</span> node_key <span class="keyword">in</span> self.sorted_keys:</span><br><span class="line">            <span class="keyword">if</span> hashed_key &lt;= node_key:</span><br><span class="line">                <span class="keyword">return</span> self.ring[node_key]</span><br><span class="line">        <span class="comment"># 将数据项映射到了哈希环上第一个节点（按照哈希值从小到大排序后的第一个节点）        </span></span><br><span class="line">        <span class="keyword">return</span> self.ring[self.sorted_keys[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ch = ConsistentHashing()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加节点及设置不同权重</span></span><br><span class="line">    ch.add_node(<span class="string">&#x27;Node1&#x27;</span>, weight=<span class="number">1</span>)</span><br><span class="line">    ch.add_node(<span class="string">&#x27;Node2&#x27;</span>, weight=<span class="number">2</span>)</span><br><span class="line">    ch.add_node(<span class="string">&#x27;Node3&#x27;</span>, weight=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    data_items = [<span class="string">&#x27;data1&#x27;</span>, <span class="string">&#x27;data2&#x27;</span>, <span class="string">&#x27;data3&#x27;</span>, <span class="string">&#x27;data4&#x27;</span>, <span class="string">&#x27;data5&#x27;</span>, <span class="string">&#x27;data6&#x27;</span>, <span class="string">&#x27;data7&#x27;</span>, <span class="string">&#x27;data8&#x27;</span>, <span class="string">&#x27;data9&#x27;</span>, <span class="string">&#x27;data10&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data_items:</span><br><span class="line">        node = ch.get_node(item)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;item&#125;</span> 映射到的节点: <span class="subst">&#123;node&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟删除一个节点</span></span><br><span class="line">    ch.remove_node(<span class="string">&#x27;Node2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;删除Node2后:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data_items:</span><br><span class="line">        node = ch.get_node(item)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;item&#125;</span> 映射到的节点: <span class="subst">&#123;node&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果，可以看到删除 Node2 之后，Node3 和 Node1 之前映射的数据并有没有改变，只是原来Node2 的数据被映射到了 Node3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">data1 映射到的节点: Node3</span><br><span class="line">data2 映射到的节点: Node1</span><br><span class="line">data3 映射到的节点: Node3</span><br><span class="line">data4 映射到的节点: Node3</span><br><span class="line">data5 映射到的节点: Node1</span><br><span class="line">data6 映射到的节点: Node3</span><br><span class="line">data7 映射到的节点: Node2</span><br><span class="line">data8 映射到的节点: Node1</span><br><span class="line">data9 映射到的节点: Node1</span><br><span class="line">data10 映射到的节点: Node2</span><br><span class="line">删除Node2后:</span><br><span class="line">data1 映射到的节点: Node3</span><br><span class="line">data2 映射到的节点: Node1</span><br><span class="line">data3 映射到的节点: Node3</span><br><span class="line">data4 映射到的节点: Node3</span><br><span class="line">data5 映射到的节点: Node1</span><br><span class="line">data6 映射到的节点: Node3</span><br><span class="line">data7 映射到的节点: Node3</span><br><span class="line">data8 映射到的节点: Node1</span><br><span class="line">data9 映射到的节点: Node1</span><br><span class="line">data10 映射到的节点: Node3</span><br></pre></td></tr></table></figure>



<h2 id="博文部分内容参考"><a href="#博文部分内容参考" class="headerlink" title="博文部分内容参考"></a>博文部分内容参考</h2><p>© 文中涉及参考链接内容版权归原作者所有，如有侵权请告知 :)</p>
<hr>
<hr>
<p>© 2018-至今 <a href="mailto:&#x6c;&#x69;&#114;&#x75;&#105;&#x6c;&#x6f;&#x6e;&#x67;&#101;&#114;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x6c;&#x69;&#114;&#x75;&#105;&#x6c;&#x6f;&#x6e;&#x67;&#101;&#114;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a>, All rights reserved. 保持署名-非商用-相同方式共享(CC BY-NC-SA 4.0)</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>为什么都用哈希,Hash 表的时间复杂度为什么是 O(1)？</p><p><a href="https://liruilongs.github.io/2024/11/02/待发布/为什么都用哈希，哈希表的复杂度为啥是O(1)/">https://liruilongs.github.io/2024/11/02/待发布/为什么都用哈希，哈希表的复杂度为啥是O(1)/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-11-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-11-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2022/11/19/Git/%E5%85%B3%E4%BA%8E-Git-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于 Git 重写历史的一些笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/08/02/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支变基操作的一些笔记</a><br></span><span>  4.<a class="is-size-6" href="/2022/07/26/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支基础知识的一些笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/02/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支工作流的一些笔记</a><br></span><span>  6.<a class="is-size-6" href="/2023/02/19/Git/%E5%85%B3%E4%BA%8EGit%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" target="_blank">关于Git分支高级合并的一些笔记整理</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/12/04/%E5%BE%85%E5%8F%91%E5%B8%83/MySQL%20%E8%B4%A6%E5%8F%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL 账号和权限管理笔记整理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/10/24/%E5%BE%85%E5%8F%91%E5%B8%83/openEuler-24-03-LTS-Mysql-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85/"><span class="level-item">openEuler 24.03 (LTS) Mysql 二进制安装</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '42d1fed0b8b745863395d80cbec05504',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#Hash-表的时间复杂度为什么是-O-1"><span class="mr-2">2</span><span>Hash 表的时间复杂度为什么是 O(1)</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#数组"><span class="mr-2">2.1</span><span>数组</span></a></li><li><a class="is-flex is-mobile" href="#Hash-表"><span class="mr-2">2.2</span><span>Hash 表</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#索引计算"><span class="mr-2">2.2.1</span><span>索引计算</span></a></li><li><a class="is-flex is-mobile" href="#长度计算"><span class="mr-2">2.2.2</span><span>长度计算</span></a></li><li><a class="is-flex is-mobile" href="#哈希冲突"><span class="mr-2">2.2.3</span><span>哈希冲突</span></a></li><li><a class="is-flex is-mobile" href="#如何减少哈希冲突"><span class="mr-2">2.2.4</span><span>如何减少哈希冲突</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#一致性哈希（Consistent-Hashing）算法"><span class="mr-2">2.3</span><span>一致性哈希（Consistent Hashing）算法</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#博文部分内容参考"><span class="mr-2">3</span><span>博文部分内容参考</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">421</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">138</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">186</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-10T03:06:02.000Z">2025-02-10</time></p><p class="title"><a href="/2025/02/10/%E5%BE%85%E5%8F%91%E5%B8%83/xxl-job-%E6%BC%8F%E6%B4%9E%E9%97%AE%E9%A2%98%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95/">xxl-job 漏洞问题版本升级记录</a></p><p class="categories"><a href="/categories/xxl-job/">xxl-job</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-06T07:06:00.000Z">2025-02-06</time></p><p class="title"><a href="/2025/02/06/%E5%BE%85%E5%8F%91%E5%B8%83/SpringBoot%20%E6%8E%A5%E5%8F%A3%E5%86%85%E5%AE%B9%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88(RSA+AES+HMAC%E6%A0%A1%E9%AA%8C)%E8%AE%A4%E7%9F%A5/">SpringBoot 接口内容加密方案(RSA+AES+HMAC校验)认知</a></p><p class="categories"><a href="/categories/RSA/">RSA</a> / <a href="/categories/RSA/AES/">AES</a> / <a href="/categories/RSA/AES/HMAC/">HMAC</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-02T05:32:31.000Z">2025-02-02</time></p><p class="title"><a href="/2025/02/02/%E5%BE%85%E5%8F%91%E5%B8%83/DeepSeek%20%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5(V3%E3%80%81R1%E3%80%81Janus%E3%80%81VL2%20%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2)/">DeepSeek 大模型基本认知(V3、R1、Janus、VL2 简单介绍以及本地部署)</a></p><p class="categories"><a href="/categories/DeepSeek/">DeepSeek</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-26T07:09:03.000Z">2025-01-26</time></p><p class="title"><a href="/2025/01/26/%E5%BE%85%E5%8F%91%E5%B8%83/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%87%E6%9C%AC%E6%B5%81%E5%A6%82%E4%BD%95%E6%8C%81%E7%BB%AD%E5%90%90%E5%88%B0%E5%89%8D%E7%AB%AF%EF%BC%8CBS%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%8A%80%E6%9C%AF%20SSE(Server-Sent%20Events)%20%E8%AE%A4%E7%9F%A5/">AI大模型的文本流如何持续吐到前端，服务端实时通信技术 SSE(Server-Sent Events) 认知</a></p><p class="categories"><a href="/categories/SSE/">SSE</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-13T03:55:24.000Z">2025-01-13</time></p><p class="title"><a href="/2025/01/13/%E5%BE%85%E5%8F%91%E5%B8%83/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E8%AE%A4%E7%9F%A5-Twitter-Snowflake/">雪花算法认知(Twitter_Snowflake)</a></p><p class="categories"><a href="/categories/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/">雪花算法</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AIGC/"><span class="level-start"><span class="level-item">AIGC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/BPF/"><span class="level-start"><span class="level-item">BPF</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">98</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"><span class="tag">华为云</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BPF/"><span class="tag">BPF</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mysql/"><span class="tag">Mysql</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%BD%B1%E6%9B%9D%E5%85%89/"><span class="tag">摄影曝光</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%B9%E5%99%A8/"><span class="tag">容器</span><span class="tag is-grey-lightest">4</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2025 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案中</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>