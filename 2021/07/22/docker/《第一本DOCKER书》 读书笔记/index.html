<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="google-adsense-account" content="ca-pub-5805170532312625"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《第一本Docker书》 读书笔记 - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="在我看来，春天里一棵小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身。我要抱着草长马发情的伟大真诚去做一切事，而不是在人前差羞答答的表演。在我看来，人都是为了要表演，失去了自己的存在。——王小波《三十而立》"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="在我看来，春天里一棵小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身。我要抱着草长马发情的伟大真诚去做一切事，而不是在人前差羞答答的表演。在我看来，人都是为了要表演，失去了自己的存在。——王小波《三十而立》"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mp.weixin.qq.com/img/头像.jpg"><meta property="article:published_time" content="2021-07-22T11:57:14.000Z"><meta property="article:modified_time" content="2023-06-21T11:25:59.118Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="Docker"><meta property="article:tag" content="容器"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2021/07/22/docker/%E3%80%8A%E7%AC%AC%E4%B8%80%E6%9C%ACDOCKER%E4%B9%A6%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"headline":"山河已无恙","image":["https://img-blog.csdnimg.cn/4ffda39b2fb949128d45b1e66b64e8b8.png","https://img-blog.csdnimg.cn/d60b581899cf498fae5d51b4495abbc1.png","https://img-blog.csdnimg.cn/75fed2bed3e14f65a16e8ee0035399a9.png"],"datePublished":"2021-07-22T11:57:14.000Z","dateModified":"2023-06-21T11:25:59.118Z","author":{"@type":"Person","name":"山河已无恙"},"description":"在我看来，春天里一棵小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身。我要抱着草长马发情的伟大真诚去做一切事，而不是在人前差羞答答的表演。在我看来，人都是为了要表演，失去了自己的存在。——王小波《三十而立》"}</script><link rel="canonical" href="https://liruilongs.github.io/2021/07/22/docker/%E3%80%8A%E7%AC%AC%E4%B8%80%E6%9C%ACDOCKER%E4%B9%A6%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2021-07-22  <a class="commentCountImg" href="/2021/07/22/docker/%E3%80%8A%E7%AC%AC%E4%B8%80%E6%9C%ACDOCKER%E4%B9%A6%E3%80%8B%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">db890a664ab4e341c613efb70671496d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="db890a664ab4e341c613efb70671496d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 小时  <i class="fas fa-pencil-alt"> </i>23.8 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《第一本Docker书》 读书笔记</h1><div class="content"><p><strong><font color="009688">在我看来，春天里一棵小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身。我要抱着草长马发情的伟大真诚去做一切事，而不是在人前差羞答答的表演。在我看来，人都是为了要表演，失去了自己的存在。——王小波《三十而立》</font></strong></p>
<span id="more"></span>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><hr>
<ul>
<li>一个之前的项目要去Oracle用teleDB上云。所以需要改好了sql，重新搞一下。拉一个Docker镜像部署一下。</li>
<li>dokcer没有系统的学习，之前都是应急，同时比较容易上手，所以都是简单学习。</li>
<li>博文主要是《第一本Docker书》的一些读书笔记，基本是书里的东西，部分没有摘的内容，小伙伴可以移步：<a target="_blank" rel="noopener" href="https://liruilong.blog.csdn.net/article/details/114435587">Docker、Podman 容器“扫盲“ 学习笔记</a></li>
</ul>
<p><strong><font color="009688">在我看来，春天里一棵小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身。我要抱着草长马发情的伟大真诚去做一切事，而不是在人前差羞答答的表演。在我看来，人都是为了要表演，失去了自己的存在。——王小波《三十而立》</font></strong></p>
<h1 id="第1章简介"><a href="#第1章简介" class="headerlink" title="第1章简介"></a>第1章<font color=seagreen>简介</font></h1><blockquote>
<p><code>容器</code>与<code>管理程序虚拟化(hypervisorvirtualization, HV)</code>的不同.</p>
</blockquote>
<ul>
<li><code>管理程序虚拟化</code>即常说的虚拟机:通过<code>中间层</code>将<font color=seagreen>一台或多台独立的机器</font>虚拟运行于<code>物理硬件之上</code>.</li>
<li><code>容器</code>则是直接运行在<code>操作系统内核之上</code>的<code>用户空间</code>。因此,容器虚拟化也被称为“<code>操作系统级虚拟化</code>”,容器技术可以让多个独立的<code>用户空间</code>运行在<code>同一台宿主机</code>上。由于“<code>客居</code>”于操作系统,<code>容器只能运行与底层宿主机相同或相似的操作系统</code>。这看起来并不是非常灵活。<font color=brown>例如,可以在<code>Ubuntu</code>服务器中运行<code>RedHat Enterprise Linux</code>,但却无法在<code>Ubuntu</code>服务器上运行<code>Microsoft Windows</code>.</font></li>
</ul>
<p>相对于彻底隔离的<code>管理程序虚拟化</code>,<code>容器</code>被认为是不安全的。而反对这一观点的人则认为,由于<code>虚拟机</code>所虚拟的是一个<code>完整的操作系统</code>,这无疑增大了<code>攻击范围</code>,而且还要考虑管理程序层潜在的暴露风险。</p>
<blockquote>
<p>尽管有诸多局限性,容器还是被广泛部署于各种各样的应用场合。在超大规模的多租户服务部署、轻量级沙盒以及对安全要求不太高的隔离环境中,容器技术非常流行。</p>
</blockquote>
<ul>
<li>最常见的一个例子就是“<code>权限隔离监牢</code>“ (chroot jail),它创建一个隔离的目录环境来运行进程。<code>如果权限隔离监牢中正在运行的进程被入侵者攻破,入侵者便会发现自己“身陷图围&quot;,因为权限不足被困在容器创建的目录中,无法对宿主机进行进一步的破坏</code>。</li>
</ul>
<p>最新的容器技术引入了<code>OpenVZ, Solaris Zones</code>以及<code>Linux容器(如lxc)</code>。使用这些新技术,容器不再仅仅是一个单纯的运行环境。在自己的权限范围内,容器更像是一个完整的宿主机。对<code>Docker</code>来说,它得益于现代Linux内核特性,<code>如控件组(control group)、命名空间(namespace)技术</code>,容器和宿主机之间的<code>隔离</code>更加彻底,<code>容器有独立的网络和存储栈,还拥有自己的资源管理能力</code>,使得同一台宿主机中的多个容器可以友好地共存。</p>
<h3 id="1-1-Docker简介"><a href="#1-1-Docker简介" class="headerlink" title="1.1 Docker简介"></a>1.1 <font color=red>Docker简介</font></h3><p><code>Docker</code>是一个能够把开发的<code>应用程序自动部署</code>到<code>容器</code>的<code>开源引擎</code>。由<code>Docker</code>公司. (<a target="_blank" rel="noopener" href="http://www.docke.com,前dotcloud公司/">www.docke.com,前dotCloud公司</a>, Paas市场中的老牌提供商)的团队编写,基于Apache .2.0开源授权协议发行。</p>
<h4 id="1-1-1-提供一个简单、轻量的建模方式"><a href="#1-1-1-提供一个简单、轻量的建模方式" class="headerlink" title="1.1.1 提供一个简单、轻量的建模方式"></a>1.1.1 <font color=camel>提供一个简单、轻量的建模方式</font></h4><p><code>Docker</code>依赖于“<code>写时复制&quot; (copy-on-write)</code>模型,Docker容器拥有很高的性能,同时同一台宿主机中也可以运行更多的容器,使用户可以尽可能充分地利用系统资源。</p>
<h4 id="1-1-2-职责的逻辑分离"><a href="#1-1-2-职责的逻辑分离" class="headerlink" title="1.1.2 职责的逻辑分离"></a>1.1.2 <font color=seagreen>职责的逻辑分离</font></h4><p>使用<code>Docker</code>,<code>开发人员</code>只需要关心容器运行的<code>应用程序</code>,而<code>运维人员</code>只需心如何<code>管理容器</code>。Docker <strong><font color=amber>设计的目的</font></strong> ，就是要 <strong><font color=plum>加强开发人员写代码的开发环境与应用程序要部署的生产环境的一致性</font></strong>,从而降低那种“开发时一切都正常,肯定是运维的问题”的风险。</p>
<h4 id="1-1-3-快速、高效的开发生命周期"><a href="#1-1-3-快速、高效的开发生命周期" class="headerlink" title="1.1.3 快速、高效的开发生命周期"></a>1.1.3 <font color=seagreen>快速、高效的开发生命周期</font></h4><p>Docker的目标之一就是开发、到署、测试到部、上线运行的周期,让你的应用程序具备<code>可移植性,易于构建,并易于协作</code>。 </p>
<h4 id="1-1-4-鼓励使用面向服务的架构"><a href="#1-1-4-鼓励使用面向服务的架构" class="headerlink" title="1.1.4 鼓励使用面向服务的架构"></a>1.1.4 <font color=camel>鼓励使用面向服务的架构</font></h4><ul>
<li>Docker还鼓励<font color=blue>面向服务的架构和微服务架构</font>。. </li>
<li>Docker推荐<font color=tomato>单个容器只运行一个应程序或进程</font>,这样就形成了一个<code>分布式的应用程序模型</code>,在这种模型下,应用程序或服务都可以表示为<code>一系列内部互联的容器</code>,从而使分布式部署应用程序,扩展或调试应用程序都变得-非常<code>简单</code>,同时也提高了程序的<code>内省性</code>。</li>
</ul>
<h3 id="1-2-Docker组件"><a href="#1-2-Docker组件" class="headerlink" title="1.2 Docker组件"></a>1.2 <font color=camel>Docker组件</font></h3><p><strong><font color=orange>Docker客户端和服务器,也成为Docker引擎;、Docker镜像;、Registry;、Docker容器。</font></strong></p>
<h4 id="1-2-1-Docker客户端和服务器"><a href="#1-2-1-Docker客户端和服务器" class="headerlink" title="1.2.1 Docker客户端和服务器"></a>1.2.1 <font color=amber>Docker客户端和服务器</font></h4><ul>
<li>Docker是一个客户端&#x2F;服务器(C&#x2F;S)架构的程序。</li>
<li>Docker客户端只需向Docker服务器”或守护进程发出请求,服务器或守护进程将完成所有工作并返回结果。</li>
<li>Docker守护进程有时也称为Docker引擎。</li>
<li>Docker提供了一个命令行工具docker以及一整套RESTful API来与守护进程交互</li>
</ul>
<h4 id="1-2-2-Docker镜像"><a href="#1-2-2-Docker镜像" class="headerlink" title="1.2.2 Docker镜像"></a>1.2.2 <font color=green>Docker镜像</font></h4><p>镜像是构建Docker世界的基石。**<font color=green>用户基于镜像来运行自己的容器</font>**。<br>镜像也是<code>Docker</code>生命周期的 **<font color=green>“构建”部分</font>**。镜像是基于<code>联合(Union)文件系统</code>一种层式的结构,)由一系列指令一步一步构建出来。例如:+ 添加一个文件;</p>
<ul>
<li>执行一个命令:</li>
<li>打开一个端口。<br>也可以把镜像当作 **<font color=chocolate>容器的“源代码”</font>**。镜像体积很小,非常“便携”,易于分享、存储和</li>
</ul>
<h4 id="1-2-3-Registry"><a href="#1-2-3-Registry" class="headerlink" title="1.2.3 Registry"></a>1.2.3 <font color=royalblue>Registry</font></h4><p><code>Docker</code>用Registry来保存用户构建的镜像。Begisty共和私有两种。<br><code>Docker</code>公司运营的公共Registry 叫作Docker Hub。</p>
<h4 id="1-2-4-容器"><a href="#1-2-4-容器" class="headerlink" title="1.2.4 容器"></a>1.2.4 <font color=brown>容器</font></h4><blockquote>
<p><code>Docker</code>可以帮<code>用户构建和部署容器</code>,用户只需要把<code>自己的应用程序或服务打包放进容器</code>即可。</p>
</blockquote>
<p>容器是基于镜像启动起来的,容器中可以运一个进程。我们可以认为,<strong><font color=purple>镜像是<code>Docker</code>生命周期中的构建或打包阶段</font></strong>,而 **<font color=orange>容器则是启动或执行阶段</font>**。总结起来, <code>Docker</code>容器就是:</p>
<ul>
<li>一个镜像格式;·</li>
<li>一系列标准的操作;</li>
<li>一个执行环境。</li>
</ul>
<blockquote>
<p>&#x3D;&#x3D;Dokeer借鉴了 **<font color=orange>标准集装箱</font>**的概念。标准集装箱将货物运往世界各地, <code>Docker</code>将这个模型运用到自己的设计哲学中,唯一不同的是:<code>集装箱运输货物</code>,而<code>Docker</code>运输软件。每个容器都包含一个软件镜像,也就是容器的“货物”,而且与真正的货物一样,容器里的软件镜像可以进行一些操作，,镜像可以被创建启动、关闭&#x3D;&#x3D;</p>
</blockquote>
<p>像标准集装箱一样, <code>Docker</code>容器方便替换,可以叠加,易于分发,并且尽量通用。使用<code>Docker</code>,可以快速构建一个应用程序服务器、一个消息总线、一套实用工具、持续集成( continuous integration, CI)测试环境或者任意一种应用程序、服务或工其。以在本地构建一个完整的测试环境,也可以为生产或开发快速复制一套复杂的应用程序可以说。</p>
<h3 id="1-3-能用Docker做什么"><a href="#1-3-能用Docker做什么" class="headerlink" title="1.3 能用Docker做什么"></a>1.3 <font color=amber>能用<code>Docker</code>做什么</font></h3><ul>
<li>加速本地开发和构建流程,使其更加高效、更加轻量化。本地开发人员可以构建、运行并分享<code>Docker</code>容器。容器可以在开发环境中构建,然后轻松地提交到测试环境中,并最终进入生产环境,</li>
<li>能够让独立服务或应用程序在不同的环境中,得到相同的运行结果。这一点在面向服务的架构和重度依赖微型服务的部署中尤其实用。</li>
<li>用<code>Docker</code>创建隔离的环境来进行测试。例如,用Jenkins CI这样的持续集成工具启动一个用于测试的容器。</li>
<li><code>Docker</code>可以让开发者先在本机上构建一个复杂的程序或架构来进行测试,而不是一开始就在生产环境部署、测试。</li>
<li>构建一个多用户的平台即服务(Paas)基础设施。</li>
<li>为开发、测试提供一个轻量级的独立沙盒环境,或者将独立的沙盒环境用于技术教学,如Unix shell的使用、编程语言教学。 </li>
<li>提供软件即服务(Saas)应用程序。</li>
<li>高性能、超大规模的宿主机部署。</li>
</ul>
<h3 id="1-4-Docker与配置管理"><a href="#1-4-Docker与配置管理" class="headerlink" title="1.4 Docker与配置管理"></a>1.4 <font color=seagreen><code>Docker</code>与配置管理</font></h3><p><code>Docker</code>一个显著的特点就是,对不同的宿主机、应用程序和服务,可能会表现出不同的特性与架构(或者确切地说, <code>Docker</code>本就是被设计成这样的): </p>
<p><code>Docker</code>可以是<font color=green>短生命周期</font>的,但也可以用于恒定的环境,可以用一次即销毁,也可以提供持久的服务。这些行为并不会给<code>Docker</code>增加复杂性,也不会和配置管理工具的需求产生重合。基于这些行为,我们基本不需要担心管理状态的挂状态复杂性,因为容器的生命周期往往比较短,而且重建容器状态的代价通常也比传统的状态修复要低。 </p>
<h3 id="1-5-Docker的技术组件"><a href="#1-5-Docker的技术组件" class="headerlink" title="1.5 Docker的技术组件"></a>1.5 <font color=yellowgreen><code>Docker</code>的技术组件</font></h3><p><code>Docker</code>可以运行于在何安装了Linux内核的x64主机上。推荐的内核版是3.8或者更高。<code>Docker</code>的开销比,可以用于服务器、台式机或笔记本。包括以下；</p>
<ul>
<li><code>一个原生的Linux容器格式</code>, <code>Docker</code>中称为1ibcontainer.</li>
<li><code>Linxu内核的命名空间(namespace) </code>“,用于隔离文件系统、进程和网络。</li>
<li><code>文件系统隔离</code>:每个容器都有自己的root文件系统。</li>
<li><code>进程隔离</code>:每个容器都运行在自己的进程环境中。</li>
<li><code>网络隔离</code>:容器间的虚拟网络接口和IP地址都是分开的。</li>
<li><code>资源隔离和分组</code>:使用cgroups” (即control group, Linux的内核特性之一)将CPU和内存之类的资源独立分配给每个<code>Docker</code>容器。</li>
<li><code>写时复制</code>:文件系统都是通过写时复制创建的,这就意味着文件系统是分层的、快速的,而且占用的磁盘空间更小。</li>
<li><code>日志</code>:容器产生的STDOUT, STDERR和STDIN这些io流都会被收集并记入日志,用来进行日志分析和故障排错。交</li>
<li><code>交互式shell</code>:用户可以创建一个伪tty终端,将其连接到STDIN,为容器提供一个交互式的shell.</li>
</ul>
<h3 id="1-7-Docker资源"><a href="#1-7-Docker资源" class="headerlink" title="1.7 Docker资源"></a>1.7 <font color=blue><code>Docker</code>资源</font></h3><blockquote>
<p>Docker官方主页(<a target="_blank" rel="noopener" href="http://www.docker.com/">http://www.docker.com/</a>)<br>Docker Hub (http:&#x2F;hub.docker.com)<br>Docker官方博客(<a target="_blank" rel="noopener" href="http://blog.docker.com/">http://blog.docker.com/</a>)<br>Docker官方文档(<a target="_blank" rel="noopener" href="http://docs.docker.com/)%E3%80%82">http://docs.docker.com/)。</a><br>Docker快速入门指南(<a target="_blank" rel="noopener" href="http://www.docker.com/tryit/">http://www.docker.com/tryit/</a>)<br>Docker的GitHub源代码(<a target="_blank" rel="noopener" href="https://github.com/docker/docker)&quot;">https://github.com/docker/docker)&quot;</a><br>Docker Forge (<a target="_blank" rel="noopener" href="https://github.com/dockerforge">https://github.com/dockerforge</a>):</p>
</blockquote>
<blockquote>
<p>收集了各种Docker工具、组件和服务。<br>Docker邮件列表(<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/docker-user">https://groups.google.com/forum/#!forum/docker-user</a>)<br>Docker的IRC频道(irc.freenode.net)<br>Docker的Twitter主页(<a target="_blank" rel="noopener" href="http://twitter.com/docker">http://twitter.com/docker</a>)<br>Docker的StackOverflow问答主页(<a target="_blank" rel="noopener" href="http://stackoverflow.com/search%EF%BC%9Fq-docker">http://stackoverflow.com/search？q-docker</a>).<br>Docker官网(<a target="_blank" rel="noopener" href="http://www.docker.com/">http://www.docker.com/</a>) </p>
</blockquote>
<h1 id="第2章安装Docker"><a href="#第2章安装Docker" class="headerlink" title="第2章安装Docker"></a><font color=plum>第2章安装<code>Docker</code></font></h1><h3 id="Docker用户界面"><a href="#Docker用户界面" class="headerlink" title="Docker用户界面"></a><font color=green><code>Docker</code>用户界面</font></h3><p><code>Shipyard</code>: Shipyard提供了通过管理界面来管理各种<code>Docker</code>资源(包括容器、镜像、宿主机等)的功能。Shipyard是开源的,源代码可以在<a target="_blank" rel="noopener" href="https://github.com/ehazlett/shipyard%E8%8E%B7%E5%BE%97pockerUl">https://github.com/ehazlett/shipyard获得pockerUl</a>:<br><code>DpckerUI</code>是一个可以与Docker Remote API交互的Web界面。DockerUI是基于AngulaJS框架,采用JavaScript编写的。<br><code>Kitematic</code>: Kitematic是一个OS X和Windows下的GUI界面工具,用于帮助我们在本地运行<code>Docker</code>以及与Docker Hub进行交互。它是由Docker公司免费发布的产品,也被包含在Docker Toolbox之中。 </p>
<h1 id="第3章Docker入门"><a href="#第3章Docker入门" class="headerlink" title="第3章Docker入门"></a><font color=orange>第3章<code>Docker</code>入门</font></h1><h3 id="3-1确保Docker已经就绪"><a href="#3-1确保Docker已经就绪" class="headerlink" title="3.1确保Docker已经就绪"></a>3.1<font color=camel>确保<code>Docker</code>已经就绪</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># docker info</span></span><br><span class="line">Containers: 4</span><br><span class="line"> Running: 2</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 2</span><br><span class="line">Images: 3</span><br><span class="line">Server Version: 1.13.1</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: <span class="literal">true</span></span><br><span class="line"> Native Overlay Diff: <span class="literal">true</span></span><br><span class="line">Logging Driver: journald</span><br><span class="line">Cgroup Driver: systemd</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: <span class="built_in">local</span></span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: docker-runc runc</span><br><span class="line">Default Runtime: docker-runc</span><br><span class="line">Init Binary: /usr/libexec/docker/docker-init-current</span><br><span class="line">containerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)</span><br></pre></td></tr></table></figure>

<h3 id="3-2运行我们的第一个容器"><a href="#3-2运行我们的第一个容器" class="headerlink" title="3.2运行我们的第一个容器"></a>3.2<font color=brown>运行我们的第一个容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/rabbitmq             management          485c275e2364        5 weeks ago         252 MB</span><br><span class="line">docker.io/nginx                latest              35c43ace9216        5 months ago        133 MB</span><br><span class="line">docker.io/mamohr/centos-java   latest              e041132b8b32        3 years ago         577 MB</span><br><span class="line">[root@liruilong ~]<span class="comment"># docker run -i -t e041132b8b32 /bin/bash</span></span><br><span class="line">[root@899c72cacb59 /]<span class="comment"># ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@899c72cacb59 /]<span class="comment"># uname</span></span><br><span class="line">Linux</span><br><span class="line">[root@899c72cacb59 /]<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-i</code>标志保证容器中STDIN是开启的,尽管我们并没有附着到容器中。持久的标准输入是交互式shell的半边天。</li>
<li><code>-t</code>标志则是另外,它docker为要创建的容器分配·一个伪tty终端。这样,新创建的容器才能提供一个交互式shell.若要在命令行下创建一个,我们能与之进行交互的容器,而不是一个运行后台服务的容器,则这两个参数已经是最基本的参数了。</li>
</ul>
<p><code>Docker会检查本地是否是存在镜像,如果本地还没有该镜像的话,那么Docker就会连接官方维护的DotrHub Rggistry,查看Docker Hub中是否有该镜像</code>。Docker一旦找到该镜像,就下载镜像并将共保存到本地宿主机中。</p>
<p>Docker在文件系统内部用这个镜像创全新容器。该容器拥有自己的网络IP地址&#x2F;以及一个用来和宿主机进行通信 桥接网络接口。最后,我们告诉Docker在新容器中要运行什么命令,在本例中我们在容器行&#x2F;bin&#x2F;bash命令启动了一个Bash shell.  </p>
<h3 id="3-3使用第一个容器"><a href="#3-3使用第一个容器" class="headerlink" title="3.3使用第一个容器"></a>3.3<font color=purple>使用第一个容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># docker run -i -t e041132b8b32 /bin/bash</span></span><br><span class="line">[root@e98c71f36f2d /]<span class="comment"># hostname</span></span><br><span class="line">e98c71f36f2d</span><br><span class="line">[root@e98c71f36f2d /]<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.18.0.5      e98c71f36f2d</span><br><span class="line">[root@e98c71f36f2d /]<span class="comment"># yum provides ifconfig</span></span><br><span class="line">Loaded plugins: fastestmirror, ovl</span><br><span class="line">base                                                                                             | 3.6 kB  00:00:00</span><br><span class="line">extras                                                                                           | 2.9 kB  00:00:00</span><br><span class="line">updates                                                                                          | 2.9 kB  00:00:00</span><br><span class="line">。。。。。。</span><br><span class="line">net-tools-2.0-0.25.20131004git.el7.x86_64 : Basic networking tools</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /sbin/ifconfig</span><br><span class="line"></span><br><span class="line">[root@e98c71f36f2d /]<span class="comment"># yum -y install net-tools-2.0-0.25.20131004git.el7.x86_64</span></span><br><span class="line">Loaded plugins: fastestmirror, ovl</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">。。。。</span><br><span class="line">[root@e98c71f36f2d /]<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.0.5  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe12:5  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:12:00:05  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 2797  bytes 30739967 (29.3 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2625  bytes 176315 (172.1 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@e98c71f36f2d /]<span class="comment"># yum update &amp;&amp; yum -y install vim</span></span><br></pre></td></tr></table></figure>
<p>用户可以继续在容器中做任何自己想做的事情。当所有工作都结束时,输入<code>exit</code>，容器现在以经停止运行了! </p>
<p>在指定的<code>/bin/bash</code>命令处于运行状态的时候,我们的容器也才会地处于运行状态。一旦退出容器, &#x2F;bin&#x2F;bash命令也就结束了,这时容器随之停止了运行。但容器仍然是存在的,可以<code>docker ps-a</code>命查看当前系统中容器的列表,</p>
<p>有3种方式可以唯一指代容器:</p>
<ul>
<li>短DUD(如f7cbdac22a02)、</li>
<li>长UUID(7cbdac02er3c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778)</li>
<li>名称(如gray-cat)。</li>
</ul>
<h3 id="3-4容器命名"><a href="#3-4容器命名" class="headerlink" title="3.4容器命名"></a>3.4<font color=blue>容器命名</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker --name boy_the_container -i-t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>定器的命名必须是唯一的。如果试图创建两个名称相同的容器》则命令将会失败。如果要使用的容器名称已经存在,可以先用dockerrmf删除已有的同名容器后,再来创建新的容器。 </p>
<h3 id="3-5重新启动已经停止的容器"><a href="#3-5重新启动已经停止的容器" class="headerlink" title="3.5重新启动已经停止的容器"></a>3.5<font color=royalblue>重新启动已经停止的容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start bpb the container</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>docker restart</code>命令来重新启动一个容器。这时运行不带<code>-a</code>标志的<code>docker ps</code>命令,就应该看到我们的容器已经开始运行了。注意类似地, Docker也提供(<code>docker create</code>命令来创建一个容器,但是并不运行它。这让我们可以在自己的容器工作流中对共进行细杠度的控制。</p>
<h3 id="3-6附着到容器上"><a href="#3-6附着到容器上" class="headerlink" title="3.6附着到容器上"></a>3.6<font color=tomato>附着到容器上</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker attach container</span><br></pre></td></tr></table></figure>

<h3 id="3-7创建守护式容器"><a href="#3-7创建守护式容器" class="headerlink" title="3.7创建守护式容器"></a>3.7<font color=brown>创建守护式容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name daemon_daved -d ubuntu /bin/sh-c <span class="string">&quot;while true;do echo tettewera;seelp 1; done&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>&#x2F;usr&#x2F;sbin&#x2F;init 启动容器之后可以使用systemctl方法  ,-privileged&#x3D;true 获取宿主机root权限(特殊权限-) su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。</p>
</blockquote>
<h3 id="3-8容器内部都在干些什"><a href="#3-8容器内部都在干些什" class="headerlink" title="3.8容器内部都在干些什"></a>3.8<font color=blue>容器内部都在干些什</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs -f daemon dave</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/9ca979f4a0ed46659dbf5822b1aa0c52.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA5bGx5rKz5bey5peg5oGZ,size_41,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ul>
<li>我们也可以跟踪容器日志的某 段,和之前类似,只需要在tail命加入-f—tail标志即可。例如,可以</li>
<li><code>docker logs --tail 10 daemon_dave </code>  获取日志最后10行内容。另外,也可以</li>
<li><code>docker logs --tail 0 -f daemon_dave</code> 命令来追踪某个容器的最新日志</li>
<li>还可-t标志为每条日志项加上时间戳</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs -ft daemon dave</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4ffda39b2fb949128d45b1e66b64e8b8.png" alt="在这里插入图片描述"></p>
<h3 id="3-9-Docker日志驱动"><a href="#3-9-Docker日志驱动" class="headerlink" title="3.9 Docker日志驱动"></a>3.9 <font color=chocolate>Docker日志驱动</font></h3><p>自<code>Docker 1.6</code>开始,也可以控制<code>Docker</code>守护进程和容器的日志驱动,<code>--1og-driver</code>选项现。可以在启动Docker守护进程或执行docker run命令</p>
<p>有好几个选项,包括默认<code>json-file</code>, <code>json-file</code>也为我 前面看到的docker logs命令提供了基础。</p>
<p>其他的选项还syslog,该选项将禁用docker logs命令,形 将所有容器志输 都重定向Syslog.可以在启动docker守护进程时指定该选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name daemon_daved --log-driver=<span class="string">&quot;syslog&quot;</span> -d ubuntu /bin/sh -c <span class="string">&quot;while true; do echo hello word; sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>

<p>取还有一个可用的选项是none,这个选项将会禁用所有容器中的日志,导致<code>docker logs</code>命令也被禁用</p>
<h3 id="3-10查看容器内的进程"><a href="#3-10查看容器内的进程" class="headerlink" title="3.10查看容器内的进程"></a>3.10<font color=seagreen>查看容器内的进程</font></h3><p>查看容器运行的讲程,要做到这一使用<code>docker top</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker top daemon_daved</span><br><span class="line">PID                 USER                TIME                COMMAND</span><br><span class="line">25931               root                0:00                /bin/sh -c <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">echo</span> hello word; sleep 1; <span class="keyword">done</span></span><br><span class="line">26291               root                0:00                sleep 1</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<h3 id="3-11-Docker统计信息"><a href="#3-11-Docker统计信息" class="headerlink" title="3.11 Docker统计信息"></a>3.11 <font color=chocolate>Docker统计信息</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stats daemon_daved</span><br></pre></td></tr></table></figure>
<h3 id="3-12在容器内部运行进程"><a href="#3-12在容器内部运行进程" class="headerlink" title="3.12在容器内部运行进程"></a>3.12<font color=yellowgreen>在容器内部运行进程</font></h3><p>在Docker 1.3之后,也可以通过<code>docker exec</code>命令在容器内部额外启动新进程。</p>
<ul>
<li>在容器内运行的进程有两种:后台任务和交互式任务。 </li>
<li>后台任务在容器内且没有交互需求,而交互式在务则保持在前台行。</li>
<li>对于需要在容器内 打开shell的在务,互式务很实用的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker <span class="built_in">exec</span> -d  daemon_daved touch /etc/new_config_file</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker <span class="built_in">exec</span> -ti  daemon_daved /bin/bash</span><br><span class="line">root@232b4ca6dd68:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@232b4ca6dd68:/<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>这里的<code>-t</code>和<code>-i</code>标志为我们执行的进程创TTY并捕护STDIN,接着我们指定了要在内部执行这个命令的容器的名字以及要执命。在上面的例子中,这条命令会在<code>daemon-dave</code>容器内创建一个新的bash会话,有了这个会话,我们就可以在该容器中运行其他命令了。</li>
</ul>
<p>从<code>Docker 1.7</code>开始,可以对<code>docker exec</code>启动的进程使用<code>-u</code>标志为新启动的进程指定,一个用户属主。</p>
<p><code>docker exec</code>命令是<code>Docker 1.3</code>引入的,早期版本并不支持该命令。对于早期Docker版本,请参考第6章中介绍的nsenter命令。</p>
<h3 id="3-13停止守护式容器"><a href="#3-13停止守护式容器" class="headerlink" title="3.13停止守护式容器"></a>3.13<font color=plum>停止守护式容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">232b4ca6dd68        ubuntu              <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   17 minutes ago      Up 17 minutes                           daemon_daved</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker stop 232b4ca6dd68</span><br><span class="line">232b4ca6dd68</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$</span><br><span class="line">└─$ docker ps -n 2</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">232b4ca6dd68        ubuntu              <span class="string">&quot;/bin/sh -c &#x27;while t…&quot;</span>   18 minutes ago      Exited (137) 42 seconds ago                       daemon_daved</span><br><span class="line">166f786ffb04        9dbed5a04e9c        <span class="string">&quot;/bin/sh -c &#x27;yum upd…&quot;</span>   5 hours ago         Exited (127) 5 hours ago                          elegant_roentgen</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-14自动重启容器"><a href="#3-14自动重启容器" class="headerlink" title="3.14自动重启容器"></a>3.14<font color=royalblue>自动重启容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker run --restart=always --name daemon_daved -d ubuntu /bin/sh -c <span class="string">&quot;while true; do echo hello word; sleep 1; done&quot;</span></span><br><span class="line">c030ed0db34903039a104816094887d884bcefff767c2ac056bd8a64d294dce9</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p><code>--restart</code>标志被设置为<code>always</code>,无论容器退出代碼是什麽,Docker都会自动重启该容器,<br>还可以将这个标志为<code>on-failure</code>,这样,只有当容器的退出代码为非0值的时候)才会自动重启。<br><code>on-failure</code> 还一个可选的重启次数.<code>--restart=on-failure:4</code></p>
<h3 id="3-15深入容器"><a href="#3-15深入容器" class="headerlink" title="3.15深入容器"></a>3.15<font color=amber>深入容器</font></h3><p>通过<code>docker ps</code>命令获取容器的信息,还可以使用<code>docker inspect</code>来获得更多的容器信息,也可用<code>-f</code>或者<code>--format</code>标志来定查看结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker inspect --format=<span class="string">&#x27;&#123;&#123; .State.Running &#125;&#125;&#x27;</span> c030ed0db349</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$ sudo docker inspect --format=<span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> c030ed0db349</span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_jdk]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p>也可以同时指定多个容器,并显示每个容器的输出结果,</p>
<h3 id="3-16删除容器"><a href="#3-16删除容器" class="headerlink" title="3.16删除容器"></a>3.16<font color=seagreen>删除容器</font></h3><p>如果容器已经不再使用,可以<code>docker rm</code>命令删除它们,<br>从<code>Docker 1.6.2</code>开始,可以通过给<code>docker rm</code>命全传 <code>-f</code>标志来删除运行中的<code>Docker</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm `sudo docker ps -a -q`</span><br></pre></td></tr></table></figure>
<p><code>-a</code>标志代表列出所有容器,而<code>-q</code>标,志则表示只需要返回容器的ID而不会返回容器的其他信息。这样我们就得到了容器<code>ID</code>的列表,并传给了<code>docker rm</code>命令,从而达到删除所有容器的目的。</p>
<h1 id="第4章-使用Docker镜像和仓库"><a href="#第4章-使用Docker镜像和仓库" class="headerlink" title="第4章 使用Docker镜像和仓库"></a><font color=royalblue>第4章 使用Docker镜像和仓库</font></h1><h3 id="4-1什么是Docker镜像"><a href="#4-1什么是Docker镜像" class="headerlink" title="4.1什么是Docker镜像"></a>4.1<font color=purple>什么是Docker镜像</font></h3><p><code>Docker</code>镜像是由文件系统叠加而成,底端是一个引导文件系统<code> bootfs</code>。<code>Docker</code>用户几乎永远不会和引导文件交互。实际上,当一个容器启动.后,它将会被移到内存中,而引导文件系统则会被卸载(unmount),以留出更多的内存供<code>initrd磁盘镜像</code>使用。</p>
<p><code>Docker</code>看起来还很像一个典型的<code>Linux虚拟化栈</code>。实际, Docker镜像的第二层是<code>root文件系统rootfs</code>, 位于引导文件系统之上。</p>
<p><code>rootfs</code>可以或多种操作系如<code>Debian</code>或者<code>ubuntu</code>文件系统)。在传统的Linux引导过程中, root文件系统会最先以<code>只读的方式加载</code>,当引导结束并完成了<code>完整性检查之后</code>,它才会被切换为<code>读写模式</code>是在<code>Docker</code>里, <code>root文件</code>系统永远只能是<code>只读状态</code>,并且<code>Docker</code>利用<code>联合加载</code>(union mount)技术又会在<code>root文件系统层</code>上加载更多的<code>只读文件系统</code>。</p>
<p>联合加载是指同时加载多个文件系统,但是在外面看起术只能看到只有一个文件系统。<code>联合加载</code>会将各层文件系统叠加到一起。</p>
<p><code>Docker</code>将这样的<code>文件系统</code>称为<code>镜像</code>。一个<code>镜像</code>可以放到另一个<code>镜像</code>的顶部。位于下面的<code>镜像</code>称为<code>父镜像(parent image)</code>,可以依次类推,直到镜像栈的最底部,最底部的镜像称为<code>基础镜像(base image)</code>,最后,当从一个镜像启动容器时, <code>Docker</code>会在该镜像的最顶层加载一个<code>读写文件系统</code>。我们想在Docker中运行的程序就是在这个<code>读写层中执行</code>的。</p>
<p><img src="https://img-blog.csdnimg.cn/1f45d836d6454c10b7a0018e43366856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA5bGx5rKz5bey5peg5oGZ,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>当<code>Docker</code>第一次<code>启动一个容器</code>时,初始的<code>读写层</code>是<code>空</code>的。当文件系统发生变化时,这些变化都会应用到这一层上。比如,如果想<code>修改一个文件</code></p>
<ul>
<li>这个<code>文件</code>首先会从该读写层下面的<code>只读层复制到该读写层</code>。该文件的只读版本依然存在,但是已经被读写层中的该文件副本所隐藏。通常这种机制被称为<code>写时复制(copy on write)</code>,这也是使Docker如此强大的技术之一。</li>
<li>每个<code>只读镜像层</code>都是<code>只读</code>的,并且以后永远不会变化。当<code>创建一个新容器</code>时, <code>Docker会构建出一个镜像栈</code>,并在<code>栈</code>的<code>最顶端添加一个读写层</code>。这个读写层再加上其下面的镜像层以及一些配置数据,就构成了一个容器。</li>
</ul>
<h3 id="4-2列出镜像"><a href="#4-2列出镜像" class="headerlink" title="4.2列出镜像"></a>4.2列出镜像</h3><p>本地镜像都保存在Docker宿主机的<code>/var/lib/docker</code>目录下。每个镜像都保存在<code>Docker</code>所采用的存储驱动目录下面,如<code>aufs</code>或者<code>devicemapper</code>。也可以在<code>/var/lib/docker/containers</code>目录下面看到所有的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h3 id="4-3拉取镜像"><a href="#4-3拉取镜像" class="headerlink" title="4.3拉取镜像"></a>4.3拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull image_name</span><br></pre></td></tr></table></figure>
<h3 id="4-4查找镜像"><a href="#4-4查找镜像" class="headerlink" title="4.4查找镜像"></a>4.4查找镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search image_name</span><br></pre></td></tr></table></figure>
<h3 id="4-5构建镜像"><a href="#4-5构建镜像" class="headerlink" title="4.5构建镜像"></a>4.5构建镜像</h3><p>使用<code>docker commit</code>命令。使用<code>docker build</code>命令和<code>Dockerfile</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器ID 镜像名</span><br></pre></td></tr></table></figure>
<p>-旦有了<code>Dockerfile</code>,我们就可以使用<code>docker build</code>命令基于该Dockerfile中的指令构建一个新的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;Hi, I am in your container&#x27;</span> \</span><br><span class="line">    &gt;/var/www/html/index.html</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-5-1-创建Docker-Hub账号"><a href="#4-5-1-创建Docker-Hub账号" class="headerlink" title="4.5.1 创建Docker Hub账号"></a>4.5.1 <font color=red>创建Docker Hub账号</font></h4><h4 id="4-5-2-用Docker的commit命令创建镜像"><a href="#4-5-2-用Docker的commit命令创建镜像" class="headerlink" title="4.5.2 用Docker的commit命令创建镜像"></a>4.5.2 <font color=blue>用Docker的commit命令创建镜像</font></h4><p>这个是基于已有的镜像的基础上新做一个。</p>
<h4 id="4-5-3-用Dockerfile构建镜像"><a href="#4-5-3-用Dockerfile构建镜像" class="headerlink" title="4.5.3 用Dockerfile构建镜像"></a>4.5.3 <font color=amber>用Dockerfile构建镜像</font></h4><p><code>每条指令都会创建一个新的镜像层并对镜像进行提交</code>。<code>Docker</code>大体上按照如下流程执行<code>Dockerfile</code>中的指令。</p>
<ul>
<li>Docker从基础镜像运行一个容器。</li>
<li>执行一条指令,对容器做出修改。</li>
<li>执行类似docker commit的操作,提交一个新的镜像层。</li>
<li>Docker再基于刚提交的镜像运行一个新容器。</li>
<li>执行Dockerfile中的下一条指令,直到所有指令都执行完毕。</li>
</ul>
<p>RUN指令会在shell里使用命令包装器<code>/bin/sh -c</code>来执行。如果是在一个不支持shell的平台上运行或者不希望在shell中运行(比如避免shell字符串篡改),也可以使用exec格式的RUN指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ <span class="string">&quot;apt-get&quot;</span>, <span class="string">&quot; install&quot;</span>, <span class="string">&quot;-y&quot;</span>, <span class="string">&quot;nginx&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>从Git仓库构建Docker镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build-t=<span class="string">&quot;jamtur01/static web:v1&quot;</span> \ git@github.com: jamtur01/docker-static web</span><br></pre></td></tr></table></figure>

<h4 id="4-5-6-Dockerfile和构建缓存"><a href="#4-5-6-Dockerfile和构建缓存" class="headerlink" title="4.5.6 Dockerfile和构建缓存"></a>4.5.6 <font color=purple>Dockerfile和构建缓存</font></h4><p>由于每一步的构建过程都会将结果提交为镜像,所以<code>Docker</code>的构建镜像过程就显得非常聪明。它会将之前的镜像层看作缓存。</p>
<p>有些时候需要确保<code>构建过程不会使用缓存</code>。要想略过缓存功能,可以使用<code>docker build的--no-cache</code>标志</p>
<h4 id="4-5-7-基于构建缓存的Dockerfile模板"><a href="#4-5-7-基于构建缓存的Dockerfile模板" class="headerlink" title="4.5.7 基于构建缓存的Dockerfile模板"></a>4.5.7 <font color=plum>基于构建缓存的Dockerfile模板</font></h4><p>构建缓存带来的一个好处就是,我们可以实现简单的Dockerfile模板(比如在Dockerfile文件顶部增加包仓库或者更新包,从而尽可能确保缓存命中),我一般都会在自己的Dockerfile文件顶部使用相同的指令集模板,比如对Ubuntu.使用模版。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line">RUN apt-get -qq update</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分析一下这个新的<code>Dockerfile</code>,首先,我通过<code>FROM</code>指令为新镜像设置了一个基础镜像<code>ubuntu:14.04</code>。接着,我又使用<code>MAINTAINER</code>指令添加了自己的详细联系信息。之后我又使用了一条新出现的指令ENV来在镜像中设置环境变量。在这个例子里,我通过<code>ENV</code>指令来设置了一个名为<code>REFRESHED_AT</code>的环境变量,这个环境变量用来表明该镜像模板最后的更新时间。最后,我使用了RUN指令来运行apt-get -qq update命令。该指令运行时将会刷新APT包的缓存,用来确保我们能将要安装的每个软件包都更新到最新版本。<code>有了这个模板,如果想刷新一个构建,只需修改ENV指令中的日期。这使Docker在命中ENV指令时开始重置这个缓存,并运行后续指令而无须依赖该缓存</code>。</p>
</blockquote>
<h4 id="4-5-8查看新镜像"><a href="#4-5-8查看新镜像" class="headerlink" title="4.5.8查看新镜像"></a>4.5.8<font color=tomato>查看新镜像</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images 镜像名字</span><br></pre></td></tr></table></figure>
<h4 id="4-5-9从新镜像启动容器"><a href="#4-5-9从新镜像启动容器" class="headerlink" title="4.5.9从新镜像启动容器"></a>4.5.9<font color=amber>从新镜像启动容器</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d --name 容器名  镜像名 启动命令</span><br></pre></td></tr></table></figure>
<h4 id="4-5-10-Dockerfile指令"><a href="#4-5-10-Dockerfile指令" class="headerlink" title="4.5.10 Dockerfile指令"></a>4.5.10 <font color=seagreen>Dockerfile指令</font></h4><h5 id="1-CMD"><a href="#1-CMD" class="headerlink" title="1.CMD"></a><font color=camel>1.CMD</font></h5><p>CMD指令用于指定<code>一个容器启动时要运行的命令</code>。这有点儿类似于<code>RUN指令</code>,**<font color=purple>只是RUN指令是指定镜像被构建时要运行的命令,而CMD是指定容器被启动时要运行的命令</font>**。这和使用docker run命令启动容器时指定要运行的命令非常类似</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it 镜像名  启动命令   // 等价与 CMD[<span class="string">&quot;启动命令&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>CMD[&quot;/bin/bash&quot; , &quot;-l&quot;]</code>  将 -l 作为参数传递进去，<code>CMD</code> 要运行的命令存放在一个数组结构中，告诉Docker 按照指定的原样来运行命令。</p>
<p>也可以直接使用命令，Dockerfile会在指定的命令前加上<code>bin/sh -c</code>(让 bash 将一个字串作为完整的命令来执行)</p>
<p>使用<code>docker run</code>命令可以覆盖<code>CMD指令</code>。如果我们在<code>Dockerfile</code>里指定了<code>CMD</code>指令,而同时在<code>docker run</code>命令行中也指定了要运行的命令,<strong><font color=camel>命令行中指定的命令会覆盖Dockerfile中的CMD指令。 </font></strong></p>
<p>在<code>Dockerfile中只能指定一条CMD指令</code>。如果<code>指定了多条CMD指令,也只有最后一·条CMD指令会被使用</code>。如果想在启动容器时运行多个进程或者多条命令,可以考虑使用.类似<code>Supervisor</code>这样的服务管理工具。</p>
<h5 id="2-ENTRYPOINT"><a href="#2-ENTRYPOINT" class="headerlink" title="2. ENTRYPOINT"></a><font color=chocolate>2. ENTRYPOINT</font></h5><blockquote>
<p><code>ENTRYPOINT</code>指令与<code>CMD</code>指令非常类似,也很容易和CMD指令弄混。这两个指令到底有什么区别呢?为什么要同时保留这两条指令?</p>
</blockquote>
<p>**<font color=orange>ENTRYPOINT指令提供的命令则不容易在启动容器时被覆盖。实际上, docker run命令行中指定的任何参数都会被当做参数再次传递给ENTRYPOINT指令中指定的命令</font>**。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [ <span class="string">&quot;/usr/sbin/nginx&quot;</span> ]</span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;/usr/sbin/nginx&quot;</span>, <span class="string">&quot;-g&quot;</span> , <span class="string">&quot;daemon off;&quot;</span> ] <span class="comment"># 通过-g参数临时指定一些全局配置项</span></span><br></pre></td></tr></table></figure>
<p>使用<code>ENTYRPOINT</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [ <span class="string">&quot;usr/sbin/nginx&quot;</span> ]</span><br><span class="line">sudo docker run -it nginx -g <span class="string">&quot;daemon off;&quot;</span></span><br></pre></td></tr></table></figure>
<p>同时使用<code>ENTRYPOINT和CMD</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [ <span class="string">&quot;/usr/sbin/nginx&quot;</span> ]</span><br><span class="line">CMD [ <span class="string">&quot;-h&quot;</span> ]</span><br><span class="line"><span class="comment">#  /usr/sbin/nginx  -h  显示帮助信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果确实需要,用户也可以在运行时通过<code>docker run的--entrypoint</code>标志覆盖<code>ENTRYPOINT</code>指令。</p>
</blockquote>
<h5 id="3-WORKDIR"><a href="#3-WORKDIR" class="headerlink" title="3. WORKDIR"></a><font color=brown>3. WORKDIR</font></h5><p><code>WORKDIR</code>指令用来在<code>从镜像创建一个新容器</code>时,<code>在容器内部设置一个工作目录,ENTRYPOINT和/或CMD指定的程序会在这个目录下执行</code>。我们可以使用<code>该指令为Dockerfile中后续的一系列指令设置工作目录,也可以为最终的容器设置工作目录</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /opt/webapp/db</span><br><span class="line">RUN bundle install</span><br><span class="line">WORKDIR /opt/webapp</span><br><span class="line">ENRTYPOINT [ <span class="string">&quot;reckup&quot;</span> ]</span><br></pre></td></tr></table></figure>
<p>这里,我们将工作目录切换为&#x2F;opt&#x2F;webapp&#x2F;db后运行了bundle install命令,之后又将工作目录设置为&#x2F;opt&#x2F;webapp,最后设置了ENTRYPOINT指令来启动rackup命令。</p>
<p><code>可以通过-w标志在运行时覆盖工作目录</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -it -w /var/<span class="built_in">log</span> ubuntu <span class="built_in">pwd</span></span><br><span class="line">/var/<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h5 id="4-ENV"><a href="#4-ENV" class="headerlink" title="4. ENV"></a><strong><font color=seagreen>4. ENV</font></strong></h5><blockquote>
<p>ENV指令用来在镜像构建过程中设置环境变量，这个新的环境变量可以在后续的任何RUN指令中使用,这就如同在命令前面指定了环境变量前级一样,</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV RVM_PATH /home/rvm</span><br></pre></td></tr></table></figure>
<p>可以在<code>ENV</code>指令中指定单个环境变量,或者,从<code>Docker 1.4</code>开始可以指定多個变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV APP_ID=Demo JAR_FILE_NAME=<span class="string">&quot;Demo-2.0.0-SNAPSHOT.jar&quot;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用<code>docker run命令行的-e</code>标志来传递环境变量。这些变量将只会在运行时有效.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -e <span class="string">&quot;WEB_PORT=8080&quot;</span> centos env</span><br></pre></td></tr></table></figure>
<h5 id="5-USER"><a href="#5-USER" class="headerlink" title="5. USER"></a><strong><font color=tomato>5. USER</font></strong></h5><blockquote>
<p>USER指令用来指定<code>该镜像会以什么样的用户去运行</code>。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER nginx</span><br></pre></td></tr></table></figure>
<p>基于该镜像启动的容器会以nginx用户的身份来运行。我们可以指定用户名或UID以及组或GID,甚至是两者的组合.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group </span><br></pre></td></tr></table></figure>
<p>如果不通过USER指令指定用户,默认用户为root</p>
<h5 id="6-VOLUME"><a href="#6-VOLUME" class="headerlink" title="6. VOLUME"></a><font color=blue>6. VOLUME</font></h5><p><strong><font color=seagreen>VOLUME指令用来向基于镜像创建的容器添加卷。一个卷是可以存在于一个或者多个容器内的特定的目录,这个目录可以绕过联合文件系统,并提供如下共享数据或者对数据进行持久化的功能。</font></strong></p>
<ul>
<li>卷可以在容器间<font color=blue>共享和重用</font>。</li>
<li>一个容器可以不是必须和其他容器共享卷。</li>
<li>对卷的<font color=green>修改是立时生效的</font>。</li>
<li>对卷的修改不会对<font color=plum>更新镜像产生影响</font>。</li>
<li>卷会一直存在<font color=red>直到没有任何容器再使用它</font>。</li>
</ul>
<p>**<font color=tomato>卷功能让我们可以将数据(如源代码)、数据库或者其他内容添加到镜像中而不是将这些内容提交到镜像中,并且允许我们在多个容器间共享这些内容。我们可以利用此功能来测·试容器和内部的应用程序代码,管理日志,或者处理容器内部的数据库</font>**。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [ <span class="string">&quot;/opt/project&quot;</span> ]</span><br><span class="line">VOLUME [ <span class="string">&quot;/opt/project&quot;</span> , <span class="string">&quot;/data&quot;</span> ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>docker cp是和VOLUME指令相关并且也是很实用的命令。该命令允许从容器复制文件&quot;和复制文件到容器上</code>。可以从Docker命令行文档(<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/cp/)%E4%B8%AD%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%E3%80%82">https://docs.docker.com/engine/reference/commandline/cp/)中获得更多信息。</a> </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 源地址：目标地址  <span class="comment"># 可以容器到宿主机，也可以宿主机到容器</span></span><br></pre></td></tr></table></figure>

<h5 id="7-ADD"><a href="#7-ADD" class="headerlink" title="7. ADD"></a><font color=blue>7. ADD</font></h5><blockquote>
<p><code>ADD</code>指令用来将构建环境下的文件和目录复制到镜像中。比如,在安装一个应用程序时。<code>ADD指令需要源文件位置和目的文件位置两个参数</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD ./target/*.tar.gz /root/</span><br></pre></td></tr></table></figure>

<p>在ADD文件时, Docker通过目的地址参数末尾的字符来判断文件源是目录还是文件。<code>如果目的地址以/结尾,那么Docker就认为源位置指向的是目录。如果目的地址不是以/结尾,那么Docker就认为源位置指向的是文件。</code> <font color=camel>文件源也可以使用URL的格式</font>.</p>
<p>最后值得一提的是, ADD在处理本地归档文件(tar archive)时还有一些小魔法。<code>如果将一个归档文件(合法的归档文件包括gzip, bzip2、 xz)指定为源文件, Docker会自动将归档文件解开(unpack)</code></p>
<ul>
<li><p><code>如果目的位置不存在的话, Docker将会为我们创建这个全路径</code>,包括路径中的任何目录。新创建的文件和目录的模式为0755,并且UID和GID都是0.</p>
</li>
<li><p><code>ADD指令会使得构建缓存变得无效,</code>。如果通过ADD指令向镜像添加’个文件或者目录,那么这将使Dockerfile中的后续指令都不能继续使用之前的构建缓存。</p>
</li>
</ul>
<h5 id="8-COPY"><a href="#8-COPY" class="headerlink" title="8. COPY"></a><font color=blue>8. COPY</font></h5><p>COPY指令非常类似于ADD,它们根本的不同是COPY只关心在构建上下文中复制本地文件,<code>而不会去做文件提取(extraction)和解压(decompression)的工作。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY conf.d/ /etc/apache2/  <span class="comment"># 把本地conf.d目录中的文件复制到/etc/apache2/目录</span></span><br></pre></td></tr></table></figure>

<p>文件源路径必须是一个与当前构建环境相对的文件或者目录,本地文件都放到和Dockerfile同一个目录下。<code>不能复制该目录之外的任何文件</code>,因<code>为构建环境将会上传到Docker守护进程,而复制是在Docker守护进程中进行的。任何位于构建环境之外的东西都是不可用的</code>。</p>
<p>**<font color=red>COPY指令的目的位置则必须是容器内部的一个绝对路径</font>**。任何由该指令创建的文件或者目录的UID和GID都会设置为0.</p>
<p>如果源路径是一个目录,那么这个目录将整个被复制到容器中,<code>包括文件系统元数据</code>;如果源文件为任何类型的文件,则该文件会随同元数据一起被复制。在这个例子里,源路径以&#x2F;结尾,所以Docker会认为它是目录,并将它复制到目的目录中。</p>
<p>如果目的位置不存在,<code> Docker将会自动创建所有需要的目录结构,就像mkdir-p命令那样。</code></p>
<h5 id="9-LABEL"><a href="#9-LABEL" class="headerlink" title="9. LABEL"></a><font color=seagreen>9. LABEL</font></h5><p><code>LABEL指令是在Docker 1.6版本中引入的。</code></p>
<p><code>LABEL指令以label=&quot;value&quot;的形式出现。可以在每一条指令中指定一个元数据</code>,或者指定多个元数据,不同的元数据之间用空格分隔。</p>
<p><code>推荐将所有的元数据都放到一条LABEL指令中</code>,以防止不同的元数据指令创建过多镜像层。可以通过docker inspect命令来查看Docker镜像中的标签信息</p>
<p>LABEL指令用于为Docker镜像添加元数据。元数据以键值对的形式展现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ cat Dockerfile</span><br><span class="line">FROM nginx</span><br><span class="line">LABEL maintainer=<span class="string">&quot;uag&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2021-08-27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOLUME  /var/<span class="built_in">log</span>/nginx/</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx_log  // </span><br><span class="line"> <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;desktop.docker.io/wsl-distro&quot;</span>: <span class="string">&quot;kali-linux&quot;</span>,</span><br><span class="line">                <span class="string">&quot;maintainer&quot;</span>: <span class="string">&quot;uag&quot;</span></span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="10-STOPSIGNAL"><a href="#10-STOPSIGNAL" class="headerlink" title="10. STOPSIGNAL"></a><font color=orange>10. STOPSIGNAL</font></h5><p>**<font color=royalblue>STOPSIGNAL指令用来设置停止容器时发送什么系统调用信号给容器</font>**。这个信号必须·是内核系统调用表中合法的数,如9,或者SIGNAME格式中的信号名称,如SIGKILL注意<code>STOPSIGNAL指令是在Docker 1.9版本中引入的。 </code></p>
<h5 id="11-ARG"><a href="#11-ARG" class="headerlink" title="11. ARG"></a><font color=seagreen>11. ARG</font></h5><p>**<font color=purple><code>ARG</code>指令用来定义可以在<code>docker build</code>命令运行时<code>传递给构建运行时的变量</code>,</font>**我们只需要在构建时使用<code>--build-arg</code>标志即可。用户只能在构建时指定在<code>Dockerfile文件</code>中定义过的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG build</span><br><span class="line">ARG webapp_user=user</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg build=1234 -t jamtur01/webapp .</span><br></pre></td></tr></table></figure>
<p>ARG指令是在Docker 1.9版本中引入的,Docker预定义了一组ARG变量,可以在构建时直接使用,而不必再到Dockerfile中自行定义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP_PROXY</span><br><span class="line">http_proxy </span><br><span class="line">HTTPS_PROXY </span><br><span class="line">https_proxy </span><br><span class="line">FTP_PROXY </span><br><span class="line">ftp_proxy </span><br><span class="line">NO_PROXY </span><br><span class="line">no_proxy</span><br></pre></td></tr></table></figure>

<h5 id="12-ONBUIID"><a href="#12-ONBUIID" class="headerlink" title="12. ONBUIID"></a><font color=royalblue>12. ONBUIID</font></h5><p><code>ONBUILD</code>指令能为镜像<code>添加触发器(trigger)</code>。**<font color=chocolate>当一个镜像被用做其他镜像的基础镜像时(比如用户的镜像需要从某未准备好的位置添加源代码,或者用户需要执行特定于构建镜像的环境的构建脚本),该镜像中的触发器将会被执行</font>**。触发器会在<code>构建过程中插入新指令</code>,我们可以认为<code>这些指令是紧跟在FROM之后指定</code>的。触发器可以是任何构建指令,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD ADD .  /app/src </span><br><span class="line">ONBUILD <span class="built_in">cd</span> /app/src &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p>上面的代码将会在创建的镜像中加入ONBUILD触发器, ONBUILD指令可以在镜像上行docker inspect命令来查看,+</p>
<h3 id="4-6将镜像推送到DockerHub"><a href="#4-6将镜像推送到DockerHub" class="headerlink" title="4.6将镜像推送到DockerHub"></a>4.6<font color=red>将镜像推送到DockerHub</font></h3><p><img src="https://img-blog.csdnimg.cn/d8bed770269343e99d6b770916110aa3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bGx5rKz5bey5peg5oGZ,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>嗯，需要注册一个<code>Docker Hub账号</code>，然后登录，需要镜像前面加 <code>账户名/</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ docker push liruilong/nginx_log</span><br><span class="line">The push refers to repository [docker.io/liruilong/nginx_log]</span><br><span class="line">An image does not exist locally with the tag: liruilong/nginx_log</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ docker tag 9c9af0362eb9  liruilong/nginx_log</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ docker push liruilong/nginx_log</span><br><span class="line">The push refers to repository [docker.io/liruilong/nginx_log]</span><br><span class="line">fb04ab8effa8: Pushed</span><br><span class="line">8f736d52032f: Pushed</span><br><span class="line">009f1d338b57: Pushed</span><br><span class="line">678bbd796838: Pushed</span><br><span class="line">d1279c519351: Pushed</span><br><span class="line">f68ef921efae: Pushed</span><br><span class="line">latest: digest: sha256:2af7e8aeab84e8a816caf6b0342e1a45f95c7089ff52578040ea3a4c28a943c7 size: 1570</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$  docker push liruilong/nginx_log:tagname  <span class="comment"># 拉去镜像</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/11cb1d8570b84bad9f7ff6d35970dca8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bGx5rKz5bey5peg5oGZ,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="4-7删除镜像"><a href="#4-7删除镜像" class="headerlink" title="4.7删除镜像"></a>4.7<font color=yellowgreen>删除镜像</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名</span><br><span class="line"><span class="comment"># 删除所有镜像</span></span><br><span class="line">docker rmi `docker images -a -q`</span><br></pre></td></tr></table></figure>

<h3 id="4-8运行自己的DockerRegistry"><a href="#4-8运行自己的DockerRegistry" class="headerlink" title="4.8运行自己的DockerRegistry"></a>4.8<font color=brown>运行自己的DockerRegistry</font></h3><p>希望构建和存储包含不想被公开的信息或数据的镜像。这时候我们有以下两种选择。</p>
<ul>
<li>利用Docker Hub上的私有仓库。</li>
<li>在防火墙后面运行你自己的Registry。</li>
</ul>
<h4 id="4-8-1从容器运行Registry"><a href="#4-8-1从容器运行Registry" class="headerlink" title="4.8.1从容器运行Registry"></a>4.8.1<font color=brown>从容器运行Registry</font></h4><p>从<code>Docker 1.3.1</code>开始,需要在启动<code>Docker守护进程</code>的命令中添加<code>--insecurereqistry localhost: 5000</code>标志,并重启守护进程,才能<code>使用本地Registry。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5000:5000 registry:2</span><br></pre></td></tr></table></figure>

<h4 id="4-8-2-测试新Registry"><a href="#4-8-2-测试新Registry" class="headerlink" title="4.8.2 测试新Registry"></a>4.8.2 <font color=purple>测试新Registry</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images </span><br><span class="line">docker tag  镜像ID 标签：镜像名 </span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ docker images registry</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry            2                   1fd8e1b0bb7e        4 months ago        26.2MB</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ docker tag  1fd8e1b0bb7e  docker.example.com:5000/liruilong/static_web</span><br></pre></td></tr></table></figure>
<h3 id="4-9其他可选Registry服务"><a href="#4-9其他可选Registry服务" class="headerlink" title="4.9其他可选Registry服务"></a>4.9<font color=plum>其他可选Registry服务</font></h3><p>也有很多其他公司和服务提供定制的Docker Registry服务。</p>
<h5 id="Quay"><a href="#Quay" class="headerlink" title="Quay"></a><font color=green>Quay</font></h5><p>Quay”服务提供了<code>私有的Registry托管服务</code>,允许用户<code>上传公共的或者私有的容</code>器。</p>
<p>目前它提供了免费的无限制的公共仓库托管服务,如果想托管私有仓库,它还提供了一系列的可伸缩计划。Quay最近被CoreOs收购了,并会被整合到他们的产品中去。</p>
<h1 id="第5章在测试中使用Docker"><a href="#第5章在测试中使用Docker" class="headerlink" title="第5章在测试中使用Docker"></a><font color=plum>第5章在测试中使用Docker</font></h1><ul>
<li>使用Docker测试一个静态网站。</li>
<li>使用Docker创建并测试一个Web应用。</li>
<li>将Docker用于持续集成。</li>
</ul>
<h2 id="5-1使用Docker测试静态网站-Nginx-docker-化"><a href="#5-1使用Docker测试静态网站-Nginx-docker-化" class="headerlink" title="5.1使用Docker测试静态网站(Nginx docker 化)"></a>5.1<font color=blue>使用Docker测试静态网站(Nginx docker 化)</font></h2><p>使用<code>Nginx Web</code>服务器安装到容器来架构一个简单的网站开始。这个网站暂且命名为<code>Sample</code>.</p>
<h3 id="5-1-1-Sample网站的初始Dockerfile"><a href="#5-1-1-Sample网站的初始Dockerfile" class="headerlink" title="5.1.1 Sample网站的初始Dockerfile"></a>5.1.1 <font color=green>Sample网站的初始Dockerfile</font></h3><blockquote>
<p><font color=red>获取Nginx配置文件</font>：</p>
</blockquote>
<p><font color=red>global.conf</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen          0.0.0.0:80;</span><br><span class="line">        server_name     _;</span><br><span class="line"></span><br><span class="line">        root            /var/www/html/website;</span><br><span class="line">        index           index.html index.htm;</span><br><span class="line"></span><br><span class="line">        access_log      /var/log/nginx/default_access.log;</span><br><span class="line">        error_log       /var/log/nginx/default_error.log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color=seagreen>nginx.conf</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes 4;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">daemon off;</span><br><span class="line"></span><br><span class="line">events &#123;  &#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  sendfile on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  types_hash_max_size 2048;</span><br><span class="line">  include /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line">  access_log /var/log/nginx/access.log;</span><br><span class="line">  error_log /var/log/nginx/error.log;</span><br><span class="line">  gzip on;</span><br><span class="line">  gzip_disable &quot;msie6&quot;;</span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font color=red>我们还需要将Nginx配置为非守护进程的模式,这样可以让Nginx在Docker容器里工作。</font></strong></p>
<blockquote>
<p>网站测试的基本Dockerfile</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2014-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update &amp;&amp; apt-get -qq install nginx</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /var/www/html/website</span><br><span class="line">ADD nginx/global.conf /etc/nginx/conf.d/</span><br><span class="line">ADD nginx/nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个简单的Dockerfile内容包括以下几项。</p>
<ul>
<li>安装Nginx.·</li>
<li>在容器中创建一个目录&#x2F;var&#x2F;www&#x2F;html&#x2F;website&#x2F;</li>
<li>将来自我们下载的本地文件的Nginx配置文件添加到镜像中。</li>
<li>公开镜像的80端口。</li>
</ul>
<p>这个Nginx配置文件是为了运行Sample网站而配置的。<code>将文件nginx/global.conf用ADD指令复制到/etc/nginx/conf.d/目录中。</code></p>
<p>在nginx.conf这个配置文件里,<code> daemon off;选项阻止Nginx进入后台,强制其在前台运行。这是因为要想保持Docker容器的活跃状态,需要其中运行的进程不能中断。默认情况下, Nginx&quot;会以守护进程的方式启动,这会导致容器只是短暂运行,在守护进程被fork启动后,发起守护进程的原始进程就会退出,这时容器就停止运行了。</code></p>
<h3 id="5-1-2构建Sample网站和Nginx镜像"><a href="#5-1-2构建Sample网站和Nginx镜像" class="headerlink" title="5.1.2构建Sample网站和Nginx镜像"></a>5.1.2<font color=amber>构建Sample网站和Nginx镜像</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/logstash/sample]</span><br><span class="line">└─$ sudo docker build -t jamtur01/nginx .</span><br><span class="line">Sending build context to Docker daemon  4.608kB</span><br><span class="line">Step 1/8 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/8 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ....</span><br><span class="line">Removing intermediate container 15c4f81371e1</span><br><span class="line"> ---&gt; 1583c3126a40</span><br><span class="line">Successfully built 1583c3126a40</span><br><span class="line">Successfully tagged jamtur01/nginx:latest </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/5707d8e2962a414dbc64e994101be653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-1-3从Sample网站和Nainx镜像构建容器"><a href="#5-1-3从Sample网站和Nainx镜像构建容器" class="headerlink" title="5.1.3从Sample网站和Nainx镜像构建容器"></a>5.1.3<font color=amber>从Sample网站和Nainx镜像构建容器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/sample]</span><br><span class="line">└─$ sudo docker run -d -p 81:80 --name website -v <span class="variable">$PWD</span>/website:/var/www/html/website  jamtur01/nginx nginx</span><br><span class="line">7bb1eaa70f46e565b940b83fd0129ad9d5b2c035278d7d9c2704187e08f4e43f</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/sample]</span><br></pre></td></tr></table></figure>

<p>可以看到,我们使用docker run命令从jamtur01&#x2F;nginx镜像创建了一个名为website的容器。</p>
<ul>
<li><code>-v这个选项允许我们将宿主机的目录作为卷,挂载到容器里</code>,卷在Docker里非常重要,也很有用。**<font color=amber>卷是在一个或者多个容器内被选定的目录,可以绕过分层的联合文件系统(Union FileSystem),为Docker提供持久数据或者共享数据</font>**。这意味着对<code>卷的修改会直接生效,并绕过镜像。当提交或者创建镜像时,卷不被包含在镜像里.</code></li>
</ul>
<p><code>卷可以在容器间共享</code>。<code>即便容器停止,卷里的内容依旧存在</code>。</p>
<p>当我们因为某些原因不想把应用或者代码构建到镜像中时,就体现出卷的价值了。例如:希望同时对代码做开发和测试;代码改动很频繁,不想在开发过程中重构镜像;希<code>望在多个容器间共享代码</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 81:80 --name website -v <span class="variable">$PWD</span>/website:/var/www/html/website:ro  jamtur01/nginx nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-v</code>选项通过指定一个目录或者登上与容器上与该目录分离的本地宿主机来工作,这两个目录用:分隔。如果容器目录不存在,Docker会自动创建一个。也可以通过在目录后面加上<code>rw</code>或者<code>ro</code>来指定容器内目录的读写状态</p>
</blockquote>
<h3 id="5-1-4修改网站"><a href="#5-1-4修改网站" class="headerlink" title="5.1.4修改网站"></a>5.1.4<font color=brown>修改网站</font></h3><p>这个很简单，不记录了</p>
<h2 id="5-2使用Docker构建并测试Web应用程序"><a href="#5-2使用Docker构建并测试Web应用程序" class="headerlink" title="5.2使用Docker构建并测试Web应用程序"></a>5.2<font color=camel>使用Docker构建并测试Web应用程序</font></h2><p>测试一个基于<code>Sinatra的Web</code>应用程序,而不是静态网站,然后我们将基于Docker来对这个应用进行测试。</p>
<p>Sinatra是一个基于Ruby的Web应用框架,它包含一个Web应用库,以及简单的领域专用语言(即DSL)来构建Web应用程序。与其他复杂的Web应用框架(如Ruby on Rails)不同, Sinatra并不遵循MVC模式,而关注于让开发者创建快速、简单的Web应用。 </p>
<p>Sinatra非常适合用来创建一个小型的示例应用进行测试。在这个例子里,我们将创建一个应用程序,它接收输入的URL参数,并以JSON散列的结构输出到客户端。通过这个例子,我们也将展示一下如何将Docker容器链接起来。</p>
<h3 id="5-2-1-构建Sinatra应用程序"><a href="#5-2-1-构建Sinatra应用程序" class="headerlink" title="5.2.1 构建Sinatra应用程序"></a>5.2.1<font color=seagreen> 构建Sinatra应用程序</font></h3><p>我们先来创建一个sinatra目录,用来存放应用程序的代码,以及构建时我们所需的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2014-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get -y install ruby ruby-dev build-essential redis-tools</span><br><span class="line">RUN gem install --no-rdoc --no-ri sinatra json redis</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /opt/webapp</span><br><span class="line"></span><br><span class="line">EXPOSE 4567</span><br><span class="line"></span><br><span class="line">CMD [ <span class="string">&quot;/opt/webapp/bin/webapp&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/ebc9c639cf1241f7a955af0cdc752289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-2-2-创建Sinatra容器"><a href="#5-2-2-创建Sinatra容器" class="headerlink" title="5.2.2 创建Sinatra容器"></a>5.2.2 创建Sinatra容器</h3><blockquote>
<p>下载web应用程序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/sinatra]</span><br><span class="line">└─$ ls -l webapp</span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwx 1 liruilong liruilong 4096 Aug 24 22:50 bin</span><br><span class="line">drwxrwxrwx 1 liruilong liruilong 4096 Aug 24 22:50 lib</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动一个Sinatra容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d -p 4567 --name webapp -v <span class="variable">$PWD</span>/webapp:/opt/webapp jamtur01/sinatra</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看日志,进程：</p>
</blockquote>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs webapp</span><br><span class="line">docker top webapp</span><br><span class="line"><span class="comment"># 检查端口映射</span></span><br><span class="line">docker port webapp <span class="number">4567</span></span><br></pre></td></tr></table></figure>
<p>嗯，这个不知道啥原因，这个镜像没有拉下来，所以这部分没实际的搞，但是应该很简单。</p>
<h3 id="5-2-3-扩展Sinatra应用程序来使用Redis"><a href="#5-2-3-扩展Sinatra应用程序来使用Redis" class="headerlink" title="5.2.3 扩展Sinatra应用程序来使用Redis"></a>5.2.3 <font color=camel>扩展Sinatra应用程序来使用Redis</font></h3><h3 id="5-2-4-将Sinatra应用程序连接到Redis容器"><a href="#5-2-4-将Sinatra应用程序连接到Redis容器" class="headerlink" title="5.2.4 将Sinatra应用程序连接到Redis容器"></a>5.2.4 <font color=royalblue>将Sinatra应用程序连接到Redis容器</font></h3><p>现在来更新<code>Sinatra</code>应用程序,让其连接到<code>Redis</code>并存储传入的参数。为此,需要能够与<code>Redis</code>服务器对话。要做到这一点,可以用以下几种方法。</p>
<ul>
<li>Docker的内部网络。</li>
<li>从<code>Docker 1.9</code>及之后的版本开始,可以使用<code>Docker Networking</code>以及<code>docker network</code>命令。</li>
<li><code>Docker链接</code>。一个可以将具体容器链接到一起来进行通信的抽象层。</li>
</ul>
<p><strong><font color=brown>两种比较现实的连接Docker容器的方式是</font></strong></p>
<ul>
<li><code>Docker Networking</code>:如果用户正在使用Docker1.9或者更新的版本,推荐使用Docker Networking</li>
<li><code>Docker链接(Dockerlink)</code>:如果使用的是Docker 1.9之前的版本,应该选择Docker链接</li>
</ul>
<blockquote>
<p><strong><font color=seagreen>在Docker Networking和Docker链接之间也有一些区别:</font></strong></p>
</blockquote>
<ul>
<li>Docker Networking可以将容器连接到不同宿主机上的容器。通过Docker Networking连接的容器可以在无需更新连接的情况下,对停止、启动或者重启容器。</li>
<li>使用Docker链接,则可能需要更新一些配置,或者重启相应的容器来维护Docker容器之间的链接。</li>
<li>使用Docker Networking,不必事先创建容器再去连接它。同样,也不必关心容器的运行顺序,读者可以在网络内部获得容器名解析和发现。</li>
</ul>
<h3 id="5-2-5-Docker内部连网"><a href="#5-2-5-Docker内部连网" class="headerlink" title="5.2.5 Docker内部连网"></a>5.2.5 <font color=chocolate>Docker内部连网</font></h3><ul>
<li><p><code>Docker自己的网络栈</code>。到目前为止, 我们看到的<code>Docker容器都是公开端口并绑定到本地网络接口的,这样可以把容器里的服务在本地Docker宿主机所在的外部网络上(比如,把容器里的80端口绑到本地宿主机的更高端口上)公开</code>。</p>
</li>
<li><p><code>内部网络</code>。在安装Docker时,会创建一个新的网络接口,名字是docker0,每个Docker容器都会在这个接口上分配一个IP地址。来看看目前Docker宿主机上这个网络接口的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># ip a show  docker0</span></span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:cc:79:42:bd brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.1/16 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>Docker每<code>创建</code>一个<code>容器</code>就会<code>创建一组互联的网络接口</code>。这组接口就像<code>管道的两端</code>(就是说,从一端发送的数据会在另一端接收到)。这组接口其中一端作为<code>容器里的eth0接口</code>,而另一端统一命名为类似vethec6a这种名字,作为宿主机的一个端口。**<font color=tomato>可以把veth* 接口认为是虚拟网线的一端。这个虚拟网线一端插在名为dockero的网桥上,另一端插到容器里。通过把每个veth<em>接口绑定到docker0网桥, Docker创建了一个虚拟子网,这个子网由宿主机和所有的Docker容器共享。</font></em>*</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># docker run -ti centos /bin/bash</span></span><br><span class="line">Unable to find image <span class="string">&#x27;centos:latest&#x27;</span> locally</span><br><span class="line">Trying to pull repository docker.io/library/centos ...</span><br><span class="line">latest: Pulling from docker.io/library/centos</span><br><span class="line">7a0437f04f83: Pull complete</span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.io/centos:latest</span><br><span class="line">[root@badb10b3f287 /]<span class="comment"># ip a show eth0</span></span><br><span class="line">77: eth0@if78: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:12:00:05 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.18.0.5/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe12:5/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@badb10b3f287 /]<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到, Docker给容器分配了IP地址<code>172.18.0.5/16</code>作为宿主虚拟接口的另一端。这样就能够让宿主网络和容器互相通信了。让我们从容器内跟踪对外通信的路由,看看是如何建立连接的.</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@badb10b3f287 /]<span class="comment"># yum update &amp;&amp; yum install -y traceroute</span></span><br><span class="line">[root@badb10b3f287 /]<span class="comment">#  traceroute www.baodu.com</span></span><br><span class="line">traceroute to www.baodu.com (115.29.223.128), 30 hops max, 60 byte packets</span><br><span class="line"> 1  _gateway (172.18.0.1)  0.034 ms  0.011 ms  0.009 ms</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6939fdd347c84cb4a0669f287364c6fb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bGx5rKz5bey5peg5oGZ,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>不过<code>Docker</code>网络还有另一个部分配置才能允许建立连接:<code>防火墙</code>规则和<code>NAT</code>配置。这些配置允许<code>Docker</code>在宿主网络和容器间路由。现在来查看一下宿主机上的<code>IPTables NAT</code>配置</p>
<p>因此,虽然第一眼看上去这是让容器互联的一个好方案,但可惜的是,这种方法有两个大问题:</p>
<ul>
<li>第一,要在应用程序里对<code>Redis</code>容器的IP地址做硬编码:</li>
<li>第二,如果重启容器,<code>Docker</code>会改变容器的IP地址。</li>
</ul>
<h3 id="5-2-6-DockerNetworking"><a href="#5-2-6-DockerNetworking" class="headerlink" title="5.2.6 DockerNetworking"></a>5.2.6 <font color=orange>DockerNetworking</font></h3><p>容器之间的连接用网络创建,这被称为<code>Docker Networking,也是Docker 1.9</code>发布版本中的一个新特性。</p>
<p>Docker Networking允许用户创建自己的网络,容器可以通过这个网上互相通信。实质上, <code>Docker Networking</code>以新的用户管理的网络补充了现有的<code>docker0</code>,更重要的是,现在容器可以跨越不同的宿主机来通信,并且网络配置可以更灵活地定制。<code>DockerNetworking也和Docker Compose以及Swarm进行了集成.</code></p>
<blockquote>
<p>创建 Docker 网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">docker network create NetWorkUag</span><br><span class="line">docker network inspect NetWorkUag</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;NetWorkUag&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;b328ad9d659e51cdd5b9b519909101b63d88f91a1a3ace3760810df5d14ef6a9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2021-08-31T08:03:13.944961308Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.20.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.20.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;6dfd37fd7083c5cc224565ffef6657b40cf563699dc328889a79f236208c014a&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;uag_app_1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;d5a9f10ddcb10cd2002cc22606f34f9fe6c34e46b1f32a91489f506fc06cd6ad&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:14:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.20.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;736bcc999a991dcc7d3113d82845b1e162bd4bd51ba25a0a88af30098a860dd5&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;uag_app_2&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;7c9eddf8f2926246e06431667acdb1012f3b7cb69cb5b248e0b079b7d8520fb8&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:14:00:03&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.20.0.3/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;9b1bc7fe929bf2487a2a3560d6001960c5eccf7614626d7c7944372681c7e101&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;uag_app_3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;0e387e8245ac216f330ba597ee6e38cda40c3eb1dd0da10c404cf2461a01fe86&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:14:00:04&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.20.0.4/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;9d73f68b83dc731271668d63995ff6439be22b2c76c401a1b9f97d9fa1501613&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;uag_nginx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;b036d6923cb8bb769fdc60fb9e2370832c9dd26daec9e2d26d957affee7a17f6&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:14:00:05&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;172.20.0.5/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>除了运行于单个主机之上的桥接网络,我们也可以创建一个overlay网络, overlay&quot;网络允许我们跨多台宿主机进行通信。</code></p>
<p><strong><font color=royalblue>Docker在默认情况下，分别会建立一个bridge、一个host和一个none的网络：</font></strong></p>
<p>网络模式简介</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>容器将不会虚拟出自己的网卡,配置自己的IP等,而是使用宿主机的IP和端口.</td>
</tr>
<tr>
<td>Bridge</td>
<td>此模式会为每一个容器分配、设置IP等,并将容器连接到一个<code>docker0</code>虚拟网桥,通过<code>docker0网桥以及iptables nat表配置与宿主机通信</code></td>
</tr>
<tr>
<td>None</td>
<td>该模式关闭了容器的网络功能</td>
</tr>
<tr>
<td>Container</td>
<td>创建的容器不会创建自己的网卡,配置自己的IP,<code>而是和一个指定的容器共享</code></td>
</tr>
</tbody></table>
<p>Docker内置这三个网络，运行容器时，你可以使用该<code>–network</code>标志来指定容器应连接到哪些网络,该<code>bridge</code>网络代表<code>docker0所有Docker安装中存在的网络(默认使用桥接)</code>,除非你使用该d<code>ocker run --network=</code>选项指定，否则<code>Docker</code>守护程序默认将容器连接到此网络</p>
<blockquote>
<p>列出当前系统的所有网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">b328ad9d659e        NetWorkUag          bridge              <span class="built_in">local</span></span><br><span class="line">05db24cdbfe4        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">017b16936585        express             bridge              <span class="built_in">local</span></span><br><span class="line">0f48492ddb93        host                host                <span class="built_in">local</span></span><br><span class="line">ac3009db29a8        none                null                <span class="built_in">local</span></span><br><span class="line">75656b057386        uag_net             bridge              <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/uag/uag_nginx]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>–net标志指定了新容器将会在哪个网络中运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p 8069:8080 --net NetWorkUag --name uag_app_3  417264b76b2b</span><br></pre></td></tr></table></figure>
<p>network这里书里的Demo，镜像一直没搞好，所以自己搞了一个，感兴趣小伙伴可以移步：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sanhewuyang/article/details/120004323">基于Docker部署 Tomcat集群、 Nginx负载均衡</a></p>
<blockquote>
<p>将已有容器连接到Docker网络也可以将正在运行的容器通过<code>docker network connect</code>命令添加到已有的网络中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect 网络名 容器名</span><br></pre></td></tr></table></figure>
<blockquote>
<p>断开</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect 网络名 容器名</span><br></pre></td></tr></table></figure>
<p>**<font color=tomato>·一个容器可以同时隶属于多个Dcoker网络,所以可以创建非常复杂的网络模型</font>**。<br>2. 通过Docker 链接来连接容器<br>这块时间原因，只做简单整理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4561 --name webapp --link redis:db -it 镜像名</span><br></pre></td></tr></table></figure>
<p><code>--link</code>标志创建了两个容器间的<code>客户-服务链接</code>。这个标志需要两个参数:一个是要链接的容器的名字,另一个是链接的别名。</p>
<p>这个例子中,我们创建了客户联系, <code>webapp容器是客户, redis容器是“服务”,并且为这个服务增加了db作为别名</code>。这个别名让我们可以一致地访问容器公开的信息,而无须关注底层容器的名字。</p>
<p>链接让服务容器有能力与客户容器通信,并且能分享一些连接细节,这些细节有助于在应用程序中配置并使用这个链接。连接也能得到一些安全上的好处。</p>
<p><code>启动Redis容器时,并没有使用-p标志公开Redis的端口</code>。因为不需要这么做。<code>通过把容器链接在一起,可以让客户容器直接访问任意服务容器的公开端口(即客户webapp容器可以连接到服务redis容器的6379端口)</code>.</p>
<p><code>只有使用--1ink标志链接到这个容器的容器才能连接到这个端口</code>。<code>容器的端口不需要对本地宿主机公开,现在我们已经拥有一个非常安全的模型</code>,通过这个安全模型,就可以限制容器化应用程序被攻击面,减少应用暴露的网络。</p>
<p>如果用户希望,<code>出于安全原因(或者其他原因),可以强制Docker只允许有链接的容器之,间互相通信</code>。为此,可以在<code>启动Docker守护进程时加上--icc=false标志</code>,关闭所有没有链接的容器间的通信。</p>
<p>查看容器是如何链接在一起的。 <code>Docker</code>在父容器里的以下两个地方写入了链接信息。</p>
<ul>
<li><strong><font color=tomato>&#x2F;etc&#x2F;hosts文件中。</font></strong></li>
<li><strong><font color=tomato>包含连接信息的环境变量中。</font></strong></li>
</ul>
<p>容器的主机名也可以不是其ID的一部分。可以在执行<code>docker run</code>命令时使用<code>-h或者--hostname</code>标志来为容器设定主机名。 </p>
<p>如果在运行容器时指定<code>--add-host</code>选项,也可以在<code>/etc/hosts</code>文件中添加相应的·记录。例如,我们可能想添加运行Docker的主机的主机名和IP地址到容器中,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --add-host=docker:10.0.0.1 .....</span><br></pre></td></tr></table></figure>
<h3 id="5-2-7-使用容器连接来通信"><a href="#5-2-7-使用容器连接来通信" class="headerlink" title="5.2.7 使用容器连接来通信"></a>5.2.7 <font color=purple>使用容器连接来通信</font></h3><p>那么如何使用这个连接呢?有以下两种方法可以让应用程序连接到Redis.</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong><font color=brown>使用环境变量里的一些连接信息。</font></strong></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/bc96cc39820a4074af394a13736403dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bGx5rKz5bey5peg5oGZ,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/d60b581899cf498fae5d51b4495abbc1.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td><strong><font color=orange>使用DNS和&#x2F;etc&#x2F;hosts信息。</font></strong></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/75fed2bed3e14f65a16e8ee0035399a9.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>也可以在<code>docker run命令中加入--dns或者--dns-search标志来为某个容器单独配置DNS</code>。你可以设置本地DNS解析的路径和搜索城。在https:&#x2F;docs.docker.com&#x2F;articlesnetworking&#x2F;上可以找到更详细的配置信息。如果没有这两个标志, Docker会根据宿主机的信息来配置DNS解析。可以在&#x2F;etc&#x2F;resolv.conf文件中查看DNS解析的配置情况。</td>
</tr>
</tbody></table>
<h3 id="5-3-Docker用于持续集成"><a href="#5-3-Docker用于持续集成" class="headerlink" title="5.3 Docker用于持续集成"></a>5.3 Docker用于持续集成</h3><h1 id="第6章使用Docker构建服务"><a href="#第6章使用Docker构建服务" class="headerlink" title="第6章使用Docker构建服务"></a><font color=tomato>第6章使用Docker构建服务</font></h1><h2 id="6-1-构建第一个应用"><a href="#6-1-构建第一个应用" class="headerlink" title="6.1　构建第一个应用"></a>6.1　<font color=amber>构建第一个应用</font></h2><p>使用<code>Jekyll</code>框架的自定义网站。我们会构建以下两个镜像。</p>
<ul>
<li>一个镜像安装了Jekyll及其他用于构建Jekyll网站的必要的软件包。</li>
<li>一个镜像通过Apache来让Jekyll网站工作起来。</li>
</ul>
<p>我们打算在启动容器时,通过创建一个新的Jekyll网站来实现自服务。工作流程如下。</p>
<ul>
<li>创建Jekyll基础镜像和Apache镜像(只需要构建一次)。</li>
<li>从Jekyll镜像创建一个容器,这个容器存放通过卷挂载的网站源代码。</li>
<li>从Apache镜像创建一个容器,这个容器利用包含编译后的网站的卷,并为其服务。<br>在网站需要更新时,清理并重复上面的步骤。</li>
</ul>
<p>可以把这个例子看作是创建一个<code>多主机站点</code>最简单的方法。实现很简单,本章后半部分会以这个例子为基础做更多扩展。</p>
<h3 id="6-1-1-Jekyll基础镜像"><a href="#6-1-1-Jekyll基础镜像" class="headerlink" title="6.1.1 Jekyll基础镜像"></a>6.1.1 <font color=brown>Jekyll基础镜像</font></h3><p>编写jekyll对应的<code>Dockerfile</code>文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install ruby ruby-dev libffi-dev build-essential nodejs</span><br><span class="line">RUN gem install --no-rdoc --no-ri jekyll -v 2.5.3</span><br><span class="line"></span><br><span class="line">VOLUME /data</span><br><span class="line">VOLUME /var/www/html</span><br><span class="line">WORKDIR /data</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;jekyll&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;--destination=/var/www/html&quot;</span> ]</span><br></pre></td></tr></table></figure>
<ul>
<li>镜像基于Ubuntu 14.04,并且安装了Ruby和用于支持Jekyll的包。然后我们使用VOLUME指令创建了以下两个卷。,&#x2F;data&#x2F;,用来存放网站的源代码。.&#x2F;var&#x2F;www&#x2F;htm1&#x2F;,用来存放编译后的Jekyll网站码然后我们需要将工作目录设置到&#x2F;data&#x2F;,并通过ENTRYPOINT指令指定自动构建的命令,这个命令会将工作目录&#x2F;data&#x2F;中的所有的Jekyll网站代码构建到&#x2F;var&#x2F;www&#x2F;html&#x2F;目录中。</li>
</ul>
<h3 id="6-1-2-构建Jekyl基础镜像"><a href="#6-1-2-构建Jekyl基础镜像" class="headerlink" title="6.1.2 构建Jekyl基础镜像"></a>6.1.2 <font color=seagreen>构建Jekyl基础镜像</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker&gt; bash</span><br><span class="line">┏━(Message from Kali developers)</span><br><span class="line">┃</span><br><span class="line">┃ This is a minimal installation of Kali Linux, you likely</span><br><span class="line">┃ want to install supplementary tools. Learn how:</span><br><span class="line">┃ ⇒ https://www.kali.org/docs/troubleshooting/common-minimum-setup/</span><br><span class="line">┃</span><br><span class="line">┗━(Run: “touch ~/.hushlogin” to hide this message)</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ mkdir jekyll</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ <span class="built_in">cd</span> jekyll/;vim Dockerfile</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/jekyll]</span><br><span class="line">└─$ sudo docker build -t jamtur01/jekyll .</span><br><span class="line">[sudo] password <span class="keyword">for</span> liruilong:</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/10 : FROM ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">feac53061382: Pull complete</span><br><span class="line">Digest: sha256:7bd7a9ca99f868bf69c4b6212f64f2af8e243f97ba13abb3e641e03a7ceb59e8</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/10 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d11e8cdaf982</span><br><span class="line">Removing intermediate container d11e8cdaf982</span><br><span class="line">。。。。</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-Apache镜像"><a href="#6-1-3-Apache镜像" class="headerlink" title="6.1.3 Apache镜像"></a>6.1.3 <font color=plum>Apache镜像</font></h3><p>构建 apache Dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install apache2</span><br><span class="line">VOLUME [<span class="string">&quot;/var/www/html&quot;</span>]</span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义环境变量</span></span><br><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/<span class="built_in">log</span>/apache2</span><br><span class="line">ENV APACHE_PID_FILE /var/run/apache2.pid</span><br><span class="line">ENV APACHE_RUN_DIR /var/run/apache2</span><br><span class="line">ENV APACHE_LOCK_DIR /var/lock/apache2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line">RUN mkdir -p <span class="variable">$APACHE_RUN_DIP</span> <span class="variable">$APACHE_LOCK_DIR</span> <span class="variable">$APACHE_LOG_DIR</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;/usr/sbin/apachectl&quot;</span> ]</span><br><span class="line"><span class="comment"># 脚本执行参数</span></span><br><span class="line">CMD [ <span class="string">&quot;-D&quot;</span>, <span class="string">&quot;FOREGROUND&quot;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>这个镜像也是基于Ubuntu 14.04的,并安装了Apache。然后我们使用VOLUME指令创建了一个卷,即&#x2F;var&#x2F;www&#x2F;html&#x2F;,用来存放编译后的Jekyll网站。</li>
<li>将&#x2F;var&#x2F;www&#x2F;html设为工作目录。然后我们使用ENV指令设置了一些必要的环境变量,创建了必要的目录,并且使用EXPOSE公开了80端口。最后指定了ENTRYPOINT和CMD指令组合来在容器启动时默认运行Apache</li>
</ul>
<h3 id="6-1-4-构建Jekyll-Apache镜像"><a href="#6-1-4-构建Jekyll-Apache镜像" class="headerlink" title="6.1.4 构建Jekyll Apache镜像"></a>6.1.4 <font color=tomato>构建Jekyll Apache镜像</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/apache]</span><br><span class="line">└─$ sudo docker  build -t jamtur01/apache .</span><br><span class="line">Sending build context to Docker daemon   2.56kB</span><br><span class="line">Step 1/16 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/16 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 4a85ddbb7c6b</span><br><span class="line">Step 3/16 : RUN apt-get -qq update</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 7de58bfe1ad6</span><br><span class="line">.....</span><br><span class="line">Successfully built 2d17448b9728</span><br><span class="line">Successfully tagged jamtur01/apache:latest</span><br></pre></td></tr></table></figure>
<h3 id="6-1-5-启动Jekyll网站"><a href="#6-1-5-启动Jekyll网站" class="headerlink" title="6.1.5 启动Jekyll网站"></a>6.1.5 <font color=chocolate>启动Jekyll网站</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\jekyll&gt; git <span class="built_in">clone</span> git@github.com:turnbullpress/james_blog.git</span><br><span class="line">Cloning into <span class="string">&#x27;james_blog&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 96, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 96 (delta 0), reused 0 (delta 0), pack-reused 96R</span><br><span class="line">Receiving objects: 100% (96/96), 224.81 KiB | 339.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (9/9), <span class="keyword">done</span>.</span><br><span class="line">PS E:\docker\jekyll&gt; ls</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ sudo docker run -v /mnt/e/docker/james_blog:/data/  --name james_blog jamtur01/jekyll</span><br><span class="line">Configuration file: /data/_config.yml</span><br><span class="line">            Source: /data</span><br><span class="line">       Destination: /var/www/html</span><br><span class="line">      Generating...</span><br><span class="line">                    <span class="keyword">done</span>.</span><br><span class="line"> Auto-regeneration: disabled. Use --watch to <span class="built_in">enable</span>.</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>我们启动了一个叫作<code>james blog的新容器</code>,把<code>本地的james blog目录作为/data/卷挂载到容器里</code>。容器已经拿到网站的源代码,并将其构建到已编译的网站,<code>存放到/var/www/html/目录</code>。<code>卷是在一个或多个容器中特殊指定的目录,卷会绕过联合文件系统,为持久化数据和共享数据提供几个有用的特性。</code></p>
<p>**<font color=chocolate>卷可以在容器间共享和重用</font>**。共享卷时不一定要运行相应的容器。对卷的修改会直接在卷上反映出来。更新镜像时不会包含对卷的修改。卷会一直存在,直到没有容器使用它们。</p>
<p><strong><font color=orange>利用卷,可以在不用提交镜像修改的情况下,向镜像里加入数据(如源代码、数据或者.其他内容),并且可以在容器间共享这些数据。卷在Docker宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes目录中。可以通过docker inspect命令查看某个卷的具体位置,如docker inspect-f “{( range .Mounts }}1f.}}lend}}”。<br></font></strong><br>所以,如果想在另一个容器里使用&#x2F;var&#x2F;www&#x2F;htm1&#x2F;卷里编译好的网站,可以创建个新的链接到这个卷的容器,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ sudo docker run -d -P --volumes-from james_blog jamtur01/apache</span><br><span class="line">04683efb9f7bb1cb0e2729d480f62d7474917a5d21bec64a6361cef28850c565</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">04683efb9f7b        jamtur01/apache     <span class="string">&quot;/usr/sbin/apachectl…&quot;</span>   17 seconds ago      Up 16 seconds       0.0.0.0:32769-&gt;80/tcp   loving_chatelet</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p><strong><font color=purple>–volumes-from标志</font></strong><br>–volumes-from把指定容器里的所有卷都加入新创建的容器里。这意味着, Apache容器可以访问之前创建的james-blog容器里&#x2F;var&#x2F;www&#x2F;html卷中存放的编译后的Jekyl网站。即便james blog容器没有运行, Apache容器也可以访问这个卷。想想,这只是卷的特性之一。不过,容器本身必须存在。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/jekyll]</span><br><span class="line">└─$ docker port ddbe29b5c188 80</span><br><span class="line">0.0.0.0:32768</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/jekyll]</span><br><span class="line">└─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS</span><br><span class="line">   PORTS                   NAMES</span><br><span class="line">ddbe29b5c188        jamtur01/apache     <span class="string">&quot;/usr/sbin/apachectl…&quot;</span>   6 minutes ago       Up 6 minutes        0.0.0.0:32768-&gt;80/tcp   nostalgic_einstein</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/jekyll]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p>查看一下容器把已公开的80端口映射到了哪个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ docker port 04683efb9f7b 80 | xargs curl</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta name=<span class="string">&quot;author&quot;</span> content=<span class="string">&quot;James Turnbull&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">&quot;/assets/themes/bootstrap/resources/bootstrap/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--[<span class="keyword">if</span> lt IE 9]&gt;</span><br><span class="line">      &lt;script src=<span class="string">&quot;/assets/themes/bootstrap/resources/respond/Respond.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;![endif]--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link href=<span class="string">&quot;/atom.xml&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;application/atom+xml&quot;</span> rel=<span class="string">&quot;alternate&quot;</span> title=<span class="string">&quot;Sitewide ATOM Feed&quot;</span>&gt;</span><br><span class="line">    &lt;link href=<span class="string">&quot;/rss.xml&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;application/rss+xml&quot;</span> rel=<span class="string">&quot;alternate&quot;</span> title=<span class="string">&quot;Sitewide RSS Feed&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/jekyll]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ed0082969dd7454bbe9b367cfa974b1e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="6-1-6-更新Jekyll网站"><a href="#6-1-6-更新Jekyll网站" class="headerlink" title="6.1.6 更新Jekyll网站"></a>6.1.6 <font color=orange>更新Jekyll网站</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/james_blog]</span><br><span class="line">└─$ vim _config.yml</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/james_blog]</span><br><span class="line">└─$ cat _config.yml | grep title</span><br><span class="line">permalink: /:categories/:year/:month/:day/:title</span><br><span class="line">title : 山河已无恙的 Blog</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/james_blog]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/58cf45bd2c8c45769c9aba7bb2967164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="6-1-7-备份Jekyll卷"><a href="#6-1-7-备份Jekyll卷" class="headerlink" title="6.1.7 备份Jekyll卷"></a>6.1.7 <font color=chocolate>备份Jekyll卷</font></h3><p>由于<code>卷的优点之一就是可以挂载到任意容器</code>,因此可以轻松备份它们。现在创建一个新容器,用来备份&#x2F;var&#x2F;www&#x2F;html卷.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/james_blog]</span><br><span class="line">└─$ sudo docker run --rm --volumes-from james_blog \</span><br><span class="line">&gt; -v $(<span class="built_in">pwd</span>):/backup ubuntu  \</span><br><span class="line">&gt; tar cvf /backup/james_blog_backup.tar /var/www/html</span><br><span class="line">Unable to find image <span class="string">&#x27;ubuntu:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">16ec32c2132b: Pull complete</span><br><span class="line">Digest: sha256:82becede498899ec668628e7cb0ad87b6e1c371cb8a1e597d83a47fac21d6af3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br><span class="line">tar: Removing leading `/<span class="string">&#x27; from member names</span></span><br><span class="line"><span class="string">/var/www/html/</span></span><br><span class="line"><span class="string">/var/www/html/tags.html</span></span><br><span class="line"><span class="string">/var/www/html/sitemap.txt</span></span><br><span class="line"><span class="string">/var/www/html/History.markdown</span></span><br><span class="line"><span class="string">/var/www/html/assets/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行了一个已有的Ubuntu容器,并把james_blog的卷挂载到该容器里。会在该容器里创建&#x2F;var&#x2F;www&#x2F;html目录。</li>
<li>使用-v标志把当前目录(通过$(pwd)命令获得)挂载到容器的&#x2F;backup 目录。</li>
<li>运行这一备份命令.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/9d1da2cb333442dc9291d56f8ce255db.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>–rm标志,这个标志对于只用一次的容器,或者说用完即扔的容器,很有”用。这个标志会在容器的进程运行完毕后, 自动删除容器。</p>
</blockquote>
<h3 id="6-1-8-扩展Jekyll示例网站"><a href="#6-1-8-扩展Jekyll示例网站" class="headerlink" title="6.1.8 扩展Jekyll示例网站"></a>6.1.8 <font color=camel>扩展Jekyll示例网站</font></h3><ul>
<li>运行多个Apache容器,这些容器都使用来自james blog容器的卷。在这些Apache容器前面加一个负载均衡器,我们就拥有了一个Web集群。</li>
<li>进一步构建一个镜像,这个镜像把用户提供的源数据复制(如通过git clone)到,卷里。再把这个卷挂载到从jamtur01&#x2F;jeky11镜像创建的容器。这就是一个可迁移的通用方案,而且不需要宿主机本地包含任何源代码。</li>
<li>在上一个扩展基础上可以很容易为我们的服务构建一个Web前端,这个服务用于从指定的源自动构建和部署网站。这样用户就有一个完全属于自己的GitHub Pages了。</li>
</ul>
<h2 id="6-2-使用Docker构建一个Java应用服务"><a href="#6-2-使用Docker构建一个Java应用服务" class="headerlink" title="6.2 使用Docker构建一个Java应用服务"></a>6.2 <font color=red>使用Docker构建一个Java应用服务</font></h2><ul>
<li>一个镜像从URL拉取指定的WAR文件并将其保存到卷里。</li>
<li>一个含有Tomcat服务器的镜像运行这些下载的WAR文件。</li>
</ul>
<h3 id="6-2-1-WAR文件的获取程序"><a href="#6-2-1-WAR文件的获取程序" class="headerlink" title="6.2.1 WAR文件的获取程序"></a>6.2.1 <font color=yellowgreen>WAR文件的获取程序</font></h3><p>编写 Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">└─$ cat Dockerfile</span><br><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install wget</span><br><span class="line"></span><br><span class="line">VOLUME [ <span class="string">&quot;/var/lib/tomcat8/webapps/&quot;</span> ]</span><br><span class="line">WORKDIR /var/lib/tomcat8/webapps/</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;wget&quot;</span> ]</span><br><span class="line">CMD [ <span class="string">&quot;--help&quot;</span> ]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ d=fetcher</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ mkdir <span class="variable">$d</span>;<span class="built_in">cd</span> <span class="variable">$d</span>;touch Dockerfile</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/fetcher]</span><br><span class="line">└─$</span><br><span class="line">└─$ sudo docker build -t jamtur01/fetcher .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/9 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/9 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">....</span><br><span class="line">Removing intermediate container ce9fd25a25e2</span><br><span class="line"> ---&gt; 392da3b6713a</span><br><span class="line">Successfully built 392da3b6713a</span><br><span class="line">Successfully tagged jamtur01/fetcher:latest</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-获取WAR文件"><a href="#6-2-2-获取WAR文件" class="headerlink" title="6.2.2 获取WAR文件"></a>6.2.2 <font color=chocolate>获取WAR文件</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/fetcher]</span><br><span class="line">└─$ sudo docker run -t -i --name sample jamtur01/fetcher https://tomcat.apache.org/tomcat-7.0-doc/appd</span><br><span class="line">ev/sample/sample.war</span><br><span class="line">--2021-08-23 12:59:56--  https://tomcat.apache.org/tomcat-7.0-doc/appdev/sample/sample.war</span><br><span class="line">Resolving tomcat.apache.org (tomcat.apache.org)... 151.101.2.132, 2a04:4e42::644</span><br><span class="line">Connecting to tomcat.apache.org (tomcat.apache.org)|151.101.2.132|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 4606 (4.5K)</span><br><span class="line">Saving to: <span class="string">&#x27;sample.war&#x27;</span></span><br><span class="line"></span><br><span class="line">sample.war                100%[===================================&gt;]   4.50K  --.-KB/s    <span class="keyword">in</span> 0s</span><br><span class="line"></span><br><span class="line">2021-08-23 12:59:58 (23.1 MB/s) - <span class="string">&#x27;sample.war&#x27;</span> saved [4606/4606]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/fetcher]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>可以看到,<code>容器通过提供的URL下载了sample.war文件。从输出结果看不出最终的保存路径,但是因为设置了容器的工作目录, sample.war文件最终会保存到/var/lib/tomcat7/webapps/目录中</code>。可以在&#x2F;var&#x2F;1ib&#x2F;docker目录找到这个WAR文件。</p>
<h3 id="6-2-3-Tomecat8应用服务器"><a href="#6-2-3-Tomecat8应用服务器" class="headerlink" title="6.2.3 Tomecat8应用服务器"></a>6.2.3 <font color=camel>Tomecat8应用服务器</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ d=tomcat8;mkdir <span class="variable">$d</span>;<span class="built_in">cd</span> <span class="variable">$d</span>;touch Dockerfile</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ vim Dockerfile</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install tomcat8 default-jdk</span><br><span class="line"></span><br><span class="line">ENV CATALINA_HOME /usr/share/tomcat8</span><br><span class="line">ENV CATALINA_BASE /var/lib/tomcat8</span><br><span class="line">ENV CATALINA_PID /var/run/tomcat8.pid</span><br><span class="line">ENV CATALINA_SH /usr/share/tomcat8/bin/catalina.sh</span><br><span class="line">ENV CATALINA_TMPDIR /tmp/tomcat8-tomcat8-tmp</span><br><span class="line"></span><br><span class="line">RUN mkdir -p <span class="variable">$CATALINA_TMPDIR</span></span><br><span class="line"></span><br><span class="line">VOLUME [ <span class="string">&quot;/var/lib/tomcat8/webapps/&quot;</span> ]</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;/usr/share/tomcat8/bin/catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span> ]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ sudo docker build -t jamtur01/tomcat8 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/14 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/14 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ....</span><br><span class="line">  ---&gt; 661bc99d59a1</span><br><span class="line">Successfully built 661bc99d59a1</span><br><span class="line">Successfully tagged jamtur01/tomcat8:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-2-4-运行WAR文件"><a href="#6-2-4-运行WAR文件" class="headerlink" title="6.2.4 运行WAR文件"></a>6.2.4 <font color=seagreen>运行WAR文件</font></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ sudo docker run --name sample_app --volumes-from sample -d -P jamtur01/tomcat8</span><br><span class="line">[sudo] password <span class="keyword">for</span> liruilong:</span><br><span class="line">41d491b0dbeeebb921872f9a3002e9732eecc93fd607dc182247527480a42bfe</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">41d491b0dbee        jamtur01/tomcat8    <span class="string">&quot;/usr/share/tomcat8/…&quot;</span>   21 seconds ago      Up 19 seconds       0.0.0.0:32770-&gt;8080/tcp   sample_app</span><br><span class="line">04683efb9f7b        jamtur01/apache     <span class="string">&quot;/usr/sbin/apachectl…&quot;</span>   5 hours ago         Up 5 hours          0.0.0.0:32769-&gt;80/tcp     loving_chatelet</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ curl http://0.0.0.0:32770/sample/</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Sample <span class="string">&quot;Hello, World&quot;</span> Application&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=white&gt;</span><br><span class="line"></span><br><span class="line">&lt;table border=<span class="string">&quot;0&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/fe06da8074b54d4489b540fd85a58de9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这会创建一个名为<code>sample-app的容器</code>,这个容器会<code>复用sample容器里的</code>卷。这意味着<code>存储在/var/lib/tomcat7/webapps/卷里的WAR文件会从sample容器挂载到, sample_app容器,最终被Tomcat加载并执行</code>。让我们在Web浏览器里看看这个示例程序。首先,我们必须使用docker port命令找出被公开的端口,如代码清单6-28所示。 </p>
<h3 id="6-2-5-基于Tomcat应用服务器的构建服务"><a href="#6-2-5-基于Tomcat应用服务器的构建服务" class="headerlink" title="6.2.5 基于Tomcat应用服务器的构建服务"></a>6.2.5 <font color=purple>基于Tomcat应用服务器的构建服务</font></h3><h2 id="6-3-多容器的应用栈"><a href="#6-3-多容器的应用栈" class="headerlink" title="6.3 多容器的应用栈"></a>6.3 <font color=amber>多容器的应用栈</font></h2><ul>
<li>一个Node容器,用来服务于Node应用,这个容器会链接到。</li>
<li>一个Redis主容器,用于保存和集群化应用状态,这个容器会链接到。</li>
<li>两个Redis副本容器,用于集群化应用状态。</li>
<li>一个日志容器,用于捕获应用日志。</li>
</ul>
<h3 id="6-3-1-Node-js镜像"><a href="#6-3-1-Node-js镜像" class="headerlink" title="6.3.1 Node.js镜像"></a>6.3.1 <font color=yellowgreen>Node.js镜像</font></h3><p>先从构建一个安装了Nodejs的镜像开始,这个镜像有Express应用和相应的必要的软件包,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/docker]</span><br><span class="line">└─$ mkdir nodejs;<span class="built_in">cd</span> nodejs;mkdir -p nodeapp;<span class="built_in">cd</span> nodeapp</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/docker/nodejs/nodeapp]</span><br><span class="line">└─$ vim package.json</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/docker/nodejs/nodeapp]</span><br><span class="line">└─$ vim server.js</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/docker/nodejs/nodeapp]</span><br><span class="line">└─$ vim Dockerfile</span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;docker-dev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Docker Dev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;connect-redis&quot;</span>: <span class="string">&quot;~3.4.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;express&quot;</span>: <span class="string">&quot;&gt;=3.11.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;express-session&quot;</span>: <span class="string">&quot;~1.15.6&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cookie-parser&quot;</span>: <span class="string">&quot;~1.4.3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;morgan&quot;</span>: <span class="string">&quot;~1.9.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;hiredis&quot;</span>: <span class="string">&quot;~0.5.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;redis&quot;</span>: <span class="string">&quot;~0.10.3&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>),</span><br><span class="line">    session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line">    cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>)</span><br><span class="line">    morgan = <span class="built_in">require</span>(<span class="string">&#x27;morgan&#x27;</span>)</span><br><span class="line">    app = express(),</span><br><span class="line">    redis = <span class="built_in">require</span>(<span class="string">&#x27;redis&#x27;</span>),</span><br><span class="line">    RedisStore = <span class="built_in">require</span>(<span class="string">&#x27;connect-redis&#x27;</span>)(session),</span><br><span class="line">    server = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>).createServer(app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logFile = fs.createWriteStream(<span class="string">&#x27;/var/log/nodeapp/nodeapp.log&#x27;</span>, &#123;<span class="attr">flags</span>: <span class="string">&#x27;a&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">app.use(morgan(<span class="string">&#x27;combined&#x27;</span>, &#123;<span class="attr">stream</span>: logFile&#125;));</span><br><span class="line">app.use(cookieParser(<span class="string">&#x27;keyboard-cat&#x27;</span>));</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">        <span class="attr">resave</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">saveUninitialized</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">store</span>: <span class="keyword">new</span> RedisStore(&#123;</span><br><span class="line">            <span class="attr">host</span>: process.env.REDIS_HOST || <span class="string">&#x27;redis_primary&#x27;</span>,</span><br><span class="line">            <span class="attr">port</span>: process.env.REDIS_PORT || <span class="number">6379</span>,</span><br><span class="line">            <span class="attr">db</span>: process.env.REDIS_DB || <span class="number">0</span></span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="attr">secret</span>: <span class="string">&#x27;keyboard cat&#x27;</span>,</span><br><span class="line">        <span class="attr">cookie</span>: &#123;</span><br><span class="line">            <span class="attr">expires</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">maxAge</span>: <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;ok&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/hello/:name&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    <span class="attr">hello</span>: req.params.name</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = process.env.HTTP_PORT || <span class="number">3000</span>;</span><br><span class="line">server.listen(port);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Listening on port &#x27;</span> + port);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install nodejs npm</span><br><span class="line">RUN mkdir -p /var/<span class="built_in">log</span>/nodeapp</span><br><span class="line"></span><br><span class="line">ADD nodeapp /opt/nodeapp/</span><br><span class="line"></span><br><span class="line">WORKDIR /opt/nodeapp</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">VOLUME [ <span class="string">&quot;/var/log/nodeapp&quot;</span> ]</span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;nodejs&quot;</span>, <span class="string">&quot;server.js&quot;</span> ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">└─$ sudo docker build -t jamtur01/nodejs .</span><br><span class="line">Sending build context to Docker daemon  5.632kB</span><br><span class="line">Step 1/12 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/12 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line">......</span><br><span class="line">  ---&gt; 7bb107b82dc7</span><br><span class="line">Successfully built 7bb107b82dc7</span><br><span class="line">Successfully tagged jamtur01/nodejs:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-3-2-Redis基础镜像"><a href="#6-3-2-Redis基础镜像" class="headerlink" title="6.3.2 Redis基础镜像"></a>6.3.2 <font color=royalblue>Redis基础镜像</font></h3><p>现在我们继续构建第一个Redis镜像<code>:安装Redis的基础镜像</code>。然后我们会使用这个镜像构建Redis主镜像和副本镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ mkdir redis_bash;<span class="built_in">cd</span> redis_bash ;vim Dockerfile</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_bash]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2017-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get install -qq software-properties-common</span><br><span class="line">RUN add-apt-repository ppa:chris-lea/redis-server</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install redis-server redis-tools</span><br><span class="line"></span><br><span class="line">VOLUME [ <span class="string">&quot;/var/lib/redis&quot;</span>, <span class="string">&quot;/var/log/redis&quot;</span> ]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line"></span><br><span class="line">CMD []</span><br></pre></td></tr></table></figure>

<p>这个Redis基础镜像安装了最新版本的Redis (从PPA库安装,而不是使用Ubuntu自带的较老的Redis包),<code>指定了两个VOLUME (/var/lib/redis和/var/log/redis),公开了Redis的默认端口6379,因为不会执行这个镜像,所以没有包含ENTRYPOINT或者CMD指令</code>。然后我们将只是基于这个镜像构建别的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_bash]</span><br><span class="line">└─$ sudo docker build -t jamtu01/redis .</span><br><span class="line">[sudo] password <span class="keyword">for</span> liruilong:</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/11 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">....</span><br><span class="line">Removing intermediate container 55c8ff1eb524</span><br><span class="line"> ---&gt; 9b06351c0489</span><br><span class="line">Successfully built 9b06351c0489</span><br><span class="line">Successfully tagged jamtu01/redis:latest</span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-Redis主镜像"><a href="#6-3-3-Redis主镜像" class="headerlink" title="6.3.3 Redis主镜像"></a>6.3.3 <font color=seagreen>Redis主镜像</font></h3><p>我们继续构建第一个Redis镜像,即Redis主服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8]</span><br><span class="line">└─$ d=redis_primary;mkdir <span class="variable">$d</span>;<span class="built_in">cd</span> <span class="variable">$d</span>;vim Dockerfile</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary]</span><br><span class="line">└─$</span><br><span class="line">FROM jamtur01/redis</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"><span class="comment">#关闭密码检测 指定日志位置</span></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--protected-mode no&quot;</span>, <span class="string">&quot;--logfile /var/log/redis/redis-server.log&quot;</span> ]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary]</span><br><span class="line">└─$ sudo docker build -t jamtur01/redis_primary .</span><br><span class="line">[sudo] password <span class="keyword">for</span> liruilong:</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM jamtur01/redis</span><br><span class="line">Removing intermediate container cc572817ea4e</span><br><span class="line"> ---&gt; 55dd53f5a2e4</span><br><span class="line">Successfully built 55dd53f5a2e4</span><br><span class="line">Successfully tagged jamtur01/redis_primary:latest</span><br></pre></td></tr></table></figure>
<h3 id="6-3-4-Redis副本镜像"><a href="#6-3-4-Redis副本镜像" class="headerlink" title="6.3.4 Redis副本镜像"></a>6.3.4 <font color=plum>Redis副本镜像</font></h3><p>为了配合Redis主镜像,我们会创建Redis副本镜像,保证为Node.js应用提供Redis服务的冗余度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary]</span><br><span class="line">└─$ d=redis_replica;mkdir <span class="variable">$d</span>;<span class="built_in">cd</span> <span class="variable">$d</span>;touch Dockerfile</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary/redis_replica]</span><br><span class="line">└─$ vim Dockerfile</span><br><span class="line"></span><br><span class="line">FROM jamtur01/redis</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"><span class="comment">#通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</span></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--protected-mode no&quot;</span>, <span class="string">&quot;--logfile /var/log/redis/redis-replica.log&quot;</span>, <span class="string">&quot;--slaveof redis_primary 6379&quot;</span> ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary/redis_replica]</span><br><span class="line">└─$ sudo docker build -t jamtur01/redis_replica .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM jamtur01/redis</span><br><span class="line"> ---&gt; d6570236145a</span><br><span class="line">Step 2/4 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 6a4d1ac13f2b</span><br><span class="line">Step 3/4 : ENV REFRESHED_AT 2016-06-01</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 124cc316623b</span><br><span class="line">Step 4/4 : ENTRYPOINT [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--protected-mode no&quot;</span>, <span class="string">&quot;--logfile /var/log/redis/redis-replica.log&quot;</span>, <span class="string">&quot;--slaveof redis_primary 6379&quot;</span> ]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> cc04596788c9</span><br><span class="line">Removing intermediate container cc04596788c9</span><br><span class="line"> ---&gt; 2a28f368f7ab</span><br><span class="line">Successfully built 2a28f368f7ab</span><br><span class="line">Successfully tagged jamtur01/redis_replica:latest</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary/redis_replica]</span><br></pre></td></tr></table></figure>

<h3 id="6-3-5-创建Redis后端集群"><a href="#6-3-5-创建Redis后端集群" class="headerlink" title="6.3.5 创建Redis后端集群"></a>6.3.5 <font color=chocolate>创建Redis后端集群</font></h3><p>现在我们已经有了<code>Redis主镜像和副本镜像</code>,已经可以构建我们<code>自己的Redis复制环境</code>了。首先我们<code>创建一个用来运行我们的Express应用程序的网络,我们称其为express</code></p>
<p>docker查看容器的网络ip</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range.NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> container_name_or_id</span><br><span class="line"><span class="comment"># 可直接获得容器的ip地址如：172.18.0.4</span></span><br><span class="line"><span class="comment"># 显示所有容器IP地址：</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range.NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Docker 1.9之前的版本中,不能使用Docker Networking,只能使用Docker链接来连接Redis主容器和副本容器。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建express网络</span></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/tomcat8/redis_primary/redis_replica]</span><br><span class="line">└─$ sudo docker network create express</span><br><span class="line">017b16936585a6cbf07dec62542f904cc662cb597355f3ad21ad3741b013f044</span><br><span class="line"><span class="comment">## 运行Redis主容器redis_primary</span></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ sudo docker run -d -h redis_primary --net express --name redis_primary jamtur01/redis_primary</span><br><span class="line">a6dd74fa924f27a193be3f33ab532e92e582fc230015ac6afcaa018fcf568267</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ docker logs redis_primary</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用docker run命令从jamtur01&#x2F;redis primary镜像创建了一个容器。</p>
<p><code>-h,这个标志用来设置容器的主机名</code>。这会覆盖默认的行为(默认将容器的主机名设置为容器ID)并允许我们指定自己的主机名。使用这个标志可以确保容器使用redis-primary作为主机名,并被本地的DNS服务正确解析。</p>
<p><code>--name标志,确保容器的名字是redis primary</code></p>
<p><code>--net标志,确保该容器在express网络中运行</code>。稍后我们会看到,我们将使用这个网络来保证容器连通性。</p>
<p><strong><font color=royalblue>查看日志</font></strong><br>什么日志都没有?这是怎么回事?原来Redis服务会将日志记录到一个文件而不是记录到标准输出,所以使用Docker查看不到任何日志。可以使用之前创建的&#x2F;var&#x2F;log&#x2F;redis卷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ sudo docker logs redis_primary</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ sudo docker run -it --rm  --volumes-from redis_primary ubuntu cat /var/<span class="built_in">log</span>/redis/redis-server.log</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/f0c3947719d84164b58d48ca4417e23b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ sudo docker run -d -h redis_replical --name redis_replical --net express jamtur01/redis_replica</span><br><span class="line">e580ea333671dcfc83ba473bfd622dde7758f96582fcc0ab69b3af58c912df60</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<p>这里我们运行了另一个容器:这个容器来自jamtur01&#x2F;redis_replica镜像。</p>
<p>和之前一样,命令里指定了主机名(通过-h标志)和容器名(通过–name标志)都是redisreplical。我们还使用了–net标志在express网络中运行Redis副本容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ sudo docker run -it --volumes-from redis_replical ubuntu cat /var/<span class="built_in">log</span>/redis/redis-replica.log</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/a179eafb9d0f493ca6d0f7a35b5ffaf4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><code>第二个副本容器</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_bash]</span><br><span class="line">└─$ sudo docker run -d -h redis_replica2 --name redis_replica2  --net express jamtur01/redis_replica</span><br><span class="line">[sudo] password <span class="keyword">for</span> liruilong:</span><br><span class="line">a8342e48c9b5aa47d294682240a3e8a59a5c2cb7fb29552b8d3c58b8173923b7</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_bash]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$ sudo docker run -it --rm --volumes-from redis_replica2 ubuntu cat /var/<span class="built_in">log</span>/redis/redis-replica.log</span><br><span class="line">1:C 24 Aug 2021 07:57:50.780 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">1:C 24 Aug 2021 07:57:50.780 <span class="comment"># Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=1, just started</span></span><br><span class="line">1:C 24 Aug 2021 07:57:50.780 <span class="comment"># Configuration loaded</span></span><br><span class="line">1:S 24 Aug 2021 07:57:50.781 * Running mode=standalone, port=6379.</span><br><span class="line">1:S 24 Aug 2021 07:57:50.781 <span class="comment"># Server initialized</span></span><br><span class="line">1:S 24 Aug 2021 07:57:50.781 <span class="comment"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span></span><br><span class="line">1:S 24 Aug 2021 07:57:50.782 * Ready to accept connections</span><br><span class="line">1:S 24 Aug 2021 07:57:50.782 * Connecting to MASTER redis_primary:6379</span><br><span class="line">1:S 24 Aug 2021 07:57:50.804 * MASTER &lt;-&gt; REPLICA sync started</span><br><span class="line">1:S 24 Aug 2021 07:57:50.804 * Non blocking connect <span class="keyword">for</span> SYNC fired the event.</span><br><span class="line">1:S 24 Aug 2021 07:57:50.805 * Master replied to PING, replication can <span class="built_in">continue</span>...</span><br><span class="line">1:S 24 Aug 2021 07:57:50.805 * Partial resynchronization not possible (no cached master)</span><br><span class="line">1:S 24 Aug 2021 07:57:50.806 * Full resync from master: 14700697ad61ad3ce1d6b36fac6b4e1403d71c9f:1428</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * MASTER &lt;-&gt; REPLICA sync: receiving 176 bytes from master to disk</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * MASTER &lt;-&gt; REPLICA sync: Flushing old data</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * MASTER &lt;-&gt; REPLICA sync: Loading DB <span class="keyword">in</span> memory</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * Loading RDB produced by version 6.0.6</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * RDB age 0 seconds</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * RDB memory usage when created 1.84 Mb</span><br><span class="line">1:S 24 Aug 2021 07:57:50.922 * MASTER &lt;-&gt; REPLICA sync: Finished with success</span><br><span class="line">failed to resize tty, using default size</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_replica]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<h3 id="6-3-6创建Node容器"><a href="#6-3-6创建Node容器" class="headerlink" title="6.3.6创建Node容器"></a>6.3.6<font color=yellowgreen>创建Node容器</font></h3><p>现在我们已经让Redis集群运行了,我们可以为启动Node.js应用启动一个容器,如代</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_bash]</span><br><span class="line">└─$ sudo docker run -d --name nodeapp -p 3000:3000 --net express jamtur01/nodejs</span><br><span class="line">ee0ad18cc61d5261d963924d4c496b3265420b76de8181143fa5a851e044a645</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_bash]</span><br><span class="line">└─$ sudo docker logs nodeapp</span><br><span class="line">Listening on port 3000</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_bash]</span><br><span class="line">└─$ curl http://127.0.0.1:3000</span><br><span class="line">&#123;<span class="string">&quot;status&quot;</span>:<span class="string">&quot;ok&quot;</span>&#125;</span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/redis_bash]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>
<h3 id="6-3-7-捕获应用日志"><a href="#6-3-7-捕获应用日志" class="headerlink" title="6.3.7 捕获应用日志"></a>6.3.7 <font color=orange>捕获应用日志</font></h3><p>现在应用已经可以运行了,需要把这个应用放到生产环境中。在生产环境里需要确保可以捕获日志并将日志保存到日志服务器。我们将使用<code>Logstash</code>“来完成这件事。我们先来创建一个<code>Logstash镜像</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker]</span><br><span class="line">└─$ d=logstash;mkdir <span class="variable">$d</span>;<span class="built_in">cd</span> <span class="variable">$d</span>;vim Dockerfile</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/logstash]</span><br><span class="line">└─$ vim logstash.conf</span><br><span class="line"></span><br><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/logstash]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-06-01</span><br><span class="line"></span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install wget gnupg2 openjdk-8-jdk</span><br><span class="line">RUN wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/5.x/apt stable main&quot;</span> | tee -a /etc/apt/sources.list.d/elastic-5.x.list</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qq install logstash</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/share/logstash</span><br><span class="line"></span><br><span class="line">ADD logstash.conf /usr/share/logstash/</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;bin/logstash&quot;</span> ]</span><br><span class="line">CMD [ <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;logstash.conf&quot;</span>, <span class="string">&quot;--config.reload.automatic&quot;</span> ]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    <span class="built_in">type</span> =&gt; <span class="string">&quot;syslog&quot;</span></span><br><span class="line">    path =&gt; [<span class="string">&quot;/var/log/nodeapp/nodeapp.log&quot;</span>, <span class="string">&quot;/var/log/redis/redis-server.log&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这个<code>Logstash配置</code>很简单,它监控两个文件,即<code>/var/1og/nodeapp/nodeapp.1og</code>和<code>/var/log/redis/redis-server.log</code>, <code>Logstash</code>会一直监视这两个文件,将其中新”的内容发送给<code>Logstash</code>。</p>
<p>配置文件的第二部分是<code>output</code>部分,<code>接受所有Logstash输入的内容并将其输出到标准输出上</code>。现实中,一般会将Logstash配置为输出到Elasticsearch集群或者其他的目的地,不过这里只使用标准输出做演示,所以忽略了现实的细节。</p>
<p>我们指定了<code>工作目录为/opt/logstash。最后,我们指定了ENTRYPOINT为bin/.logstash,并且指定了CMD为--config=/etc/logstash.conf。这样容器启动时会启动Logstash并加载/etc/logstash.conf配置文件</code>。</p>
<p>构建 Logstash 镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──(liruilong㉿Liruilong)-[/mnt/e/docker/logstash]</span><br><span class="line">└─$ sudo docker build -t jamtur01/logstash .</span><br><span class="line">[sudo] password <span class="keyword">for</span> liruilong:</span><br><span class="line">Sending build context to Docker daemon  3.584kB</span><br><span class="line">Step 1/13 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; 39a8cfeef173</span><br><span class="line">Step 2/13 : LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">Removing intermediate container 66091ab4268b</span><br><span class="line"> ---&gt; b473a0d43049</span><br><span class="line">Successfully built b473a0d43049</span><br><span class="line">Successfully tagged jamtur01/logstash:latest</span><br></pre></td></tr></table></figure>
<p><strong><font color=yellowgreen>启动 Logstash 容器</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/2a1e60797cdb49c7b47f2142d48742a1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>现在我们已经演示过了如何使用多个容器组成应用程序栈,演示了如何使用Docker链·接来将应用容器连在一起,还演示了如何使用Docker卷来管理应用中各种数据。这些技术可以很容易地用来构建更加复杂的应用程序和架构。</p>
<h2 id="6-4-不使用SSH管理Docker容器"><a href="#6-4-不使用SSH管理Docker容器" class="headerlink" title="6.4 不使用SSH管理Docker容器"></a>6.4 <font color=orange>不使用SSH管理Docker容器</font></h2><p>传统上讲,通过SSH登入运行环境或者虚拟机里来管理服务。在Docker的世界里,大部分容器都只运行一个进程,所以不能使用这种访问方法。不过就像之前多次看到的,其实不需要这种访问:可以使用卷或者链接完成大部分同样的管理操作。比如说,如果服务通过某个网络接口做管理,就可以在启动容器时公开这个接口;如果服务通过Unix套接字(socket)来管理,就可以通过卷公开这个套接字。如果需要给容器发送信号,<code>使用docker ki11命令发送信号。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">kill</span> -s &lt;signal&gt; &lt;container&gt;</span><br></pre></td></tr></table></figure>
<p>为了使用nsenter,首先要拿到要进入的容器的进程ID (PID)。可以使用dockerinspect命令获得PID,如代码清单6-65所示。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID=$(sudo docker inspect --format <span class="string">&#x27;&#123;&#123;t.State.Pid&#125;&#125;&#x27;</span> &lt;container&gt;)</span><br></pre></td></tr></table></figure>
<p><code>nsenter一般适用于Docker 1.2或者更早的版本。docker exec命令是在Docker 1.3中引入的,替换了它的大部分功能。</code></p>
<h1 id="第七章，Docker编配和服务发现"><a href="#第七章，Docker编配和服务发现" class="headerlink" title="第七章，Docker编配和服务发现"></a>第七章，Docker编配和服务发现</h1><p><code>编配(orchestration)</code>是一个没有严格定义的概念。这个概念大概描述了<code>自动配置、协作和管理服务</code>的<code>过程</code>。</p>
<p>编配用来描述一组实践过程,管理运行在多个Docker容器里的应用,而这些Docker容器有可能运行在多个宿主机上。 </p>
<p><code>Docker对编配的原生</code>支持非常<code>弱</code>,不过整个社区围绕编配开发和集成了很多很棒的工具。· </p>
<h2 id="7-1-Docker-Compose"><a href="#7-1-Docker-Compose" class="headerlink" title="7.1 Docker Compose,"></a>7.1 Docker Compose,</h2><p><code>Docker Compose</code>,可以用一个<code>YAML</code>文件定义一组要启动的容器,以及容器运行时的属性。Docker Compose称这些容器为“服务”.像这样定义:</p>
<blockquote>
<p><code>容器通过某些方法并指定一些运行时的属性来和其他容器产生交互。</code></p>
</blockquote>
<h3 id="7-1-1-安装-Docker-Compose"><a href="#7-1-1-安装-Docker-Compose" class="headerlink" title="7.1.1 安装 Docker Compose"></a>7.1.1 安装 Docker Compose</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="7-1-2获取示例应用"><a href="#7-1-2获取示例应用" class="headerlink" title="7.1.2获取示例应用"></a>7.1.2获取示例应用</h3><p>新建一个目录创建一个DockerFile文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># rm -rf composeapp</span></span><br><span class="line">[root@liruilong ~]<span class="comment"># dir=composeapp</span></span><br><span class="line">[root@liruilong ~]<span class="comment"># mkdir $dir;cd $dir;touch Dockerfile</span></span><br><span class="line">[root@liruilong composeapp]<span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建一个DockerFile文件 ：</p>
<ul>
<li>应用容器,运行Python示侧程序。</li>
<li>Redis容器,运行Redis数据库。</li>
</ul>
<p>模拟应用程序：app.py</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">&quot;redis&quot;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    redis.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Docker Book reader! I have been seen &#123;0&#125; times&#x27;</span>.<span class="built_in">format</span>(redis.get(<span class="string">&#x27;hits&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, debug=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建<code>requirements.txt</code>文件来保存应用程序的依赖关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
<p>创建 Dockerfile  文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于python:2.7镜像构建</span></span><br><span class="line">FROM python:2.7</span><br><span class="line">LABEL maintainer=<span class="string">&quot;james@example.com&quot;</span></span><br><span class="line">ENV REFRESHED_AT 2016-08-01</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加文件app.py和. requirements.txt到镜像中的/composeapp目录</span></span><br><span class="line">ADD . /composeapp</span><br><span class="line"><span class="comment"># 将工作目录设置为/composeapp,并执行pip命令来安装应用的依赖: flask和redis.</span></span><br><span class="line">WORKDIR /composeapp</span><br><span class="line"></span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用 docker build 来构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build composeapp .</span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-docker-compose-yml文件"><a href="#7-1-3-docker-compose-yml文件" class="headerlink" title="7.1.3 docker-compose.yml文件"></a>7.1.3 docker-compose.yml文件</h3><p>现在应用镜像已经构建好了,可以配置Compose来创建需要的服务了。<br>在Compose中,我们定义了一组要启动的服务(以Docker容器的形式表现),我们还定义了我们希望这些服务要启动的运行时属性.</p>
<p>这些属性和<code>docker run</code>命令需要的<code>参数</code>类似。将所有与<code>服务有关的属性</code>都定义在一个<code>YAML</code>文件里。之后执行<code>docker-compose up</code>命令, <code>Compose</code>会启动这些容器,<code>使用指定的参数来执行</code>,并将<code>所有的日志输出合并到一起</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch docker-compose.yml</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">composeapp</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">python</span> <span class="string">app.py</span></span><br><span class="line">    <span class="comment">## 映射端口</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="comment">## 映射路径 </span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/composeapp</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-1-4运行Compose"><a href="#7-1-4运行Compose" class="headerlink" title="7.1.4运行Compose"></a>7.1.4运行Compose</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong docker]<span class="comment"># vim app.py</span></span><br><span class="line">[root@liruilong docker]<span class="comment"># vim docker-compose.yml</span></span><br><span class="line">[root@liruilong docker]<span class="comment"># docker-compose up -d</span></span><br><span class="line">Creating docker_redis_1 ...</span><br><span class="line">Creating docker_web_1   ... error</span><br><span class="line"></span><br><span class="line">ERROR: <span class="keyword">for</span> docker_web_1  Cannot start service web: driver failed programming external connectivity on endpoint docker_weCreating docker_redis_1 ... <span class="keyword">done</span></span><br><span class="line">0:5000: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use</span><br><span class="line"></span><br><span class="line">ERROR: <span class="keyword">for</span> web  Cannot start service web: driver failed programming external connectivity on endpoint docker_web_1 (101bedf849c53b6182020e7d51a12a36e566e87f1a269e667086da7d4a1fea4a): Error starting userland proxy: listen tcp 0.0.0.0:5000: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use</span><br><span class="line">ERROR: Encountered errors <span class="keyword">while</span> bringing up the project.</span><br></pre></td></tr></table></figure>
<p>嗯，报错了端口被占用，解决一下，把占用的端口kill掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong docker]<span class="comment"># ps -a</span></span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">13874 pts/3    00:00:00 vim</span><br><span class="line">15546 pts/4    00:00:00 ps</span><br><span class="line">[root@liruilong docker]<span class="comment"># netstat -tnalp</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      7234/java</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1964/sshd</span><br><span class="line">tcp        0      0 0.0.0.0:2181            0.0.0.0:*               LISTEN      7234/java</span><br><span class="line">tcp        0      0 0.0.0.0:27017           0.0.0.0:*               LISTEN      24880/mongod</span><br><span class="line">tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      799/redis-server *:</span><br><span class="line">tcp        0      0 0.0.0.0:42445           0.0.0.0:*               LISTEN      7234/java</span><br><span class="line">tcp        0     36 172.17.57.70:22         39.154.13.103:1859      ESTABLISHED 13923/sshd: root@pt</span><br><span class="line">tcp        0      0 172.17.57.70:54780      100.100.30.25:80        ESTABLISHED 15077/AliYunDun</span><br><span class="line">tcp        0      0 172.17.57.70:59758      100.100.105.70:80       TIME_WAIT   -</span><br><span class="line">tcp        0      0 172.17.57.70:56292      100.100.18.120:443      TIME_WAIT   -</span><br><span class="line">tcp        0      0 172.17.57.70:22         39.154.13.103:2607      ESTABLISHED 13801/sshd: root@pt</span><br><span class="line">tcp        0      0 172.17.57.70:59760      100.100.105.70:80       TIME_WAIT   -</span><br><span class="line">tcp        0      0 172.17.57.70:22         39.154.13.103:2582      ESTABLISHED 13831/sshd: root@pt</span><br><span class="line">tcp        0      0 172.17.57.70:59762      100.100.105.70:80       TIME_WAIT   -</span><br><span class="line">tcp        0      0 172.17.57.70:59754      100.100.105.70:80       TIME_WAIT   -</span><br><span class="line">tcp6       0      0 :::5000                 :::*                    LISTEN      23998/registry</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      24962/mysqld</span><br><span class="line">tcp6       0      0 :::6379                 :::*                    LISTEN      799/redis-server *:</span><br><span class="line">[root@liruilong docker]<span class="comment"># kill 23998</span></span><br></pre></td></tr></table></figure>
<p>在执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong docker]# docker-compose up -d</span><br><span class="line">docker_redis_1 is up-to-date</span><br><span class="line">Starting docker_web_1 ... done</span><br><span class="line">[root@liruilong docker]# curl  http://0.0.0.0:5000/</span><br><span class="line">Hello Docker Book reader! I have been seen 1 times[root@liruilong docker]#</span><br><span class="line">[root@liruilong docker]# curl  http://0.0.0.0:5000/</span><br><span class="line">Hello Docker Book reader! I have been seen 2 times[root@liruilong docker]#</span><br><span class="line">[root@liruilong docker]#</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5be99c7bcb02444f92eff6213a2939f1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="7-1-5使用Compose"><a href="#7-1-5使用Compose" class="headerlink" title="7.1.5使用Compose"></a>7.1.5使用Compose</h3><p><code>docker-compose ps</code>命令列出了本地<code>docker-compose.yml</code>文件里定义的正在运行的所有服务,可以使用<code>docker-compose rm</code>命令来删除这些服务,还可以使用<code>docker-compose logs</code>命令来进一步查看服务的日志事件,</p>
<p>如果使用<code>docker-compose stop</code>或者<code>docker-compose ki11</code>命令停止服务,还”可以使用<code>docker-compose start</code>命令重新启动这些服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong docker]<span class="comment"># docker-compose ps</span></span><br><span class="line">     Name                   Command               State           Ports</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">docker_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp</span><br><span class="line">docker_web_1     python app.py                    Up      0.0.0.0:5000-&gt;5000/tcp</span><br><span class="line">[root@liruilong docker]<span class="comment"># docker-compose logs</span></span><br><span class="line">Attaching to docker_web_1, docker_redis_1</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">web_1    |  * Restarting with <span class="built_in">stat</span></span><br><span class="line">web_1    |  * Debugger is active!</span><br><span class="line">web_1    |  * Debugger PIN: 212-073-889</span><br><span class="line">web_1    | 172.19.0.1 - - [21/Aug/2021 17:59:57] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 -</span><br><span class="line">web_1    | 172.19.0.1 - - [21/Aug/2021 18:00:02] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 -</span><br><span class="line">redis_1  | 1:C 21 Aug 2021 17:57:52.123 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">redis_1  | 1:C 21 Aug 2021 17:57:52.123 <span class="comment"># Redis version=6.2.5, bits=64, commit=00000000, modified=0, pid=1, just started</span></span><br><span class="line">redis_1  | 1:C 21 Aug 2021 17:57:52.123 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span></span><br><span class="line">redis_1  | 1:M 21 Aug 2021 17:57:52.126 * monotonic clock: POSIX clock_gettime</span><br><span class="line">redis_1  | 1:M 21 Aug 2021 17:57:52.127 * Running mode=standalone, port=6379.</span><br><span class="line">redis_1  | 1:M 21 Aug 2021 17:57:52.127 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">redis_1  | 1:M 21 Aug 2021 17:57:52.127 <span class="comment"># Server initialized</span></span><br><span class="line">redis_1  | 1:M 21 Aug 2021 17:57:52.127 <span class="comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span></span><br><span class="line">redis_1  | 1:M 21 Aug 2021 17:57:52.127 * Ready to accept connections</span><br><span class="line">[root@liruilong docker]<span class="comment"># docker-compose stop;docker-compose kill;</span></span><br><span class="line">Stopping docker_web_1   ... <span class="keyword">done</span></span><br><span class="line">Stopping docker_redis_1 ... <span class="keyword">done</span></span><br><span class="line">[root@liruilong docker]<span class="comment"># docker-compose ps</span></span><br><span class="line">     Name                   Command               State    Ports</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">docker_redis_1   docker-entrypoint.sh redis ...   Exit 0</span><br><span class="line">docker_web_1     python app.py                    Exit 0</span><br><span class="line">[root@liruilong docker]<span class="comment"># docker-compose rm</span></span><br><span class="line">Going to remove docker_web_1, docker_redis_1</span><br><span class="line">Are you sure? [yN] y</span><br><span class="line">Removing docker_web_1   ... <span class="keyword">done</span></span><br><span class="line">Removing docker_redis_1 ... <span class="keyword">done</span></span><br><span class="line">[root@liruilong docker]<span class="comment"># docker-compose ps</span></span><br><span class="line">Name   Command   State   Ports</span><br><span class="line">------------------------------</span><br><span class="line">[root@liruilong docker]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-6-Compose小结"><a href="#7-1-6-Compose小结" class="headerlink" title="7.1.6 Compose小结"></a>7.1.6 Compose小结</h3><p>可以将Compose与提供图形化用户界面的Shipyard 一起使用。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/rails/">https://docs.docker.com/compose/rails/</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/diango/">https://docs.docker.com/compose/diango/</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/wordpress/">https://docs.docker.com/compose/wordpress/</a>)<br><a target="_blank" rel="noopener" href="https://github.com/shipyard/shipyard">https://github.com/shipyard/shipyard</a><br><a target="_blank" rel="noopener" href="https://dos.docker.com/compose/cli/">https://dos.docker.com/compose/cli/</a></p>
</blockquote>
<h2 id="7-2-Consul-服务发现和Docker"><a href="#7-2-Consul-服务发现和Docker" class="headerlink" title="7.2 Consul,服务发现和Docker"></a>7.2 Consul,服务发现和Docker</h2><p><code>服务发现</code>是<code>分布式应用程序之间</code>管理<code>相互关系</code>的一种<code>机制</code>。一个分布式程序一般由多个</p>
<h2 id="7-3-Docker-Swarm"><a href="#7-3-Docker-Swarm" class="headerlink" title="7.3 Docker Swarm"></a>7.3 Docker Swarm</h2><h2 id="7-4其他编配工具和组件"><a href="#7-4其他编配工具和组件" class="headerlink" title="7.4其他编配工具和组件"></a>7.4其他编配工具和组件</h2><p>编配工具是一个快速发展的生态环境,没有办法列出这个领域中的所有可用的工具。这些工具·的功能不尽相同,不过大部分都属于以下两个类型;</p>
<ul>
<li>调度和集群管理;</li>
<li>服务发现。</li>
</ul>
<h3 id="7-4-1-Fleet和etco"><a href="#7-4-1-Fleet和etco" class="headerlink" title="7.4.1 Fleet和etco"></a>7.4.1 Fleet和etco</h3><h3 id="7-4-2-Kubernetes"><a href="#7-4-2-Kubernetes" class="headerlink" title="7.4.2 Kubernetes"></a>7.4.2 Kubernetes</h3><h3 id="7-4-3-Apache-Mesos"><a href="#7-4-3-Apache-Mesos" class="headerlink" title="7.4.3 Apache Mesos"></a>7.4.3 Apache Mesos</h3><h3 id="7-4-4-Helios"><a href="#7-4-4-Helios" class="headerlink" title="7.4.4 Helios"></a>7.4.4 Helios</h3><h3 id="7-4-5-Centurion"><a href="#7-4-5-Centurion" class="headerlink" title="7.4.5 Centurion"></a>7.4.5 Centurion</h3></div><div class="article-licensing box"><div class="licensing-title"><p>《第一本Docker书》 读书笔记</p><p><a href="https://liruilongs.github.io/2021/07/22/docker/《第一本DOCKER书》 读书笔记/">https://liruilongs.github.io/2021/07/22/docker/《第一本DOCKER书》 读书笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-07-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/03/17/docker/Docker%20%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E7%AB%AF%E4%BB%A5%E5%8F%8A%E5%8F%A3%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%EF%BC%9F/" target="_blank">Docker 容器如何访问外部网络端以及口映射原理？</a><br></span><span>  2.<a class="is-size-6" href="/2022/12/25/docker/%E5%85%B3%E4%BA%8ELinux%E4%B8%8BDocker%E5%86%85%E7%BD%91%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Linux下Docker内网离线安装的一些笔记</a><br></span><span>  3.<a class="is-size-6" href="/2022/01/03/K8s/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2-%E8%BF%90%E7%BB%B4/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Calico%E5%AE%9E%E7%8E%B0%E8%B7%A8%E4%B8%BB%E6%9C%BADocker%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" target="_blank">如何使用Calico实现跨主机Docker网络通信</a><br></span><span>  4.<a class="is-size-6" href="/2021/08/30/docker/%E5%9F%BA%E4%BA%8EDocker%E9%83%A8%E7%BD%B2%20Tomcat%E9%9B%86%E7%BE%A4%E3%80%81%20Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" target="_blank">基于Docker部署 Tomcat集群、 Nginx负载均衡</a><br></span><span>  5.<a class="is-size-6" href="/2021/07/27/docker/Docker%E3%80%81Podman%20%E5%AE%B9%E5%99%A8%E2%80%9C%E6%89%AB%E7%9B%B2%E2%80%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank">Docker、Podman 容器“扫盲“ 学习笔记</a><br></span><span>  6.<a class="is-size-6" href="/2021/07/27/docker/%E5%9F%BA%E4%BA%8EDocker%E6%9E%84%E5%BB%BACentOS7_Java8_Tomcat8.5%20%E7%9A%84%E9%95%9C%E5%83%8F%E5%8F%8AWeb%E5%BA%94%E7%94%A8%E7%9A%84%E9%83%A8%E7%BD%B2/" target="_blank">基于Docker构建CentOS7_Java8_Tomcat8.5 的镜像及Web应用的部署</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2025/04/15/Linux-%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E9%99%90%E5%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F/" target="_blank">Linux 限制内存使用量：Linux 内存调优之限制进程、系统级别内存使用量</a><br></span><span>  3.<a class="is-size-6" href="/2024/10/10/Git/Git-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81-reference-broken-%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" target="_blank">Git 提交代码 reference broken 问题处理</a><br></span><span>  4.<a class="is-size-6" href="/2022/11/19/Git/%E5%85%B3%E4%BA%8E-Git-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于 Git 重写历史的一些笔记</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/02/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%8F%98%E5%9F%BA%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支变基操作的一些笔记</a><br></span><span>  6.<a class="is-size-6" href="/2022/07/26/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/" target="_blank">关于Git分支基础知识的一些笔记</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/27/docker/%E5%9F%BA%E4%BA%8EDocker%E6%9E%84%E5%BB%BACentOS7_Java8_Tomcat8.5%20%E7%9A%84%E9%95%9C%E5%83%8F%E5%8F%8AWeb%E5%BA%94%E7%94%A8%E7%9A%84%E9%83%A8%E7%BD%B2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">基于Docker构建CentOS7_Java8_Tomcat8.5 的镜像及Web应用的部署</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/07/17/%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%8D%8E%E4%B8%BA%E4%BA%91%E6%9C%8D%E5%8A%A1DevOps%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88(HCIP)-DevCloud%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-item">华为云服务DevOps高级工程师(HCIP)-DevCloud 学习笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'db890a664ab4e341c613efb70671496d',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1.1</span><span>写在前面</span></a></li></ul><li><a class="is-flex is-mobile" href="#第1章简介"><span class="mr-2">2</span><span>第1章简介</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-1-4-鼓励使用面向服务的架构"><span class="mr-2">2.1.1</span><span>1.1.4 鼓励使用面向服务的架构</span></a></li><li><a class="is-flex is-mobile" href="#1-2-4-容器"><span class="mr-2">2.1.2</span><span>1.2.4 容器</span></a></li><li><a class="is-flex is-mobile" href="#1-3-能用Docker做什么"><span class="mr-2">2.1.3</span><span>1.3 能用Docker做什么</span></a></li><li><a class="is-flex is-mobile" href="#1-4-Docker与配置管理"><span class="mr-2">2.1.4</span><span>1.4 Docker与配置管理</span></a></li><li><a class="is-flex is-mobile" href="#1-5-Docker的技术组件"><span class="mr-2">2.1.5</span><span>1.5 Docker的技术组件</span></a></li><li><a class="is-flex is-mobile" href="#1-7-Docker资源"><span class="mr-2">2.1.6</span><span>1.7 Docker资源</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第2章安装Docker"><span class="mr-2">3</span><span>第2章安装Docker</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#Docker用户界面"><span class="mr-2">3.1.1</span><span>Docker用户界面</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第3章Docker入门"><span class="mr-2">4</span><span>第3章Docker入门</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#3-1确保Docker已经就绪"><span class="mr-2">4.1.1</span><span>3.1确保Docker已经就绪</span></a></li><li><a class="is-flex is-mobile" href="#3-2运行我们的第一个容器"><span class="mr-2">4.1.2</span><span>3.2运行我们的第一个容器</span></a></li><li><a class="is-flex is-mobile" href="#3-3使用第一个容器"><span class="mr-2">4.1.3</span><span>3.3使用第一个容器</span></a></li><li><a class="is-flex is-mobile" href="#3-4容器命名"><span class="mr-2">4.1.4</span><span>3.4容器命名</span></a></li><li><a class="is-flex is-mobile" href="#3-5重新启动已经停止的容器"><span class="mr-2">4.1.5</span><span>3.5重新启动已经停止的容器</span></a></li><li><a class="is-flex is-mobile" href="#3-6附着到容器上"><span class="mr-2">4.1.6</span><span>3.6附着到容器上</span></a></li><li><a class="is-flex is-mobile" href="#3-7创建守护式容器"><span class="mr-2">4.1.7</span><span>3.7创建守护式容器</span></a></li><li><a class="is-flex is-mobile" href="#3-8容器内部都在干些什"><span class="mr-2">4.1.8</span><span>3.8容器内部都在干些什</span></a></li><li><a class="is-flex is-mobile" href="#3-9-Docker日志驱动"><span class="mr-2">4.1.9</span><span>3.9 Docker日志驱动</span></a></li><li><a class="is-flex is-mobile" href="#3-10查看容器内的进程"><span class="mr-2">4.1.10</span><span>3.10查看容器内的进程</span></a></li><li><a class="is-flex is-mobile" href="#3-11-Docker统计信息"><span class="mr-2">4.1.11</span><span>3.11 Docker统计信息</span></a></li><li><a class="is-flex is-mobile" href="#3-12在容器内部运行进程"><span class="mr-2">4.1.12</span><span>3.12在容器内部运行进程</span></a></li><li><a class="is-flex is-mobile" href="#3-13停止守护式容器"><span class="mr-2">4.1.13</span><span>3.13停止守护式容器</span></a></li><li><a class="is-flex is-mobile" href="#3-14自动重启容器"><span class="mr-2">4.1.14</span><span>3.14自动重启容器</span></a></li><li><a class="is-flex is-mobile" href="#3-15深入容器"><span class="mr-2">4.1.15</span><span>3.15深入容器</span></a></li><li><a class="is-flex is-mobile" href="#3-16删除容器"><span class="mr-2">4.1.16</span><span>3.16删除容器</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第4章-使用Docker镜像和仓库"><span class="mr-2">5</span><span>第4章 使用Docker镜像和仓库</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#4-1什么是Docker镜像"><span class="mr-2">5.1.1</span><span>4.1什么是Docker镜像</span></a></li><li><a class="is-flex is-mobile" href="#4-2列出镜像"><span class="mr-2">5.1.2</span><span>4.2列出镜像</span></a></li><li><a class="is-flex is-mobile" href="#4-3拉取镜像"><span class="mr-2">5.1.3</span><span>4.3拉取镜像</span></a></li><li><a class="is-flex is-mobile" href="#4-4查找镜像"><span class="mr-2">5.1.4</span><span>4.4查找镜像</span></a></li><li><a class="is-flex is-mobile" href="#12-ONBUIID"><span class="mr-2">5.1.5</span><span>12. ONBUIID</span></a></li><li><a class="is-flex is-mobile" href="#4-6将镜像推送到DockerHub"><span class="mr-2">5.1.6</span><span>4.6将镜像推送到DockerHub</span></a></li><li><a class="is-flex is-mobile" href="#4-7删除镜像"><span class="mr-2">5.1.7</span><span>4.7删除镜像</span></a></li><li><a class="is-flex is-mobile" href="#4-8-2-测试新Registry"><span class="mr-2">5.1.8</span><span>4.8.2 测试新Registry</span></a></li><li><a class="is-flex is-mobile" href="#Quay"><span class="mr-2">5.1.9</span><span>Quay</span></a></li></ul></ul></li><li><a class="is-flex is-mobile" href="#第5章在测试中使用Docker"><span class="mr-2">6</span><span>第5章在测试中使用Docker</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-1使用Docker测试静态网站-Nginx-docker-化"><span class="mr-2">6.1</span><span>5.1使用Docker测试静态网站(Nginx docker 化)</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-1-1-Sample网站的初始Dockerfile"><span class="mr-2">6.1.1</span><span>5.1.1 Sample网站的初始Dockerfile</span></a></li><li><a class="is-flex is-mobile" href="#5-1-2构建Sample网站和Nginx镜像"><span class="mr-2">6.1.2</span><span>5.1.2构建Sample网站和Nginx镜像</span></a></li><li><a class="is-flex is-mobile" href="#5-1-3从Sample网站和Nainx镜像构建容器"><span class="mr-2">6.1.3</span><span>5.1.3从Sample网站和Nainx镜像构建容器</span></a></li><li><a class="is-flex is-mobile" href="#5-1-4修改网站"><span class="mr-2">6.1.4</span><span>5.1.4修改网站</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#5-2使用Docker构建并测试Web应用程序"><span class="mr-2">6.2</span><span>5.2使用Docker构建并测试Web应用程序</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-2-1-构建Sinatra应用程序"><span class="mr-2">6.2.1</span><span>5.2.1 构建Sinatra应用程序</span></a></li><li><a class="is-flex is-mobile" href="#5-2-2-创建Sinatra容器"><span class="mr-2">6.2.2</span><span>5.2.2 创建Sinatra容器</span></a></li><li><a class="is-flex is-mobile" href="#5-2-3-扩展Sinatra应用程序来使用Redis"><span class="mr-2">6.2.3</span><span>5.2.3 扩展Sinatra应用程序来使用Redis</span></a></li><li><a class="is-flex is-mobile" href="#5-2-4-将Sinatra应用程序连接到Redis容器"><span class="mr-2">6.2.4</span><span>5.2.4 将Sinatra应用程序连接到Redis容器</span></a></li><li><a class="is-flex is-mobile" href="#5-2-5-Docker内部连网"><span class="mr-2">6.2.5</span><span>5.2.5 Docker内部连网</span></a></li><li><a class="is-flex is-mobile" href="#5-2-6-DockerNetworking"><span class="mr-2">6.2.6</span><span>5.2.6 DockerNetworking</span></a></li><li><a class="is-flex is-mobile" href="#5-2-7-使用容器连接来通信"><span class="mr-2">6.2.7</span><span>5.2.7 使用容器连接来通信</span></a></li><li><a class="is-flex is-mobile" href="#5-3-Docker用于持续集成"><span class="mr-2">6.2.8</span><span>5.3 Docker用于持续集成</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第6章使用Docker构建服务"><span class="mr-2">7</span><span>第6章使用Docker构建服务</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-1-构建第一个应用"><span class="mr-2">7.1</span><span>6.1　构建第一个应用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-1-1-Jekyll基础镜像"><span class="mr-2">7.1.1</span><span>6.1.1 Jekyll基础镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-1-2-构建Jekyl基础镜像"><span class="mr-2">7.1.2</span><span>6.1.2 构建Jekyl基础镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-1-3-Apache镜像"><span class="mr-2">7.1.3</span><span>6.1.3 Apache镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-1-4-构建Jekyll-Apache镜像"><span class="mr-2">7.1.4</span><span>6.1.4 构建Jekyll Apache镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-1-5-启动Jekyll网站"><span class="mr-2">7.1.5</span><span>6.1.5 启动Jekyll网站</span></a></li><li><a class="is-flex is-mobile" href="#6-1-6-更新Jekyll网站"><span class="mr-2">7.1.6</span><span>6.1.6 更新Jekyll网站</span></a></li><li><a class="is-flex is-mobile" href="#6-1-7-备份Jekyll卷"><span class="mr-2">7.1.7</span><span>6.1.7 备份Jekyll卷</span></a></li><li><a class="is-flex is-mobile" href="#6-1-8-扩展Jekyll示例网站"><span class="mr-2">7.1.8</span><span>6.1.8 扩展Jekyll示例网站</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#6-2-使用Docker构建一个Java应用服务"><span class="mr-2">7.2</span><span>6.2 使用Docker构建一个Java应用服务</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-2-1-WAR文件的获取程序"><span class="mr-2">7.2.1</span><span>6.2.1 WAR文件的获取程序</span></a></li><li><a class="is-flex is-mobile" href="#6-2-2-获取WAR文件"><span class="mr-2">7.2.2</span><span>6.2.2 获取WAR文件</span></a></li><li><a class="is-flex is-mobile" href="#6-2-3-Tomecat8应用服务器"><span class="mr-2">7.2.3</span><span>6.2.3 Tomecat8应用服务器</span></a></li><li><a class="is-flex is-mobile" href="#6-2-4-运行WAR文件"><span class="mr-2">7.2.4</span><span>6.2.4 运行WAR文件</span></a></li><li><a class="is-flex is-mobile" href="#6-2-5-基于Tomcat应用服务器的构建服务"><span class="mr-2">7.2.5</span><span>6.2.5 基于Tomcat应用服务器的构建服务</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#6-3-多容器的应用栈"><span class="mr-2">7.3</span><span>6.3 多容器的应用栈</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-3-1-Node-js镜像"><span class="mr-2">7.3.1</span><span>6.3.1 Node.js镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-3-2-Redis基础镜像"><span class="mr-2">7.3.2</span><span>6.3.2 Redis基础镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-3-3-Redis主镜像"><span class="mr-2">7.3.3</span><span>6.3.3 Redis主镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-3-4-Redis副本镜像"><span class="mr-2">7.3.4</span><span>6.3.4 Redis副本镜像</span></a></li><li><a class="is-flex is-mobile" href="#6-3-5-创建Redis后端集群"><span class="mr-2">7.3.5</span><span>6.3.5 创建Redis后端集群</span></a></li><li><a class="is-flex is-mobile" href="#6-3-6创建Node容器"><span class="mr-2">7.3.6</span><span>6.3.6创建Node容器</span></a></li><li><a class="is-flex is-mobile" href="#6-3-7-捕获应用日志"><span class="mr-2">7.3.7</span><span>6.3.7 捕获应用日志</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#6-4-不使用SSH管理Docker容器"><span class="mr-2">7.4</span><span>6.4 不使用SSH管理Docker容器</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#第七章，Docker编配和服务发现"><span class="mr-2">8</span><span>第七章，Docker编配和服务发现</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#7-1-Docker-Compose"><span class="mr-2">8.1</span><span>7.1 Docker Compose,</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#7-1-1-安装-Docker-Compose"><span class="mr-2">8.1.1</span><span>7.1.1 安装 Docker Compose</span></a></li><li><a class="is-flex is-mobile" href="#7-1-2获取示例应用"><span class="mr-2">8.1.2</span><span>7.1.2获取示例应用</span></a></li><li><a class="is-flex is-mobile" href="#7-1-3-docker-compose-yml文件"><span class="mr-2">8.1.3</span><span>7.1.3 docker-compose.yml文件</span></a></li><li><a class="is-flex is-mobile" href="#7-1-4运行Compose"><span class="mr-2">8.1.4</span><span>7.1.4运行Compose</span></a></li><li><a class="is-flex is-mobile" href="#7-1-5使用Compose"><span class="mr-2">8.1.5</span><span>7.1.5使用Compose</span></a></li><li><a class="is-flex is-mobile" href="#7-1-6-Compose小结"><span class="mr-2">8.1.6</span><span>7.1.6 Compose小结</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#7-2-Consul-服务发现和Docker"><span class="mr-2">8.2</span><span>7.2 Consul,服务发现和Docker</span></a></li><li><a class="is-flex is-mobile" href="#7-3-Docker-Swarm"><span class="mr-2">8.3</span><span>7.3 Docker Swarm</span></a></li><li><a class="is-flex is-mobile" href="#7-4其他编配工具和组件"><span class="mr-2">8.4</span><span>7.4其他编配工具和组件</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#7-4-1-Fleet和etco"><span class="mr-2">8.4.1</span><span>7.4.1 Fleet和etco</span></a></li><li><a class="is-flex is-mobile" href="#7-4-2-Kubernetes"><span class="mr-2">8.4.2</span><span>7.4.2 Kubernetes</span></a></li><li><a class="is-flex is-mobile" href="#7-4-3-Apache-Mesos"><span class="mr-2">8.4.3</span><span>7.4.3 Apache Mesos</span></a></li><li><a class="is-flex is-mobile" href="#7-4-4-Helios"><span class="mr-2">8.4.4</span><span>7.4.4 Helios</span></a></li><li><a class="is-flex is-mobile" href="#7-4-5-Centurion"><span class="mr-2">8.4.5</span><span>7.4.5 Centurion</span></a></li></ul></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">440</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">144</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">191</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-15T01:51:14.000Z">2025-04-15</time></p><p class="title"><a href="/2025/04/15/Linux-%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E9%99%90%E5%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F/">Linux 限制内存使用量：Linux 内存调优之限制进程、系统级别内存使用量</a></p><p class="categories"><a href="/categories/test3/">test3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-13T14:50:54.000Z">2025-04-13</time></p><p class="title"><a href="/2025/04/13/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%B0%B7%E6%AD%8C68%E9%A1%B5%E7%99%BD%E7%9A%AE%E4%B9%A6%E8%A7%A3%E5%AF%86%EF%BC%9A%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%A6%82%E4%BD%95%E9%87%8D%E5%A1%91AI%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91/">谷歌68页白皮书解密：提示工程如何重塑AI交互逻辑</a></p><p class="categories"><a href="/categories/LLM/">LLM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-11T11:38:12.000Z">2025-04-11</time></p><p class="title"><a href="/2025/04/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%85%A8%E9%9D%A2%E7%9B%91%E6%8E%A7/">Linux 系统内存监控：Linux 内存调优之系统内存全面监控</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-11T11:38:12.000Z">2025-04-11</time></p><p class="title"><a href="/2025/04/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B7%B1%E5%BA%A6%E7%9B%91%E6%8E%A7/">Linux 进程内存监控：Linux 内存调优之进程内存深度监控</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T23:32:10.000Z">2025-04-08</time></p><p class="title"><a href="/2025/04/08/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%AE%A4%E8%AF%86%20Linux%20%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98/">认识 Linux 内存构成：Linux 内存调优之虚拟内存与物理内存</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AIGC/"><span class="level-start"><span class="level-item">AIGC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/BPF/"><span class="level-start"><span class="level-item">BPF</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">98</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">55</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"><span class="tag">华为云</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLM/"><span class="tag">LLM</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mysql/"><span class="tag">Mysql</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BPF/"><span class="tag">BPF</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%BD%B1%E6%9B%9D%E5%85%89/"><span class="tag">摄影曝光</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2025 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案中</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>