<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>《从Paxos到Zookper分布式一致性原理与实践》读书笔记 - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="笔记主要是关于《从Paxos到Zookeeper分布式一致性原理与实践》的学习笔记，从而对分布式有个大概的了解。对 Zookeeper有个基本认识。"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="笔记主要是关于《从Paxos到Zookeeper分布式一致性原理与实践》的学习笔记，从而对分布式有个大概的了解。对 Zookeeper有个基本认识。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mp.weixin.qq.com/img/头像.jpg"><meta property="article:published_time" content="2021-06-30T03:44:22.000Z"><meta property="article:modified_time" content="2023-06-21T11:25:59.031Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="分布式"><meta property="article:tag" content="Zookper"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2021/06/30/Java/%E3%80%8A%E4%BB%8EPaxos%E5%88%B0Zookper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"headline":"山河已无恙","image":["https://img-blog.csdnimg.cn/20210702224320371.png","https://img-blog.csdnimg.cn/20210703001921360.png","https://img-blog.csdnimg.cn/20210703012000815.png","https://img-blog.csdnimg.cn/20210703125626372.png","https://img-blog.csdnimg.cn/20210703125712845.png","https://img-blog.csdnimg.cn/20210703131627455.png","https://img-blog.csdnimg.cn/20210703132329244.png","https://img-blog.csdnimg.cn/20210703132400190.png"],"datePublished":"2021-06-30T03:44:22.000Z","dateModified":"2023-06-21T11:25:59.031Z","author":{"@type":"Person","name":"山河已无恙"},"description":"笔记主要是关于《从Paxos到Zookeeper分布式一致性原理与实践》的学习笔记，从而对分布式有个大概的了解。对 Zookeeper有个基本认识。"}</script><link rel="canonical" href="https://liruilongs.github.io/2021/06/30/Java/%E3%80%8A%E4%BB%8EPaxos%E5%88%B0Zookper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2021-06-30  <a class="commentCountImg" href="/2021/06/30/Java/%E3%80%8A%E4%BB%8EPaxos%E5%88%B0Zookper%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#comment-container"><span class="display-none-class">f381f6f655b09178272310a799f16b99</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f381f6f655b09178272310a799f16b99">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 小时  <i class="fas fa-pencil-alt"> </i>25.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">《从Paxos到Zookper分布式一致性原理与实践》读书笔记</h1><div class="content"><blockquote>
<p>笔记主要是关于《从Paxos到Zookeeper分布式一致性原理与实践》的学习笔记，从而对分布式有个大概的了解。对 Zookeeper有个基本认识。</p>
</blockquote>
<span id="more"></span>
<p><strong>写在前面</strong></p>
<hr>
<p>嗯，一直听人家说<code>分布式</code>，奈何这个概念一直不清晰，不知道和<code>微服务</code>有啥区别，而且问大佬，也总是听的一知半解的，一直听人家讲<code>Zookeeper</code>,奈何工作中遇不到，很早就想系统的学习一下，奈何时间挤不出来，除了工作就是不开心，没时间学习。现在离职准备找工作，留了点时间系统的学习一下。而且，忍受不了一知半解。要不就不学，要学就形成一个大概的知识体系，和已有的体系建立连接。至于学了有用没有，那就不重要了，也不考虑时间成本问题，要是这点任性都没有的，那活着多憋屈呀。哈哈…</p>
<p>嗯，时间原因，好多复杂的东西我都没看，先整体熟悉下，以后如果会用到在深入研究研究。</p>
<h4 id="笔记还在更新中…"><a href="#笔记还在更新中…" class="headerlink" title="笔记还在更新中….."></a>笔记还在更新中…..</h4><p><strong><font color="009688"> 傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波</strong></font></p>
<hr>
<h1 id="第1章分布式架构"><a href="#第1章分布式架构" class="headerlink" title="第1章分布式架构"></a>第1章分布式架构</h1><p>随着计算机<code>系统规模</code>变得越来越大,将所有的<code>业务单元集中部署</code>在<code>一个</code>或<code>若干个</code>大型机上的体系结构,已经越来越不能满足当今计算机系统.</p>
<h2 id="1-1从集中式到分布式"><a href="#1-1从集中式到分布式" class="headerlink" title="1.1从集中式到分布式"></a>1.1从集中式到分布式</h2><p>伴随着<code>大型主机</code>时代的到来,<code>集中式</code>的<code>计算机系统架构</code>也成为了<code>主流</code>。在那个时候,由于大型主机卓越的性能和良好的稳定性,其在单机处理能力方面的优势非常明显,使得<code>IT系统</code>快速进入了<code>集中式处理阶段</code>,其对应的计算机系统称为<code>集中式系统</code>。但从20世纪80年代以来,计算机系统向<code>网络化</code>和<code>微型化</code>的发展日趋明显,传统的<code>集中式处理模式</code>越来越不能适应人们的需求。(<font color=orange>找重点，计算机系统架构</font>,<code>即分布式是一种计算机系统架构方式</code>)</p>
<ul>
<li>学习成本高</li>
<li>大型主机贵</li>
<li>容错性差，扩容困难</li>
</ul>
<p>为了解决<code>业务快速发展</code>给<code>IT系统</code>带来的巨大挑战,从2009年开始,阿里集团启动了<code>去IOE</code>计划,其电商系统开始正式迈入<code>分布式系统时代</code>。</p>
<h3 id="1-1-1集中式的特点"><a href="#1-1-1集中式的特点" class="headerlink" title="1.1.1集中式的特点"></a>1.1.1集中式的特点</h3><p>集中式系统:指由<code>一台</code>或<code>多台主计算机</code>组成<code>中心节点</code>,数据<code>集中存储</code>于这个<code>中心节点</code>中,并且整个系统的<code>所有业务单元</code>都<code>集中部署</code>在这个<code>中心节点</code>上,系统的<code>所有功能</code>均由其<code>集中处理</code>。</p>
<p>在集中式系统中:每个<code>终端</code>或<code>客户端</code>机器仅仅负责数据的<code>录入和输出</code>,而数据的<code>存储与控制处理</code>完全交由<code>主机</code>来完成。集中式系统最大的特点就是<code>部署结构简单</code>。由于集中式系统往往基于<code>底层性能卓越</code>的<code>大型主机</code>,因此无须考虑如何对<code>服务进行多个节点的部署</code>,也就不用考虑<code>多个节点之间</code>的<code>分布式协作</code>问题。</p>
<h3 id="1-1-2分布式的特点"><a href="#1-1-2分布式的特点" class="headerlink" title="1.1.2分布式的特点"></a>1.1.2分布式的特点</h3><p>在<code>《分布式系统概念与设计》</code>生一书中,对<code>分布式系统</code>做了如下定义:</p>
<p><strong><font color="#409EFF"><code>分布式系统</code>是一个<code>硬件或软件组件</code>分布在不同的<code>网络计算机</code>上,彼此之间<code>仅仅</code>通过<code>消息传递</code>进行<code>通信和协调</code>的系统。</font></strong> (<font color=orange>找重点，硬件或软件组件</font>,个人理解 ，硬件组件分布我们可以结合<code>HarmonyOS</code>理解，音画同步，应用跨设备流转，软总线等硬件抽象的分布式，软件组件分布这里结合我们常说微服务，类比Web分布式系统。)</p>
<p>一个<code>标准的分布式系统</code>在没有任何特定业务逻辑约束的情况下,都会有如下几个<code>特征</code>。</p>
<ul>
<li><p><font color="#409EFF">分布性</font>:多台计算机都会在<code>空间上随意分布</code></p>
</li>
<li><p><font color="#409EFF">对等性</font>:计算机<code>没有主/从之分</code></p>
<ul>
<li><font color=brown>副本(Replica)</font>最常见的概念之一,对数据和服务提供的一种冗余方式。为了对外提供<font color=camel>高可用</font>的服务,我们往往会对数据和服务进行<font color=red>副本处理</font>。</li>
<li><font color=plum>数据副本</font>是指在不同的节点上持久化同一份数据,当某一个节点上存储的数据丢失时,可以从副本上读取到该数据,这是解决分布式系统数据丢失问题最为有效的手段。</li>
<li><font color=royalblue>服务副本</font>指多个节点提供同样的服务,每个节点都有能力接收来自外部的请求并进行相应的处理。</li>
</ul>
</li>
<li><p><font color=green>并发性</font>:在一个计算机网络中,程序运行过程中的<code>并发性操作</code>是非常常见的行为,例如同一个分布式系统中的<code>多个节点</code>,可能会<code>并发</code>地操作一些<code>共享的资源</code>,诸如数据库或分布式存储等.</p>
</li>
<li><p><font color=orange>缺乏全局时钟</font>一个典型的分布式系统是由一系列在<code>空间上随意分布</code>的<code>多个进程组成</code>的,具有明显的<code>分布性</code>,这些进程之间通过<code>交换消息</code>来进行<code>相互通信</code>。因此,在分布式系统中,很难定义两个事件究竟谁先谁后,原因就是因为分布式系统<code>缺乏</code>一个全局的<code>时钟序列控制</code>。</p>
</li>
<li><p><font color=brown>故障总是会发生</font>:任何在<code>设计阶段</code>考虑到的异常情况,一定会在<code>系统实际</code>运行中发生,并且,在系统实际运行过程中还会遇到很多在设计时未能考虑到的<code>异常故障</code>。所以,除非需求指标允许,在系统设计时<code>不能放过任何异常情况</code>。</p>
</li>
</ul>
<h3 id="1-1-3分布式环境的各种问题"><a href="#1-1-3分布式环境的各种问题" class="headerlink" title="1.1.3分布式环境的各种问题"></a>1.1.3分布式环境的各种问题</h3><h4 id="通信异常"><a href="#通信异常" class="headerlink" title="通信异常"></a><font color=royalblue>通信异常</font></h4><p>分布式系统需要在各个节点之间进行<code>网络通信</code>,因此每次网络通信都会伴随着网络不可用的风险,<code>网络光纤、路由器或是DNS等硬件设备</code>或是<code>系统不可用</code>都会导致最终分布式系统无法顺利完成一次网络通信。</p>
<p>即使分布式系统各节点之间的网络通信能够正常进行,其<code>延时也会远大于单机操作</code>。通常我们认为在现代计算机体系结构中,单机内存访问的延时在<code>纳秒数量级</code>(通常是10ns左右),而正常的一次<code>网络通信</code>的延迟在<code>0.1~1ms左右</code>(相当于内存访问延时的105-106倍),如此巨大的延时差别,也会影响消息的收发的过程,因此<code>消息丢失</code>和<code>消息延迟</code>变得非常普遍。</p>
<h4 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a><font color=blue>网络分区</font></h4><p>当网络由于发生异常情况,导致分布式系统中部分节点之间的网络延时不断增大,最终导致组成分布式系统的<code>所有节点中</code>,<code>只有部分节点之间能够进行正常通信,而另一些节点则不能</code>–我们将这个现象称为<code>网络分区</code>,就是俗称的<code>脑裂</code>。当网络分区出现时,分布式系统会出现<code>局部小集群</code>,在极端情况下,这些<code>局部小集群</code>会独立完成原本需要整个分布式系统才能完成的功能,包括对数据的事务处理等。</p>
<h4 id="三态"><a href="#三态" class="headerlink" title="三态"></a><font color=amber>三态</font></h4><p>分布式系统的每一次<code>请求与响应</code>,存在特有的<code>三态</code>概念,即<code>成功、失败与超时</code>。在传统的<code>单机系统</code>中,应用程序在调用一个函数之后,能够得到一个非常明确的<code>响应</code>:成功或失败</p>
<p>分布式系统中当网络出现异常的情况下,就可能会出现<code>超时</code>现象,通常有以下两种情况:</p>
<ul>
<li><font color=amber>由于网络原因,该请求(消息)并没有被成功地发送到接收方,而是在发送过程就发生了消息丢失现象。</font></li>
<li><font color=brown>该请求(消息)成功的被接收方接收后,并进行了处理,但是在将响应反馈给发送方的过程中,发生了消息丢失现象。</font></li>
</ul>
<p>当出现这样的<font color=royalblue>超时现象</font>时,网络通信的发起方是无法确定当前请求是否被成功处理的。</p>
<h3 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a><font color=brown>节点故障</font></h3><p>节点故障则是比较常见的问题,组成分布式系统的<code>服务器节点</code>出现的<code>宕机或“僵死”现象</code>。通常根据经验来说,每个节点都有可能会出现故障,并且每天都在发生。</p>
<h2 id="1-2从ACID到CAP-x2F-BASE"><a href="#1-2从ACID到CAP-x2F-BASE" class="headerlink" title="1.2从ACID到CAP&#x2F;BASE"></a>1.2从ACID到CAP&#x2F;BASE</h2><h3 id="1-2-1-ACID"><a href="#1-2-1-ACID" class="headerlink" title="1.2.1 ACID"></a>1.2.1 ACID</h3><p><code>事务(Transaction)</code>是由一系列对系统中<code>数据进行访问与更新的操作</code>所组成的一个<code>程序执行逻辑单元(Unit)</code>,狭义上的事务特指<code>数据库事务</code>。</p>
<ul>
<li>一方面,当多个应用程序并发访,问数据库时,事务可以在这些应用程序之间提供一个<code>隔离方法</code>,以防止彼此的操作互相干扰。</li>
<li>另一方面,事务为数据库操作序列提供了一个<code>从失败中恢复到正常状态的方法</code>,同时提供了数据库即使在<code>异常状态下</code>仍能保持数据<code>一致性</code>的方法。</li>
</ul>
<p>事务具有四个特征,分别是<code>原子性(Atomicity)</code>、<code>一致性(Consistency)</code>、<code>隔离性(Isolation)</code>和<code>持久性(Durability)</code>,简称为事务的ACID特性。</p>
<ul>
<li><font color=amber>原子性</font>: 事务的原子性是指<code>事务</code>必须是一个<code>原子的操作序列单元</code>。事务中包含的各项操作在<code>一次执行过程中</code>,只允许出现以下<code>两种状态之一</code>。<font color=green>全部成功执行。全部不执行</font>。任何一项操作失败都将导致整个事务失败,同时其他<font color=chocolate>已经被执行的操作都将被撤销并回滚</font>,只有所有的操作<font color=red>全部成功</font>,整个事务才算是<font color=brown>成功完成</font>。</li>
<li><font color=chocolate>一致性</font>: 事务的一致性是指<code>事务的执行</code>不能破坏<code>数据库数据的完整性和一致性</code>,一个事务在执行之前和执行之后,数据库都<font color=blue>必须处于一致性状态</font>。也就是说,事务执行的结果必须是**<font color=blue>使数据库从一个一致性状态转变到另一个一致性状态</font>,**因此当数据库只包含成功事务提交的结果时,就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障,有些事务尚未完成就被迫中断,这些未完成的事务对数据库所做的修改有一部分已写入物理数据库,这时数据库就处于一种<font color=amber>不正确</font>的状态,或者说是<font color=royalblue>不一致的状态</font>。</li>
<li><font color=blue>持久性</font>: 事务的<code>持久性</code>也被称为<code>永久性</code>,是指<code>一个事务一旦提交</code>,它对数据库中对应数据的状态变更就应该是<code>永久性</code>的。换句话说,一旦某个事务成功结束,那么它对数据库所做的更新就必须<code>被永久保存下来</code>-即使发生系统崩溃或机器宕机等故障,只要数据库能够重新启动,那么一定能够将其恢复到事务成功结束时的状态。</li>
<li><font color=plum>隔离性</font>: 事务的隔离性是指在<font color=green>并发环境</font>中,并发的事务是<font color=red>相互隔离</font>的,<code>一个事务的执行不能被其他事务干扰</code>。也就是说,不同的事务并发操纵相同的数据时,<font color=green>每个事务都有各自完整的数据空间</font>,即一个事务内部的操作及使用的数据对其他并发事务是隔离的,并发执行的各个事务之间不能互相干扰。在标准<code>SQL</code>规范中,定义了<code>4个事务隔离级别</code>,<strong><font color=green>不同的隔离级别对事务的处理不同:</font></strong></li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>未授权读取</code></td>
<td>未授权读取也被称为<code>读未提交(Read Uncommitted)</code>该隔离级别允许<code>脏读</code>取,其<code>隔离级别最低</code>。换句话说,如果<code>一个事务</code>正在处理某一数据,并对其进行了<code>更新</code>,但同时<code>尚未完成事务</code>,因此还没有进行<code>事务提交</code>;而与此同时,允许另一个事务也能够访问该数据。举个例子来说,事务A和事务B同时进行,事务A在整个执行阶段,会将某数据项的值从1开始,做一系列加法操作(比如说加1操作)直到变成10之后进行事务提交,此时,事务B能够看到这个数据项在事务A操作过程中的所有中间值(如1变成2、2变成3等),而对这一系列的中间值的读取就是<code>未授权读取</code>。</td>
</tr>
<tr>
<td><code>授权读取</code></td>
<td>授权读取也被称为<code>读已提交(Read Committed)</code>它和<code>未授权读取</code>非常相近,唯一的区别就是授权读取只允许获取<code>已经被提交的数据</code>。同样以上面的例子来说,事务A和事务B同时进行,事务A进行与上述同样的操作,此时,事务B无法看到这个数据项在事务A操作过程中的所有中间值,只能看到最终的10,另外,如果说有一个事务C,和事务A进行非常类似的操作,只是事务C是将数据项从10加到20,此时事务B也同样可以读取到20,即<code>授权读取允许不可重复读取</code>。</td>
</tr>
<tr>
<td><code>可重复读取(Repeatable Read)</code></td>
<td>简单地说,就是保证在<code>事务处理过程中</code>,<code>多次读取同一个数据时</code>,其<code>值都和事务开始时刻是一致</code>的。因此该事务级别禁止了<code>不可重复读取</code>和<code>脏读取</code>,但是有可能出现<code>幻影数据</code>。所谓<font color=purple>幻影数据</font>,就是指同样的事务操作,在<font color=seagreen>前后两个时间段内执行对同一个数据项的读取,可能出现不一致的结果</font>。在上面的例子,可重复读取隔离级别能够保证事务B在第一次事务操作过程中,始终对<code>数据项读取到1</code>,但是在下一次事务操作中,即使事务B(注意,事务名字虽然相同,但是指的是另一次事务操作)采用同样的查询方式,就可能会读取到<font color=brown>10或20.</font></td>
</tr>
<tr>
<td><code>串行化(Serializable)</code></td>
<td>是<font color=green>最严格的事务隔离级别</font>。它要求<font color=purple>所有事务都被串行执行,即事务只能一个接一个地进行处理,不能并发执行。</font>类似于java的同步块同步方法</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/60dc0ea45132923bf8953bcf.jpg"></a></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未授权读取</td>
<td>存在</td>
<td>不可以</td>
<td>存在</td>
</tr>
<tr>
<td>授权读取</td>
<td>不存在</td>
<td>不可以</td>
<td>存在</td>
</tr>
<tr>
<td>可重复读取</td>
<td>不存在</td>
<td>可以</td>
<td>存在</td>
</tr>
<tr>
<td>串行化</td>
<td>不存在</td>
<td>不存在</td>
<td>不存在</td>
</tr>
</tbody></table>
<p><code>事务隔离级别越高,就越能保证数据的完整性和一致性,但同时对并发性能的影响也越大</code>。通常,对于绝大多数的应用程序来说,可以优先考虑将<code>数据库系统的隔离级别</code>设置为<code>授权读取</code>,这能够在<code>避免脏读取</code>的同时保证<code>较好的并发性能</code>。</p>
<p><strong><font color=camel>尽管这种事务隔离级别会导致不可重复读、虚读和第二类丢失更新等并发问题,但较为科学的做法是在可能出现这类问题的个别场合中,由应用程序主动采用悲观锁或乐观锁来进行事务控制。</font></strong></p>
<h3 id="1-2-2分布式事务"><a href="#1-2-2分布式事务" class="headerlink" title="1.2.2分布式事务"></a>1.2.2分布式事务</h3><p><code>分布式事务</code>是指事务的<code>参与者</code>、支持事务的<code>服务器</code>、<code>资源服务器</code>以及<code>事务管理器</code>分别位于分布式系统的<code>不同节点之上</code>。通常一个<code>分布式事务</code>中会涉及对<code>多个数据源或业务系统</code>的操作。</p>
<h3 id="1-2-3-CAP和BASE理论"><a href="#1-2-3-CAP和BASE理论" class="headerlink" title="1.2.3 CAP和BASE理论"></a>1.2.3 CAP和BASE理论</h3><p>在可用性和一致性之间永远无法存在一个两全其美的方案,于是如何构建一个兼顾可用性和一致性”的分布式系统成为了无数工程师探讨的难题,出现了诸如CAP和BASE这样的分布式系统经典理论。</p>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a><font color=blue>CAP定理</font></h4><p><code>CAP定理</code>:CAP理论告诉我们,<font color=red>一个分布式系统不可能同时满足<code>一致性(C: Consistency)</code>、<code>可用性(A: Availability)</code>和<code>分区容错性(P: Partition tolerance)</code>这三个基本需求,<code>最多只能同时满足其中的两项</code>。</font></p>
<p><font color=royalblue>一致性</font>:在分布式环境中,一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性的需求下,当一个系统在数据一致的状态下执行更新操作后,应该保证系统的数据仍然处于一致的状态。那么这样的系统就被认为<code>具有强一致性(或严格的一致性)</code>。</p>
<p><font color=yellowgreen>可用性</font>:可用性是指系统提供的服务<code>必须一直处于可用的状态</code>,对于用户的每一个操作请求总是能够在<code>有限的时间内返回结果</code>。对于用户的一个操作请求,系统必须能够在指定的时间(即响应时间)内返回对应的处理结果,如果超过了这个时间范围,那么系统就被认为<font color=purple>不可用。</font></p>
<p><font color=blue>分区容错性</font>:分区容错性 <strong><font color=tomato>约束</font></strong> 了一个分布式系统需要具有如下<code>特性</code>:</p>
<ul>
<li>分布式系统在遇到<font color=brown>任何网络分区故障</font>的时候,仍然需要能够保证对外提供满足<code>一致性和可用性</code>的<font color=camel>服务</font>,除非是整个网络环境都发生了故障。</li>
<li><code>网络分区</code>是指在分布式系统中,<font color=royalblue>不同的节点分布在不同的子网络(机房或异地网络等)中</font>,由于一些特殊的原因导致这些子网络之间出现网络不连通的状况,但各个子网络的内部网络是正常的,从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是,组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的<code>网络分区</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>放弃CAP定理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>放弃P(分区容错性)</code></td>
<td>如果希望能够避免系统出现分区容错性问题,一种较为简单的做法是将所有的数据(或者仅仅是那些与事务相关的数据)都放在一个分布式节点上。这样的做法虽然无法100%地保证系统不会出错,但至少不会碰到由于网络分区带来的负面影响。但同时需要注意的是,放弃P的同时也就意味着放弃了系统的可扩展性,<code>分区容错性可以说是一个最基本的要求</code></td>
</tr>
<tr>
<td><code>放弃A(可用性)</code></td>
<td>相对于放弃“分区容错性”来说,放弃可用性则正好相反,其做法是一旦系统遇到网络分区或其他故障时,那么受到影响的服务需要等待一定的时间,因.此在等待期间系统无法对外提供正常的服务,即不可用</td>
</tr>
<tr>
<td><code>放弃C(一致性)</code></td>
<td>这里所说的放弃一致性,并不是完全不需要数据一致性,如果真是这样的话,那么系统的数据都是没有意义的,整个系统也是没有价值的。<font color=seagreen>事实上,放弃一致性指的是放弃數据的强一致性,而保留數据的最终一致性。这样的系统无法保证数据保持实时的一致性,但是能够承诺的是,数据最终会达到一个一致的状态。</font>这就引入了一个<code>时间窗口</code>的概念,具体多久能够达到<code>数据一致</code>取决于<code>系统的设计</code>,主要包<code>括数据副本在不同节点之间的复制时间长短</code></td>
</tr>
</tbody></table>
<p><strong><font color=tomato>而对于分布式系统而言,网络问题又是一个必定会出现的异常情况,因此<code>分区容错性</code>也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在<code>C(一致性)和A (可用性)之间寻求平衡</code>。</font></strong></p>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a><font color=camel>BASE理论</font></h4><p><code>BASE</code>是<code>Basically Available (基本可用)</code>, <code>Soft state (软状态)</code>和<code>Eventually consistent(最终一致性)</code>三个短语的简写.</p>
<p><strong><font color=orange>BASE是对CAP中一致性和可用性权衡的结果</font></strong>,其来源于对大规模互联网系统分布式实践的总结,是基于CAP定理逐步演化而来的,<strong><font color=yellowgreen>其核心思想是即使无法做到强一致性(Strong consistency),但每个应用都可以根据自身的业务特点,采用适当的方式来使系统达到最终一致性(Eventual consistency)</font></strong>,</p>
<p><strong><font color=seagreen><code>BASE</code>中的三要素</font></strong>:</p>
<ul>
<li><p><code>基本可用</code>:是指分布式系统在<code>出现不可预知故障</code>的时候,<code>允许损失部分可用性</code>-但请注意,这绝不等价于系统不可用。以下两个就是“<code>基本可用</code>”的典型例子。</p>
<ul>
<li><code>响应时间上的损失</code>:正常情况下,一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果,但由于出现故障(比如系统部分机房发生断电或断网故障) ,查询结果的响应时间增加到了1-2秒。</li>
<li><code>功能上的损失</code>:正常情况下,在一个电子商务网站上进行购物,消费者几乎能够顺利地完成每一笔订单,但是在一些节日大促购物高峰的时候,由于消费者的购物行为激增,为了保护购物系统的稳定性,部分消费者可能会被引导到一个<code>降级页面</code>。</li>
</ul>
</li>
<li><p><code>弱状态</code>:<font color=amber>弱状态也称为软状态</font>,和硬状态相对,是指允许<font color=seagreen>系统中的数据存在中间状态,并认为该中间状态的存在不会影响系统的整体可用性,即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</font>。</p>
</li>
<li><p><code>最终一致性</code>:最终一致性强调的是系统中所有的数据副本,在经过一段时间的同步后,最终能够达到一个一致的状态。因此,最终一致性的本质是<font color=green>需要系统保证最终数据能够达到一致</font>,而不需要实时保证系统数据的强一致性。</p>
</li>
</ul>
<p><code>亚马逊首席技术官Werner Vogels在于2008年发表的一篇经典文章</code>：对最终一致性进行了非常详细的介绍。他认为最终一致性是一种<code>特殊的弱一致性</code>:<font color=camel>系统能够保证在没有其他新的更新操作的情况下,数据最终一定能够达到一致的状态,因此所有客户端对系统的数据访问都能够获取到最新的值</font>。同时,在没有发生故障的前提下,<font color=orange>数据达到一致状态的时间延迟,取决于网络延迟、系统负载和数据复制方案设计等</font></p>
<p><strong>最终一致性变种：</strong></p>
<p><strong><code>因果一致性( Causal consistency )</code></strong><br><font color=blue>因果一致性</font>是指,如果进程A在更新完某个数据项后通知了进程B,那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值,并且如果进程B要对该数据项进行更新操作的话,务必基于进程A更新后的最新值,<code>即不能发生丢失更新情况</code>。与此同时,与进程A无因果关系的进程C的数据访问则没有这样的限制。</p>
<p><strong><code>读已之所写( Read your writes)</code></strong><br><font color=blue>读己之所写</font>是指,进程A更新一个数据项之后,它自己总是能够访问到更新过的最新值,而不会看到旧值。也就是说,对于单个数据获取者来说,其读取到的数据,一定不会比自己上次写入的值旧。因此,读己之所写也可以看作是一种特殊的因果一致性。</p>
<p><strong><code>会话一致性(Session consistency )</code></strong><br><font color=tomato>会话一致性</font>将对系统数据的访问过程框定在了一个会话当中:<font color=blue>系统能保证在同一个有效的会话中实现“读己之所写”的一致性,也就是说,执行更新操作之后,客户端能够在同一个会话中始终读取到该数据项的最新值。</font><br><strong><code>单调读一致性( Monotonic read consistency )</code></strong><br><font color=green>单调读一致性</font>是指如果一个进程从系统中读取出一个数据项的某个值后,那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。**<font color=brown>单调写一致性是指,一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</font>**</p>
<p>总的来说, <code>BASE</code>理论面向的是<font color=chocolate>大型高可用可扩展的分布式系统</font>,和<font color=chocolate>传统事务的ACID特性是相反的</font>,它完全不同于<code>ACID的强一致性模型</code>,而是提出通过<code>牺牲强一致性来获,得可用性</code>,并允许数据在一段时间内是不一致的,但最终达到一致状态。但同时,<strong><font color=amber>在实际的分布式场景中,不同业务单元和组件对数据一致性的要求是不同的,因此在具体的分布式系统架构设计过程中, <code>ACID</code>特性与<code>BASE</code>理论往往又会结合在一起使用。</font></strong></p>
<h1 id="第2章一致性协议"><a href="#第2章一致性协议" class="headerlink" title="第2章一致性协议"></a>第2章一致性协议</h1><p>为了解决分布式一致性问题,在长期的探索研究过程中,涌现出了一大批经典的<code>一致性协议和算法</code>,其中最著名的就是<code>二阶段提交协议</code>、<code>三阶段提交协议</code>和<code>Paxos算法</code>了。</p>
<h2 id="2-1-2PC3PC"><a href="#2-1-2PC3PC" class="headerlink" title="2.1 2PC3PC"></a>2.1 2PC3PC</h2><p>在<font color=seagreen>分布式系统</font>中,每一个机器节点虽然都能够明确地知道自己在进行事务操作过程中的结果是成功或失败,但却<font color=chocolate>无法直接获取到其他分布式节点的操作结果</font>。因此,当一个事务操作需要<code>跨越多个分布式节点</code>的时候,为了<code>保持事务处理的ACID特性</code>,就需要<code>引入一个称为“协调者(Coordinator)”的组件</code>来统一调度所有<code>分布式节点的执行逻辑</code>,这些<code>被调度的分布式节点则被称为“参与者” (Participant)</code>,<code>协调者</code>负责<code>调度参与者的行为</code>,并最终决定这些<code>参与者</code>是否要把<code>事务真正进行提交</code>。基于这个思想,衍生出了<code>二阶段提交</code>和<code>三阶段提交</code>两种协议。</p>
<h3 id="2-1-1-2PC"><a href="#2-1-1-2PC" class="headerlink" title="2.1.1 2PC"></a>2.1.1 2PC</h3><p><strong><font color=green>2PC,是Two-Phase Commit的缩写,即二阶段提交</font></strong>,是计算机网络尤其是在数据库领域内,为了使基于<code>分布式系统架构下</code>的所有节点在进行事务处理过程中能够保持<code>原子性和一致性</code>而设计的一种算法。通常,二阶段提交协议也被认为是一种<code>一致性协议</code>,用来保证分布式系统数据的一致性。目前,绝大部分的<code>关系型数据库</code>都是采用<code>二阶段提交协议</code>·来完成<code>分布式事务处理</code>的,利用该协议能够非常方便地完成所有<code>分布式事务参与者的协调</code>,统一决定<code>事务的提交或回滚</code>,从而能够有效地保证分布式数据一致性.</p>
<h4 id="协议说明"><a href="#协议说明" class="headerlink" title="协议说明"></a><font color=royalblue>协议说明</font></h4><p>顾名思义,二阶段提交协议是将事务的提交过程分成了两个阶段</p>
<p><strong><font color=green>阶段一:提交事务请求</font></strong></p>
<ol>
<li>事务询问。<code>协调者</code>向所有的<code>参与者</code>发送事务内容,询问是否可以执行事务提交操作,并开始等待各参与者的响应。</li>
<li>执行事务。各<code>参与者</code>节点执行事务操作,并将<code>Undo</code>和<code>Redo</code>信息记入事务日志中。</li>
<li>各参与者向协调者反馈事务询问的响应。</li>
</ol>
<p>如果参与者成功执行了事务操作,那么就反馈给<code>协调者Yes</code>响应,表示事务<code>可以执行</code>;如果参与者<code>没有成功执行事务</code>,那么就反馈给<code>协调者No</code>响应,表示事务<code>不可以执行</code>。</p>
<p>由于上面讲述的内容在形式上近似是<code>协调者组织各参与者</code>对一次事务操作的<code>投票表态过程</code>,因此二阶段提交协议的<code>阶段一</code>也被称为“<code>投票阶段</code>”,即各<code>参与者投票</code>表明是否要继续执行接下的事务提交操作。</p>
<p><strong><font color=plum>阶段二:执行事务提交</font></strong></p>
<p>阶段二中,协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作,正常情况下,包含以下两种可能:</p>
<ul>
<li><code>执行事务提交</code>:假如协调者从所有的参与者获得的反馈都是Yes响应,那么就会<code>执行事务提交</code>。<ol>
<li><code>发送提交请求</code>。协调者向所有参与者节点发出Commit请求。</li>
<li><code>事务提交</code>。参与者接收到Commit请求后,会正式执行事务提交操作,并在完成提交之后释放在整个事务执行期间占用的事务资源。</li>
<li><code>反馈事务提交结果</code>。参与者在完成事务提交之后,向协调者发送Ack消息。</li>
<li><code>完成事务</code>。协调者接收到所有参与者反馈的Ack消息后,完成事务。</li>
</ol>
</li>
<li><code>中断事务</code>:假如任何一个参与者向协调者反馈了No响应,或者在等待超时之后,协调者尚无法接收到所有参与者的反馈响应,那么就会<font color=orange>中断事务</font>。<ol>
<li><code>发送回滚请求</code>。协调者向所有参与者节点发出Rollback请求。</li>
<li><code>事务回滚</code>。参与者接收到Rollback请求后,会利用其在阶段一中记录的Undo信息来执行事务回滚操作,并在完成回滚之后释放在整个事务执行期间占用的资源。</li>
<li><code>反馈事务回滚结果</code>。参与者在完成事务回滚之后,向协调者发送Ack消息。</li>
<li><code>中断事务</code>。协调者接收到所有参与者反馈的Ack消息后,完成事务中断。</li>
</ol>
</li>
</ul>
<p>二阶段提交将<font color=plum>一个事务的处理过程分为了<code>投票</code>和<code>执行</code>两个阶段</font>,其核心是对每个事务都采用<code>先尝试后提交</code>的处理方式,因此也可以将二阶段提交看作一个<code>强一致性的算法</code>.<br><img src="https://img-blog.csdnimg.cn/20210702224336758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong><font color=red>优缺点</font></strong>:</p>
<ul>
<li>优点:<code>原理简单,实现方便。</code></li>
<li>缺点:<code>同步阻塞、单点问题、脑裂、太过保守。</code></li>
</ul>
<p><font color=yellowgreen>同步阻塞</font>:<font color=orange>所有参与该事务操作的逻辑都处于阻塞状态,也就是说,各个参与者在等待其他参与者响应的过程中,将无法进行其他任何操作。</font></p>
<p><font color=camel>单点问题</font>:<font color=brown>如果协调者是在阶段二中出现问题的话,那么其他参与者将会一直处于锁定事务资源的状态中,而无法继续完成事务操作。</font></p>
<p><font color=amber>数据不一致</font>:在二阶段提交协议的阶段二,即执行事务提交的时候,当协调者向所有的参与者发送Commit请求之后,<font color=amber>发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃,导致最终只有部分参与者收到了Commit请求</font>。于是,这部分收到了Commit请求的参与者就会进行事务的提交,而其他没有收到Commit请求的参与者则无法进行事务提交,于是<font color=yellowgreen>整个分布式系统便出现了数据不一致性现象</font>。</p>
<p><font color=camel>太过保守</font>:如果在协调者指示参与者进行事务提交询问的过程中,参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话,这时协调者只能依靠其自身的超时机制来判断是否需要中断事务,这样的策略显得比较保守。换句话说,<font color=blue>二阶段提交协议没有设计较为完善的容错机制,任意一个节点的失败都会导致整个事务的失败。</font></p>
<h3 id="2-1-2-3PC"><a href="#2-1-2-3PC" class="headerlink" title="2.1.2 3PC"></a>2.1.2 3PC</h3><p>二阶段提交协议的基础上进行了改进,提出了三阶段提交协议。</p>
<p><strong><font color=royalblue>3PC,是Three-Phase Commit的缩写,即三阶段提交</font></strong>,是2PC的改进版,其将二阶段提交协议的“提交事务请求”过程一分为二,形成了由<code>CanCommit</code>, <code>PreCommit</code>和<code>do Commit</code>三个阶段组成的事务处理协议.</p>
<h4 id="阶段一-CanCommit1"><a href="#阶段一-CanCommit1" class="headerlink" title="阶段一: CanCommit1"></a><font color=brown>阶段一: CanCommit1</font></h4><p>  1.<code> 事务询问</code>。协调者向所有的参与者发送一个包含事务内容的canCommit请求,询问是否可以执行事务提交操作,并开始等待各参与者的响应。<br>  2. <code>各参与者向协调者反馈事务询问的响应</code>。参与者在接收到来自协调者的canCommit请求后,正常情况下,如果其自身认为可以顺利执行事务,那么会反馈Yes响应,并进入预备状态,否则反馈No响应。</p>
<h4 id="阶段二-PreCommit"><a href="#阶段二-PreCommit" class="headerlink" title="阶段二: PreCommit"></a><font color=seagreen>阶段二: PreCommit</font></h4><p>在阶段二中,协调者会根据各参与者的反馈情况来决定是否可以进行事务的<code>PreCommit</code>操作,正常情况下,包含两种可能。</p>
<ul>
<li><font color=red>执行事务预提交</font>假如协调者从所有的参与者获得的反馈都是Yes响应,那么就会执行事务预提交。<ol>
<li><code>发送预提交请求</code>。协调者向所有参与者节点发出<code>preCommit的请求</code>,<code>并进入Prepared阶段。</code></li>
<li><code>事务预提交</code>。<code>参与者</code>接收到<code>preCommit</code>请求后,会执行事务操作,并将<code>Undo和Redo信息记录到事务日志</code>中。</li>
<li><code>各参与者向协调者反馈事务执行的响应</code>。如果<code>参与者</code>成功执行了事务操作,那么就会反馈给<code>协调者Ack响应</code>,同时等待最终的指令:提交(commit)或中止(abort)中断事务</li>
</ol>
</li>
<li><font color=royalblue>中断事务</font>假如任何一个参与者向协调者反馈了No响应,或者在等待超时之后,协调者尚无法接收到所有参与者的反馈响应,那么就会中断事务。<ol>
<li><code>发送中断请求</code>。协调者向所有<code>参与者</code>节点发出<code>abort请求</code>。</li>
<li><code>中断事务</code>。无论是收到来自<code>协调者的abort请求</code>,或者是在等待<font color=blue>协调者</font>请求过程中出现超时,<font color=red>参与者</font>都会<code>中断事务</code>。</li>
</ol>
</li>
</ul>
<h4 id="阶段三-doCommit"><a href="#阶段三-doCommit" class="headerlink" title="阶段三: doCommit"></a><font color=red>阶段三: doCommit</font></h4><p>该阶段将进行真正的事务提交,会存在以下两种可能的情况。</p>
<ul>
<li><font color=chocolate> 执行提交.</font><ol>
<li><code>发送提交请求</code>。进入这一阶段,假设<code>协调者</code>处于正常工作状态,<code>并且它接收到了来自所有参与者的Ack响应,那么它将从“预提交”状态转换到“提交”状态,并向所有的参与者发送doCommit请求。</code></li>
<li><code>事务提交</code>。<code>参与者</code>接收到doCommit请求后,<code>会正式执行事务提交操作,并在完成提交之后释放在整个事务执行期间占用的事务资源。</code></li>
<li><code>反馈事务提交结果</code>。<code>参与者</code>在完成事务提交之后,<code>向协调者发送Ack消息</code>。</li>
<li><code>完成事务</code>。<code>协调者接收到所有参与者反馈的Ack消息后,完成事务</code>。</li>
</ol>
</li>
<li><font color=red>中断事务</font>进入这一阶段,假设<code>协调者</code>处于正常工作状态,并且有任意一个参与者向协调者反馈了No响应,或者在等待超时之后,协调者尚无法接收到所有参与者的反馈响应,那么就会<code>中断事务</code>。<ol>
<li><code>发送中断请求</code>。<code>协调者</code>向所有的参与者节点发送<code>abort请求</code>。</li>
<li><code>事务回滚</code>。参与者接收到<code>abort请求</code>后,会利用其在阶段二中记录的<code>Undo信息来执行事务回滚操作</code>,并在完成回滚之后释放在整<code>个事务执行期间占用的资源。</code></li>
</ol>
</li>
</ul>
<p>需要注意的是,一旦进入阶段三,可能会存在以下两种故障。</p>
<ul>
<li>协调者出现问题。</li>
<li>协调者和参与者之间的网络出现故障。</li>
</ul>
<p>无论出现哪种情况,最终都会导致参与者无法及时接收到来自协调者的<code>doCommit</code>或是<code>abort请求</code>,针对这样的异常情况,参与者都会在<font color=yellowgreen>等待超时之后</font>,继续进行<code>事务提交</code>。<br><strong><font color=tomato>感觉这里说的有点问题，感觉和第二阶段的中断事务是有冲突的</font></strong><br><strong><font color=plum>优缺点</font></strong><br><font color=seagreen>三阶段提交协议的优点</font>:<br>相较于二阶段提交协议,三阶段提交协议最大的优点就是<code>降低了参与者的阻塞范围</code>,并且能够在出现单点故障后继续达成一致。<br><font color=orange>三阶段提交协议的缺点:</font><br>三阶段提交协议在去除阻塞的同时也引入了新的问题,那就是在<code>参与者接收到preCommit消息后</code>,如果网络出现分区,此时协调者所在的节点和参与者无法进行正常的网络通信,在这种情况下,该参与者依然会进行事务的提交,这必然出现<code>数据的不一致性</code>。</p>
<h2 id="2-2-Paxos算法"><a href="#2-2-Paxos算法" class="headerlink" title="2.2 Paxos算法"></a>2.2 Paxos算法</h2><p>嗯,这部分有点深，简单了解一下。</p>
<h3 id="2-2-1追本湖源"><a href="#2-2-1追本湖源" class="headerlink" title="2.2.1追本湖源"></a>2.2.1追本湖源</h3><ul>
<li>拜占廷将军问题</li>
<li>Paxos算法名称的由来也是取自Lamport论文(The Par-Time Parliament)中提到的Paxos小岛。</li>
</ul>
<h3 id="2-2-2-Paxos理论的诞生"><a href="#2-2-2-Paxos理论的诞生" class="headerlink" title="2.2.2 Paxos理论的诞生"></a>2.2.2 Paxos理论的诞生</h3><p>由于Lamport个人自负固执的性格,使得Paxos理论的诞生可谓一波三折。</p>
<h3 id="2-2-3-Paxos算法详解"><a href="#2-2-3-Paxos算法详解" class="headerlink" title="2.2.3 Paxos算法详解"></a>2.2.3 Paxos算法详解</h3><p>嗯。。。这个以后在学习。</p>
<h1 id="第3章Paxos的工程实践"><a href="#第3章Paxos的工程实践" class="headerlink" title="第3章Paxos的工程实践"></a>第3章Paxos的工程实践</h1><p>嗯。。。这个以后在学习。</p>
<h1 id="第4章Zookeeper与Paxos"><a href="#第4章Zookeeper与Paxos" class="headerlink" title="第4章Zookeeper与Paxos"></a>第4章Zookeeper与Paxos</h1><p><code>Apache ZooKeeper</code>是由<code>Apache Hadoop</code>的子项目发展而来,于2010年11月正式成为了Apache的顶级项目。<code>ZooKeeper</code>为<code>分布式应用</code>提供了<code>高效</code>且<code>可靠</code>的<code>分布式协调服务</code>,提供了诸如<code>统一命名服务</code>、<code>配置管理</code>和<code>分布式锁</code>等分布式的<code>基础服务</code>。在解决分布式数据一致性方面, ZooKeeper并没有直接采用Paxos算法,而是采用了一种被称为<code>ZAB(Zookeeper Atomic Broadcast)</code>的一致性协议。</p>
<h2 id="4-1初识ZooKeeper"><a href="#4-1初识ZooKeeper" class="headerlink" title="4.1初识ZooKeeper"></a>4.1初识ZooKeeper</h2><h3 id="4-1-1-ZooKeeper介绍"><a href="#4-1-1-ZooKeeper介绍" class="headerlink" title="4.1.1 ZooKeeper介绍"></a>4.1.1 ZooKeeper介绍</h3><p><code>ZooKeeper</code>是一个开放源代码的<code>分布式协调服务</code>,由知名互联网公司<code>雅虎</code>创建,是<code>Google.Chubby</code>的开源实现。<code>ZooKeeper</code>的设计目标是将那些复杂且容易出错的<code>分布式一致性服务</code>封装起来,构成一个<code>高效可靠的原语集</code>,并以一系列简单易用的接口提供给用户使用。</p>
<h4 id="Zookeeper是什么"><a href="#Zookeeper是什么" class="headerlink" title="Zookeeper是什么"></a>Zookeeper是什么</h4><p><code>Zookeeper</code>是一个典型的<code>分布式数据一致性</code>的解决方案,分布式应用程序可以基于它实现如<font color=amber>数据发布&#x2F;订阅</font>、<font color=orange>负载均衡</font>、<font color=chocolate>命名服务</font>、<font color=seagreen>分布式协调&#x2F;通知</font>、<font color=green>集群管理</font>、<font color=brown>Master选举</font>、<font color=orange>分布式锁和分布式队列等功能</font>. ZooKeeper可以保证如下分布式一致性特性.</p>
<ul>
<li><font color=camel>顺序一致性</font>：从同一个客户端发起的事务请求,最终将会严格地按照其发起顺序被应用到ZooKeeper中去.</li>
<li><font color=plum>原子性</font>：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的,也就是说,要么整个集群所有机器都成功应用了某一个事务,要么都没有应用,一定不会出现集群中部分机器应用了该事务,而另外一部分没有应用的情况</li>
<li><font color=blue>单一视围( Single System Image )</font>：无论客户端连接的是哪个ZooKeeper服务器,其看到的服务端数据模型都是一致的。</li>
<li><font color=yellowgreen>可靠性</font>：一旦服务端成功地应用了一个事务,并完成对客户端的响应,那么该事务所引起的服务端状态变更将会被一直保留下来,除非有另一个事务又对其进行了变更。</li>
<li><font color=green>实时性</font>:Zookeeper仅仅保证在一定的时间段内,客户端最终一定能够从服务端上读取到最新的数据状态。</li>
</ul>
<h4 id="ZooKeeper的设计目标"><a href="#ZooKeeper的设计目标" class="headerlink" title="ZooKeeper的设计目标"></a>ZooKeeper的设计目标</h4><p>Zookeeper致力于提供一个<font color=blue>高性能、高可用,且具有严格的顺序访问控制能力(主要是写操作的严格顺序性)的分布式协调服务</font>。高性能使得ZooKeeper能够应用于那些<code>对系统吞吐有明确要求的大型分布式系统</code>中,<code>高可用使得分布式的单点问题</code>得到了很好的解决,而严格的顺序访问控制使得客户端能够<code>基于ZooKeeper实现一些复杂的同步原语</code>。下面我们来具体看一下Zookeeper的四个设计目标。</p>
<ul>
<li>目标一:<font color=red>简单的数据模型</font>:<code>ZooKeeper</code>使得分布式程序能够通过一个共享的、树型结构的名字空间来进行相互协调。</li>
<li>目标二:<font color=orange>可以构建集群</font>:一个<code>ZooKeeper</code>集群通常由一组机器组成,一般3-5台机器就可以组成一个可用的ZooKeeper集群了。</li>
<li>目标三:<font color=orange>顺序访问</font>:对于来自客户端的每个更新请求, ZooKeeper都会分配一个全局唯一的递增编号,这个编号反映了所有事务操作的先后顺序,应用程序可以使用ZooKeeper的这个特性来实现更高层次的同步原语。关于ZooKeeper的事务请求处理和事务ID的生成,</li>
<li>目标四:<font color=seagreen>高性能</font>“由于ZooKeeper将全量数据存储在内存中,并直接服务于客户端的所有非事务请求,因此它尤其适用于以读操作为主的应用场景。</li>
</ul>
<h3 id="4-1-2-Zookeeper从何而来"><a href="#4-1-2-Zookeeper从何而来" class="headerlink" title="4.1.2 Zookeeper从何而来"></a>4.1.2 Zookeeper从何而来</h3><blockquote>
<p>关于”ZooKeeper”这个项目的名字,其实也有一段趣闻。在立项初期,考虑到之前内部很多项目都是使用动物的名字来命名的(例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家Raghu Ramakrishnan开玩笑地说: “在这样下去,我们这儿就变成动物园了!”此话一出,大家纷纷表示就叫动物园管理员吧-因为各个以动物命名的分布式组件放在一起,雅虎的整个分布式系统看上去就像一个大型的动物园了,而ZooKeeper正好要用来进行分布式环境的协调-于是,ZooKeeper的名字也就由此诞生了。</p>
</blockquote>
<h3 id="4-1-3-ZooKeeper的基本概念"><a href="#4-1-3-ZooKeeper的基本概念" class="headerlink" title="4.1.3 ZooKeeper的基本概念"></a>4.1.3 ZooKeeper的基本概念</h3><h4 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a><font color=plum>集群角色</font></h4><p>通常在分布式系统中,构成一个集群的每一台机器都有自己的角色,最典型的集群模式就是<code>Master/Slave模式(主备模式)</code>。在这种模式中,我们把能够处理所有<code>写操作的机器称为Master机器</code>,把所有<code>通过异步复制方式获取最新数据,并提供读服务的机器称为Slave机器</code>。</p>
<p>而在ZooKeeper中,这些概念被颠覆了。它没有沿用传统的Master&#x2F;Slave概念,而是引入了<font color=green>Leader</font>, <font color=yellowgreen>Follower</font>和<font color=seagreen>Observer</font>三种角色。ZooKeeper集群中的所有机器通过一个<code>Leader选举</code>过程来选定一台被称为”<font color=seagreen>Leader</font>“的机器, <code>Leader服务器</code>为客户端提供<code>读和写服务</code>。除Leader外,其他机器包括<code>Follower``和Observer</code>, <code>Follower</code>和<code>Observer</code>都能够提供<font color=tomato>读服务</font>,唯一的区别在于,<font color=camel> Observer机器不参与Leader选举过程</font>,也不参与<font color=purple>写操作的“过半写成功”策略</font>,因此<code>Observer</code>可以在不影响写性能的情况下提升<code>集群的读性能</code>。</p>
<h4 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话(Session)"></a><font color=tomato>会话(Session)</font></h4><p>Session是指客户端会话,在讲解会话之前,我们首先来了解一下客户端连接。在ZooKeeper中,一个客户端连接是指客户端和服务器之间的<code>一个TCP长连接</code>.ZooKeeper对外的服务端口默认是<code>2181</code>,客户端启动的时候,首先会与服务器建立一个<code>TCP连接</code>,从第一次连接建立开始,客户端会话的生命周期也开始了,通过这个连接,客户端能够通过<code>心跳检测</code>与<code>服务器保持有效的会话</code>,也能够向<code>ZooKeeper服务器</code>发送请求并接受响应,同时还能够通过该连接接收来自服务器的<code>Watch事件</code>通知.</p>
<h4 id="数据节点-Znode"><a href="#数据节点-Znode" class="headerlink" title="数据节点(Znode)"></a><font color=royalblue>数据节点(Znode)</font></h4><p>在谈到分布式的时候,我们通常说的<font color=yellowgreen>“节点”是指组成集群的每一台机器</font>。然而,在ZooKeeper中, <font color=brown>“节点”分为两类,</font>第一类同样是<font color=yellowgreen>指构成集群的机器,我们称之为机器节点</font>;第二类则是指数<font color=yellowgreen>据模型中的数据单元,我们称之为数据节点-ZNode</font>,.</p>
<p>ZooKeeper将所有数据存储在内存中,数据模型是一棵树(ZNode Tree),由斜杠(&#x2F;)进行分割的路径,就是一个Znode,例如&#x2F;oo&#x2F;pathl,每个ZNode上都会保存自己的数据内容,同时,还会保存一系列属性信息。在ZooKeeper中,<font color=amber> ZNode可以分为持久节点和临时节点两类</font>。所谓持久节点是指一旦这个ZNode被创建了,除非主动进行ZNode的移除操作,否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了,它的生命周期和客户端会话绑定,一旦客户端会话失效,那么这个客户端创建的所有临时节点都会被移除。</p>
<p>Zookeeper还允许用户为<code>每个节点添加一个特殊的属性: SEQUENTIAL</code>,一旦节点被标记上这个属性,那么在这个节点被创建的时候, ZooKeeper会自动在其节点名后面追加上一个整型数字,这个整型数字是一个由父节点维护的自增数字。</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a><font color=yellowgreen>版本</font></h4><p>在前面我们已经提到, <code>ZooKeeper</code>的每个<code>ZNode</code>上都会存储数据,对应于每个<code>ZNode</code>,<code>ZooKeeper都会为其维护一个叫作Stat的数据结构</code>, Stat中记录了这个ZNode的三个数据版本,分别是<code>version (当前ZNode的版本)</code>, <code>cversion (当前ZNode子节点的版本)</code>和<code>aversion (当前ZNode的ACL版本)</code></p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a><font color=green>Watcher</font></h4><p><code>Watcher (事件监听器)</code>,是ZooKeeper中的一个很重要的特性。<font color=royalblue>ZooKeeper允许用户在指定节点上注册一些Watcher,并且在一些特定事件触发的时候, ZooKeeper服务端会将事件通知到感兴趣的客户端上去,该机制是ZooKeeper实现分布式协调服务的重要特性</font>。</p>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a><font color=amber>ACL</font></h4><p>ZooKeeper采用<code>ACL (Access Control Lists)策略</code>来进行权限控制,类似于<code>UNIX文件系统的权限控制</code>。ZooKkeeper定义了如下5种权限。</p>
<ul>
<li>CREATE;创建子节点的权限。</li>
<li>READ:获取节点数据和子节点列表的权限。</li>
<li>WRITE:更新节点数据的权限。</li>
<li>DELETE:删除子节点的权限。</li>
<li>ADMIN:设置节点ACL的权限。其中尤其需要注意的是.</li>
</ul>
<p><code>CREATE</code>和<code>DELETE</code>这两种权限都是针对子节点的权限控制。</p>
<h3 id="4-1-4为什么选择Zookeeper"><a href="#4-1-4为什么选择Zookeeper" class="headerlink" title="4.1.4为什么选择Zookeeper"></a>4.1.4为什么选择Zookeeper</h3><ul>
<li>达到了一个工业级产品的标准。其次, ZooKeeper是开放源代码的.</li>
<li>ZooKeeper是免费的,你无须为它支付任何费用。</li>
<li>ZooKeeper已经得到了广泛的应用。诸如Hadoop, HBase, Storm和Solr等.</li>
</ul>
<h2 id="4-2-Zookeeper的ZAB协议"><a href="#4-2-Zookeeper的ZAB协议" class="headerlink" title="4.2 Zookeeper的ZAB协议"></a>4.2 Zookeeper的ZAB协议</h2><p>嗯，时间紧张，这部分以后在看</p>
<h3 id="4-2-1-ZAB协议"><a href="#4-2-1-ZAB协议" class="headerlink" title="4.2.1 ZAB协议"></a>4.2.1 ZAB协议</h3><h3 id="4-2-2协议介绍"><a href="#4-2-2协议介绍" class="headerlink" title="4.2.2协议介绍"></a>4.2.2协议介绍</h3><h3 id="4-2-3深入ZAB协议"><a href="#4-2-3深入ZAB协议" class="headerlink" title="4.2.3深入ZAB协议"></a>4.2.3深入ZAB协议</h3><h3 id="4-2-4-ZAB与Paxos算法的联系与区别"><a href="#4-2-4-ZAB与Paxos算法的联系与区别" class="headerlink" title="4.2.4 ZAB与Paxos算法的联系与区别"></a>4.2.4 ZAB与Paxos算法的联系与区别</h3><h1 id="第5章使用Zookeeper"><a href="#第5章使用Zookeeper" class="headerlink" title="第5章使用Zookeeper"></a>第5章使用Zookeeper</h1><h2 id="5-1部署与运行"><a href="#5-1部署与运行" class="headerlink" title="5.1部署与运行"></a>5.1部署与运行</h2><p>如何部署一个ZooKeeper集群。</p>
<h3 id="5-1-1系统环境"><a href="#5-1-1系统环境" class="headerlink" title="5.1.1系统环境"></a>5.1.1系统环境</h3><ul>
<li>操作系统: GNU&#x2F;Linux, Sun Solaris, Win32以及MacoSX等</li>
<li>Java环境: JDK1.6 以上。</li>
</ul>
<h3 id="5-1-2集群与单机"><a href="#5-1-2集群与单机" class="headerlink" title="5.1.2集群与单机"></a>5.1.2集群与单机</h3><p><code>ZooKeeper</code>有两种运行模式:<code>集群模式</code>和<code>单机模式</code>。涉及的部署与配置操作都是针对GNU&#x2F;Linux系统的。</p>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a><font color=camel>集群模式</font></h4><ol>
<li>zookeeper安装<br>下载网站： <a target="_blank" rel="noopener" href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong opt]<span class="comment"># wget https://downloads.apache.org/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz</span></span><br><span class="line">--2021-07-01 16:47:48--  https://downloads.apache.org/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz</span><br><span class="line">Resolving downloads.apache.org (downloads.apache.org)... 135.181.214.104, 88.99.95.219, 135.181.209.10, ...</span><br><span class="line">Connecting to downloads.apache.org (downloads.apache.org)|135.181.214.104|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 9623007 (9.2M) [application/x-gzip]</span><br><span class="line">Saving to: ‘apache-zookeeper-3.5.9-bin.tar.gz’</span><br><span class="line"></span><br><span class="line">100%[===========================================================================&gt;] 9,623,007   7.57KB/s   <span class="keyword">in</span> 22m 35s</span><br><span class="line"></span><br><span class="line">2021-07-01 17:10:25 (6.93 KB/s) - ‘apache-zookeeper-3.5.9-bin.tar.gz’ saved [9623007/9623007]</span><br><span class="line"></span><br><span class="line">[root@liruilong opt]<span class="comment"># ls</span></span><br><span class="line">apache-zookeeper-3.5.9-bin.tar.gz</span><br><span class="line">[root@liruilong opt]<span class="comment"># </span></span><br><span class="line">[root@liruilong opt]<span class="comment"># mkdir zookeeper-3.5.9</span></span><br><span class="line">[root@liruilong opt]<span class="comment"># tar -xf apache-zookeeper-3.5.9-bin.tar.gz  -C ./zookeeper-3.5.9/</span></span><br><span class="line">[root@liruilong opt]<span class="comment"># cd zookeeper-3.5.9/</span></span><br><span class="line">[root@liruilong zookeeper-3.5.9]<span class="comment"># ls</span></span><br><span class="line">apache-zookeeper-3.5.9-bin</span><br><span class="line">[root@liruilong zookeeper-3.5.9]<span class="comment"># </span></span><br><span class="line">[root@liruilong zookeeper-3.5.9]<span class="comment"># ls</span></span><br><span class="line">apache-zookeeper-3.5.9-bin</span><br><span class="line">[root@liruilong zookeeper-3.5.9]<span class="comment"># cd apache-zookeeper-3.5.9-bin/</span></span><br><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># ls</span></span><br><span class="line">bin  conf  docs  lib  LICENSE.txt  NOTICE.txt  README.md  README_packaging.txt</span><br><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># ls -l</span></span><br><span class="line">total 40</span><br><span class="line">drwxr-xr-x 2  502 games  4096 Jan  7 02:56 bin</span><br><span class="line">drwxr-xr-x 2  502 games  4096 Jan  7 02:56 conf</span><br><span class="line">drwxr-xr-x 5  502 games  4096 Jan  7 03:48 docs</span><br><span class="line">drwxr-xr-x 2 root root   4096 Jul  1 19:12 lib</span><br><span class="line">-rw-r--r-- 1  502 games 11358 Oct  5  2020 LICENSE.txt</span><br><span class="line">-rw-r--r-- 1  502 games   432 Jan  7 00:12 NOTICE.txt</span><br><span class="line">-rw-r--r-- 1  502 games  1560 Jan  7 02:56 README.md</span><br><span class="line">-rw-r--r-- 1  502 games  1347 Jan  7 02:56 README_packaging.txt</span><br><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>配置配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># ls conf/</span></span><br><span class="line">configuration.xsl  log4j.properties  zoo_sample.cfg</span><br><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># cp ./conf/zoo_sample.cfg  ./conf/zoo.cfg</span></span><br><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># ls conf/</span></span><br><span class="line">configuration.xsl  log4j.properties  zoo.cfg  zoo_sample.cfg</span><br><span class="line">[root@liruilong apache-zookeeper-3.5.9-bin]<span class="comment"># vim ./conf/zoo.cfg </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
初次使用<code>ZooKeeper</code>,需要将<code>%ZK-HOME%conf</code>目录下的<code>zoo-sample.cfg</code>文件重命名为<code>zoo.cfg</code>,并且按照如下代码进行简单配置即可:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=IP1: 2888:3888</span><br><span class="line">server.2=IP2: 2888:3888</span><br><span class="line">server.3-IP3: 2888:3888</span><br></pre></td></tr></table></figure>
在<code>集群模式</code>下,集群中的<code>每台机器都需要感知到整个集群</code>是由哪几台机器组成的,在配置文件中,可以按照这样的格式进行配置,每一行都代表一个机器配置:<br><code>server.id-host:port:port</code>其中,id被称为<code>Server ID</code>,用来标识该机器在<code>集群中的机器序号</code>。同时,在每台ZooKeeper机器上,我们都需要在<code>数据目录</code>(即<code>dataDir</code>参数指定的那个目录)下创建一个<code>myid</code>文件,该文件只有一行内容,并且是一个数字,即对应于每台机器的<code>Server ID</code>数字。在ZooKeeper的设计中,<font color=purple>集群中所有机器</font>上<code>zoo.cfg</code>文件的内容都应该是一致内。</li>
</ol>
<p><font color=green>myid文件中只有一个数字</font>,即一个<code>Server ID</code>,例如, <code>server.1的myid文件内容就是“1” </code>。注意,请确保每个服务器的myid文件中的数字不同,并且和自己所在机器的<code>zoo.cfg</code>中<code>server.id-host:port: port</code>的d值一致。另外, <code>id</code>的范围是<code>1-255</code></p>
<ol start="4">
<li>创建 myid文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># touch /tmp/zookeeper/myid ;echo &quot;1&quot;  &gt; myid</span></span><br><span class="line">```  </span><br><span class="line">5. 按照相同的步骤,为其他机器都配置上zoo.cfg和myid文件。</span><br><span class="line">6. 启动服务器。 `zkServer.sh`脚本进行服务器的启动</span><br><span class="line">```bash</span><br><span class="line">[root@liruilong bin]<span class="comment"># sh zkServer.sh start</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... already running as process 6580.</span><br><span class="line">[root@liruilong bin]<span class="comment"># </span></span><br></pre></td></tr></table></figure></li>
<li>验证服务器。启动完成后,可以使用如下命令来检查服务器启动是否正常:<code>$telnet 127.0.0.1 2181</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong bin]<span class="comment"># telnet 127.0.0.1 2181</span></span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line"><span class="built_in">stat</span></span><br><span class="line"><span class="built_in">stat</span> is not executed because it is not <span class="keyword">in</span> the whitelist.</span><br><span class="line">Connection closed by foreign host.</span><br><span class="line">[root@liruilong bin]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>报错了，指令不在白名单里，百度解决一下 : 修改启动指令 zkServer.sh ，往里面添加 ：<code>ZOOMAIN=&quot;-Dzookeeper.4lw.commands.whitelist=* $&#123;ZOOMAIN&#125;&quot;</code>  #L77</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"> 66     <span class="keyword">fi</span></span><br><span class="line"> 67     <span class="built_in">echo</span> <span class="string">&quot;ZooKeeper remote JMX Port set to <span class="variable">$JMXPORT</span>&quot;</span> &gt;&amp;2</span><br><span class="line"> 68     <span class="built_in">echo</span> <span class="string">&quot;ZooKeeper remote JMX authenticate set to <span class="variable">$JMXAUTH</span>&quot;</span> &gt;&amp;2</span><br><span class="line"> 69     <span class="built_in">echo</span> <span class="string">&quot;ZooKeeper remote JMX ssl set to <span class="variable">$JMXSSL</span>&quot;</span> &gt;&amp;2</span><br><span class="line"> 70     <span class="built_in">echo</span> <span class="string">&quot;ZooKeeper remote JMX log4j set to <span class="variable">$JMXLOG4J</span>&quot;</span> &gt;&amp;2</span><br><span class="line"> 71     ZOOMAIN=<span class="string">&quot;-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=<span class="variable">$JMXPORT</span> -Dcom    .sun.management.jmxremote.authenticate=<span class="variable">$JMXAUTH</span> -Dcom.sun.management.jmxremote.ssl=<span class="variable">$JMXSSL</span> -Dz    ookeeper.jmx.log4j.disable=<span class="variable">$JMXLOG4J</span> org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span></span><br><span class="line"> 72   <span class="keyword">fi</span></span><br><span class="line"> 73 <span class="keyword">else</span></span><br><span class="line"> 74     <span class="built_in">echo</span> <span class="string">&quot;JMX disabled by user request&quot;</span> &gt;&amp;2</span><br><span class="line"> 75     ZOOMAIN=<span class="string">&quot;org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span></span><br><span class="line"> 76 <span class="keyword">fi</span></span><br><span class="line"> 77 ZOOMMAIN=<span class="string">&quot;-Dzookeeper.4lw.commands.whitelist=* <span class="variable">$&#123;ZOOMAIN&#125;</span>&quot;</span></span><br><span class="line"> 78 <span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$SERVER_JVMFLAGS</span>&quot;</span> != <span class="string">&quot;x&quot;</span> ]</span><br><span class="line"> 79 <span class="keyword">then</span></span><br><span class="line"> 80     JVMFLAGS=<span class="string">&quot;<span class="variable">$SERVER_JVMFLAGS</span> <span class="variable">$JVMFLAGS</span>&quot;</span></span><br><span class="line"> 81 <span class="keyword">fi</span></span><br><span class="line">................</span><br></pre></td></tr></table></figure>
<p>在试一下，这里需要 <strong><font color=plum>注意的是 服务先stop 然后在start，因为没有restart命令。</font></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong bin]<span class="comment"># sh zkServer.sh start</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">[root@liruilong bin]<span class="comment"># telnet 127.0.0.1 2181</span></span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line"><span class="built_in">stat</span></span><br><span class="line">Zookeeper version: 3.5.9-83df9301aa5c2a5d284a9940177808c01bc35cef, built on 01/06/2021 19:49 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /127.0.0.1:42942[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/0</span><br><span class="line">Received: 1</span><br><span class="line">Sent: 0</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x0</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 5</span><br><span class="line">Connection closed by foreign host.</span><br><span class="line">[root@liruilong bin]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>服务正常启动了。嗯，这个是单机版的，阿里云上搞得，笔记本内存太小，多跑机器卡的不行，所以集群不试了。</p>
<h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a><font color=blue>单机模式</font></h4><p>单机模式只有一个Server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong bin]<span class="comment"># cat ../conf/zoo.cfg </span></span><br><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line">sercer.1=172.17.57.70:2888:3888</span><br><span class="line">[root@liruilong bin]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>集群模式和单机模式下输出的服务器验证信息基本一致,只有<font color=brown>Mode属性</font>不一样。<font color=red>在集群模式中, Mode显示的是leader,其实还有可能是follower,对于Leader和Follower角色的概念</font>,而在单机模式中, Mode显示的是<code>standalone</code>.</p>
<p>所谓的<code>伪集群</code>,用一句话说就是,<code>集群所有的机器都在一台机器上,但是还是以集群的特性来对外提供服务</code>。这种模式和集群模式非常类似,只是把zoo.cfg做了如下修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=IP:2888:3888 </span><br><span class="line">server.2=IP:2889:3889 </span><br><span class="line">server.3=IP:2898:3899</span><br></pre></td></tr></table></figure>
<p>嗯，这里的myid文件如何写，书里没有明确说明。百度下需要跑三个端口不同的服务。myid还是原来的写法。</p>
<h3 id="5-1-3运行服务"><a href="#5-1-3运行服务" class="headerlink" title="5.1.3运行服务"></a>5.1.3运行服务</h3><h4 id="Java命令行"><a href="#Java命令行" class="headerlink" title="Java命令行"></a><font color=amber>Java命令行</font></h4><p>这是Java语言中通常使用的方式。<font color=plum>使用Java命令来运行JAR包</font>,具体方法是在ZooKeeper 发行版本的<font color=plum>%ZK HOME%</font>目录下执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -cp zookeeper-3.4.3.jar:lib/ slf4j-api-1.6. 1.jar:Lib/slf4j- log4j121.6.1.iar: lib/loq4i-1.2.15.jar:conf org.apache.zookeeper.server.quorum.QuorumPeerMain conf/zoo.cfg</span><br></pre></td></tr></table></figure>
<p>通过运行上面这个命令, <font color=royalblue>ZooKeeper的主入口QuorumPeerMain类就会启动ZooKeeper服务器,</font>同时,随着ZooKeeper服务的启动,其内部的JMX也会被启动,方便管理员在JMX管理控制台上进行一些对ZooKeeper的监控与操作。</p>
<h4 id="使用ZooKeeper自带的启动脚本来启动ZooKeeper"><a href="#使用ZooKeeper自带的启动脚本来启动ZooKeeper" class="headerlink" title="使用ZooKeeper自带的启动脚本来启动ZooKeeper"></a><font color=tomato>使用ZooKeeper自带的启动脚本来启动ZooKeeper</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong bin]<span class="comment"># ls | grep .sh</span></span><br><span class="line">zkCleanup.sh  <span class="comment">#清理ZooKeeper历史数据,包括事务日志文件和快照数据文件</span></span><br><span class="line">zkCli.sh <span class="comment">#ZooKeeper的一个简易客户端</span></span><br><span class="line">zkEnv.sh <span class="comment">#设置ZooKeeper的环境变量</span></span><br><span class="line">zkServer-initialize.sh</span><br><span class="line">zkServer.sh    <span class="comment">#ZooKeeper服务器的启动,停止和重启脚本</span></span><br><span class="line">zkTxnLogToolkit.sh</span><br><span class="line">[root@liruilong bin]<span class="comment"># ls | grep .cmd</span></span><br><span class="line">zkCli.cmd</span><br><span class="line">zkEnv.cmd</span><br><span class="line">zkServer.cmd</span><br><span class="line">zkTxnLogToolkit.cmd</span><br><span class="line">[root@liruilong bin]<span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a><font color=purple>常见异常</font></h4><p>在启动的时候，通常会碰到一些异常,下面将对这些常见的异常进行讲解。</p>
<ul>
<li><font color=seagreen>端口被占用</font>在启动ZooKeeper的时候,可能出现如下“端口被占用”的异常,导致服务器无法正常启动:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.BindException: Address already in use</span><br></pre></td></tr></table></figure></li>
<li><font color=red>磁盘没有剩余空间</font>无论是在Zookeeper启动还是正常运行过程中,都有可能出现如下“磁盘没有剩余空间”的异常,一旦遇到这个异常, ZooKeeper会立即执行Failover策略,从而退出进程:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.IOException: No space Left on device</span><br></pre></td></tr></table></figure></li>
<li><font color=blue>无法找到myid文件</font>在数据目录下创建一个<font color=red>myid</font>文件。这里说的“<font color=plum>无法找到myid文件</font>”就是因为没有找到这个配置文件而导致的如下异常:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Imain:OuorumPeerMaina851 . Invalid config, exiting abnormally</span><br></pre></td></tr></table></figure></li>
<li><font color=blue>集群中其他机器Leader选举端口未开</font>在集群模式部署下服务器逐台启动的过程中,会碰到类似于下面这样的异常:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARN [QuorumPeer[myid-<span class="number">11</span>/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">2181</span>:0uorumCnxManagera368]Cannot open channel to <span class="number">2</span> at election address /<span class="number">122.228</span><span class="number">.242</span><span class="number">.241</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-2客户端脚本"><a href="#5-2客户端脚本" class="headerlink" title="5.2客户端脚本"></a>5.2客户端脚本</h2><p>带的一些命令行工具,在本节,我们重点要看下<code>zkCli</code>这个脚本。进入<code>ZooKeeper的bin</code>目录之后,直接执行如下命令:当看到如下输出信息时,表示已经成功连接上本地的ZooKeeper服务器了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong bin]<span class="comment"># sh zkCli.sh </span></span><br><span class="line">/usr/bin/java</span><br><span class="line">Connecting to localhost:2181</span><br><span class="line">.....</span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None path:null</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] </span><br></pre></td></tr></table></figure>

<p>命令没有显式地指定<font color=seagreen>ZooKeeper服务器地址</font>,那么默认是连接<font color=green>本地的ZooKeeper服务器</font>。如果希望连接指定的ZooKeeper服务器,可以通过如下方式实现:<code>sh zkCli.sh -server ip:port</code></p>
<h3 id="5-2-1创建"><a href="#5-2-1创建" class="headerlink" title="5.2.1创建"></a>5.2.1创建</h3><p><font color=chocolate>使用create命令</font>,可以创建一个<font color=orange>ZooKeeper节点</font>。用法如下:<br><code>create [-5] [-e] path data act</code><br>其中, <font color=amber>-s或-e分别指定节点特性:顺序或临时节点</font>。默认情况下,即不添加-s或-e参数的,<font color=camel>创建的是持久节点</font>。执行完下面的命令,就在ZooKeeper的根节点下创建了一个叫作<font color=amber>&#x2F;k-book</font>的节点,并且节点的数据内容是<font color=purple>“123”</font>。另外, create命令的最后一个参数是<font color=green>acl</font>,它是用来进行权限控制的,缺省情况下,不做任何权限控制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] </span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] create /zk-book 123</span><br><span class="line">Created /zk-book</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] </span><br></pre></td></tr></table></figure>

<h3 id="5-2-2读取"><a href="#5-2-2读取" class="headerlink" title="5.2.2读取"></a>5.2.2读取</h3><p>与读取相关的命令包括<font color=royalblue>1s命令</font>和<font color=seagreen>get命令</font>。</p>
<p><strong><font color=seagreen>1s</font></strong><br>使用1s命令,可以<font color=camel>列出ZooKeeper指定节点下的所有子节点</font>。当然,这个命令只能看到指定节点下第一级的所有子节点。用法如下:<br><code>Is path [watch],</code><br>其中, <font color=green>path</font>表示的是指定数据节点的节点路径。执行如下命令:第一次部署的<code>ZooKeeper集群</code>,默认在根节点<code>“/&quot;下面有一个叫作/zookeeper的保留节点。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[zk-book, zookeeper]</span><br></pre></td></tr></table></figure>
<p>** <font color=camel>get</font>**<br>使用get命令,可以获取<font color=amber>ZooKeeper指定节点的数据内容和属性信息</font>。用法如下:<br><code>get path [watch]</code><br>执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] get /zk-book</span><br><span class="line">123</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-2-3更新"><a href="#5-2-3更新" class="headerlink" title="5.2.3更新"></a>5.2.3更新</h3><p>使用set命令,可以更新指定节点的数据内容。用法如下:<br><code>set path data [version]</code><br>其中, <font color=amber>data就是要更新的新内容</font>。注意, set命令后面还有一个<font color=green>version参数</font>,在ZooKeeper中,节点的数据是有版本概念的,这个参数用于指定本次更新操作是基于<font color=tomato>ZNode的哪一个数据版本</font>进行的。执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] <span class="built_in">set</span> /zk-book 456</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] get /zk-book</span><br><span class="line">456</span><br></pre></td></tr></table></figure>
<h3 id="5-2-4删除"><a href="#5-2-4删除" class="headerlink" title="5.2.4删除"></a>5.2.4删除</h3><p>使用delete命令,可以删除ZooKeeepr上的指定节点。用法如下:<br><code>delete path [version]</code><br>此命令中的version参数和set命令中的version参数的作用是一致的。执行如下命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] delete /zk-book</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] get /zk-book</span><br><span class="line">org.apache.zookeeper.KeeperException<span class="variable">$NoNodeException</span>: KeeperErrorCode = NoNode <span class="keyword">for</span> /zk-book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /zk-liruilong  liruilong</span><br><span class="line">Created /zk-liruilong</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] create /zk-liruilong/child 12345</span><br><span class="line">Created /zk-liruilong/child</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] delete /zk-liruilong  </span><br><span class="line">Node not empty: /zk-liruilong</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行完以上命令后,就可以把&#x2F;zk-book这个节点成功删除了。但是这里要注意的一点是,要想删除某一个指定节点,该节点必须没有子节点存在。</p>
<h2 id="5-3-Java户端AP使用"><a href="#5-3-Java户端AP使用" class="headerlink" title="5.3 Java户端AP使用"></a>5.3 Java户端AP使用</h2><p><code>ZooKeeper</code>作为一个<code>分布式服务框架</code>,主要用来解决<code>分布式数据一致性问题</code>,它提供了简单的<code>分布式原语</code>,并且对多种编程语言提供了<code>API</code>,下面我们重点来看下<code>Zookeeper的Java客户端API</code>使用方式。</p>
<h3 id="5-3-1创建会话"><a href="#5-3-1创建会话" class="headerlink" title="5.3.1创建会话"></a>5.3.1创建会话</h3><p>这里自己用SpringBoot集成了Zookeeper，代码还是书里的，只是加了一些Java8 的写法。</p>
<p>配置文件<a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/resources/application.yml">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.yml</a></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">39.97</span><span class="number">.241</span><span class="number">.18</span><span class="string">:2181</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">4000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/test/java/com/liruilong/zookeeper_demo/ZookeeperDemoApplicationTests.java#L19">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;test&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;ZookeeperDemoApplicationTests.java#L19</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZookeeperDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZookeeperDemoApplicationTests.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;zookeeper.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span>    String connectString;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;zookeeper.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;org.apache.zookeeper:zookeeper:3.5.5--创建连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(connectString,timeout,(event) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (Watcher.Event.KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">                    connectedSemaphore.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(<span class="string">&quot;初始化ZooKeeper连接异常....】=&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(<span class="string">&quot;初始化ZooKeeper连接异常....】=&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;【初始化ZooKeeper连接状态....】=&#123;&#125;&quot;</span>,zooKeeper.getState());</span><br><span class="line"></span><br><span class="line">        Arrays.stream(ZooKeeper.class.getConstructors()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Zookeeper构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, ZKClientConfig)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">boolean</span>)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">boolean</span>, ZKClientConfig)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">boolean</span>, HostProvider)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">boolean</span>, HostProvider, ZKClientConfig)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[])</span>  <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[], <span class="keyword">boolean</span>)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[], <span class="keyword">boolean</span>, HostProvider)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZooKeeper</span><span class="params">(String, <span class="keyword">int</span>, Watcher, <span class="keyword">long</span>, <span class="keyword">byte</span>[], <span class="keyword">boolean</span>, HostProvider, ZKClientConfig)</span> <span class="keyword">throws</span> java.io.IOException</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210702225421382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>注意, ZooKeeper客户端和服务端会话的建立是一个异步的过程,也就是说在程序中,”构造方法会在处理完客户端初始化工作后<font color=purple>立即返回</font>,在大多数情况下,<font color=brown>此时并没有真正建立好一个可用的会话</font>,在会话的生命周期中处于”<font color=brown>CONNECTING</font>“的状态。当该<font color=royalblue>会话真正创建完毕</font>后, <font color=chocolate>Zookeeper服务端</font>会向会话对应的<font color=tomato>客户端</font>发送一个<font color=green>事件通知</font>,以告知客户端,客户端只有在获取这个通知之后,<font color=amber>才算真正建立了会话</font>。该构造方法内部实现了与ZooKeeper服务器之间的TCP连接创建,负责维护客户端会话的生命周期。</p>
<p><strong>创建一个复用<font color=orange>sessionId</font>和<font color=royalblue>sessionPasswd</font>的<font color=royalblue>ZooKeeper对象实例</font></strong></p>
<p>ZooKeeper客户端构造方法中,<code>我们看到Zookeeper构造方法允许传入sessionId和sessionPasswd</code>-客户端传入sessionId和sessionPasswd的目的是为了<code>复用会话,以维持之前会话的有效性</code>。(这<font color=plum>个输出结果和书里不一样，原因以后遇到这细究</font>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Chapter: 5.3.1 Java API -&gt; 创建连接 -&gt; 创建一个最基本的ZooKeeper对象实例，复用sessionId和</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeper_Constructor_Usage_With_SID_PASSWD</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> ZooKeeper_Constructor_Usage_With_SID_PASSWD());</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        <span class="keyword">long</span> sessionId = zookeeper.getSessionId();</span><br><span class="line">        <span class="keyword">byte</span>[] passwd  = zookeeper.getSessionPasswd();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Use illegal sessionId and sessionPassWd</span></span><br><span class="line">        zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> ZooKeeper_Constructor_Usage_With_SID_PASSWD(),<span class="comment">//</span></span><br><span class="line">				<span class="number">1l</span>,<span class="comment">//</span></span><br><span class="line">				<span class="string">&quot;test&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//Use correct sessionId and sessionPassWd</span></span><br><span class="line">        zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> ZooKeeper_Constructor_Usage_With_SID_PASSWD(),<span class="comment">//</span></span><br><span class="line">				sessionId,<span class="comment">//</span></span><br><span class="line">				passwd);</span><br><span class="line">        Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Receive watched event：&quot;</span> + event);</span><br><span class="line">        <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">            connectedSemaphore.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/ZooKeeper_Constructor_Usage_With_SID_PASSWD.java#L11">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;ZooKeeper_Constructor_Usage_With_SID_PASSWD.java#L11</a></p>
<h3 id="5-3-2创建节点"><a href="#5-3-2创建节点" class="headerlink" title="5.3.2创建节点"></a>5.3.2创建节点</h3><p>客户端可以通过ZooKeeper的API来创建一个数据节点,有如下6个接口:<br><img src="https://img-blog.csdnimg.cn/20210702224320371.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.String org.apache.zookeeper.ZooKeeper.create(java.lang.String,<span class="keyword">byte</span>[],java.util.List,org.apache.zookeeper.CreateMode) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.apache.zookeeper.ZooKeeper.create(java.lang.String,<span class="keyword">byte</span>[],java.util.List,org.apache.zookeeper.CreateMode,org.apache.zookeeper.data.Stat) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> java.lang.String org.apache.zookeeper.ZooKeeper.create(java.lang.String,<span class="keyword">byte</span>[],java.util.List,org.apache.zookeeper.CreateMode,org.apache.zookeeper.data.Stat,<span class="keyword">long</span>) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p>返回<code>String</code>的为同步创建节点，返回<code>void</code>的为异步创建节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.create(java.lang.String,<span class="keyword">byte</span>[],java.util.List,org.apache.zookeeper.CreateMode,org.apache.zookeeper.AsyncCallback$Create2Callback,java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.create(java.lang.String,<span class="keyword">byte</span>[],java.util.List,org.apache.zookeeper.CreateMode,org.apache.zookeeper.AsyncCallback$Create2Callback,java.lang.Object,<span class="keyword">long</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.create(java.lang.String,<span class="keyword">byte</span>[],java.util.List,org.apache.zookeeper.CreateMode,org.apache.zookeeper.AsyncCallback$StringCallback,java.lang.Object)</span><br><span class="line"></span><br><span class="line">+ &lt;font color=purple&gt;无论是同步还是异步接口, ZooKeeper都不支持递归创建&lt;/font&gt;,即无法在父节点不存在的情况下创建一个子节点。</span><br><span class="line">+ 如果一个节点已经存在了,那么创建同名节点的时候,会抛出&lt;font color=brown&gt;NodeExistsException异常&lt;/font&gt;</span><br><span class="line">+ ZooKeeper的节点内容只支持&lt;font color=green&gt;字节数组(<span class="keyword">byte</span>[])&lt;/font&gt;类型,也就是说,&lt;font color=red&gt; ZooKeeper不负责为节点内容进行序列化&lt;/font&gt;,开发人员需要自己使用序列化工具将节点内容进行序列化和反序列化。对于字符串,可以简单地使用<span class="string">&quot;string&quot;</span>.getBytes ()来生成一个字节数组;对于其他复杂对象,可以使用Hessian或是Kryo等专门的序列化工具来进行序列化。</span><br><span class="line">+ 关于&lt;font color=brown&gt;权限控制&lt;/font&gt;,如果你的应用场景没有太高的权限要求,那么可以不关注这个参数,只需要在acl参数中传入参数&lt;font color=brown&gt;Ids.OPEN-ACL_UNSAFE&lt;/font&gt;,这就表明之后对这个节点的任何操作都不受权限控制。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210702224551553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>使用了同步的节点创建接口</strong>:<a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/test/java/com/liruilong/zookeeper_demo/ZookeeperDemoApplicationTests.java#L153">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;test&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;ZookeeperDemoApplicationTests.java#L153</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    String path1 = zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-sync&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>.getBytes(),</span><br><span class="line">            ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">            CreateMode.EPHEMERAL);</span><br><span class="line">    System.out.println(<span class="string">&quot;Success create znode: &quot;</span> + path1);</span><br><span class="line"></span><br><span class="line">    String path2 = zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-sync&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span>.getBytes(),</span><br><span class="line">            ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">            CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">    System.out.println(<span class="string">&quot;Success create znode: &quot;</span> + path2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Success create znode: /zk-test-ephemeral-sync</span><br><span class="line">Success create znode: /zk-test-ephemeral-sync0000000005</span><br></pre></td></tr></table></figure>
<ul>
<li>使用了<font color=plum>同步的节点创建接口</font>中,我们分别创建了两种类型的节点:<code>临时节点</code>和<code>临时顺序节点</code>。</li>
<li>如果创建了<code>临时节点</code>,那么API的<code>返回值</code>就是当时传入的<code>path参数</code></li>
<li>如果创建了<code>临时顺序节点</code>,那么ZooKeeper会自动在<code>节点后缀加上一个数字</code>,并且在API接口的返回值中返回该数据节点的一个<code>完整的节点路径</code>。</li>
</ul>
<p><strong>使用异步方式创建接口</strong>:<a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/test/java/com/liruilong/zookeeper_demo/ZookeeperDemoApplicationTests.java#L126">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;test&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;ZookeeperDemoApplicationTests.java#L126</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-async&quot;</span>, <span class="string">&quot;123&quot;</span>.getBytes(),</span><br><span class="line">        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL,</span><br><span class="line">        (rc,path,ctx,name)-&gt; logger.warn(<span class="string">&quot;Create path result: [&quot;</span> + rc + <span class="string">&quot;, &quot;</span> + path + <span class="string">&quot;, &quot;</span> + ctx + <span class="string">&quot;, real path name: &quot;</span> + name)</span><br><span class="line">        , <span class="string">&quot;I am context.&quot;</span>);</span><br><span class="line"></span><br><span class="line">zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-async&quot;</span>, <span class="string">&quot;345&quot;</span>.getBytes(),</span><br><span class="line">        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL,</span><br><span class="line">        (rc,path,ctx,name)-&gt; logger.warn(<span class="string">&quot;Create path result: [&quot;</span> + rc + <span class="string">&quot;, &quot;</span> + path + <span class="string">&quot;, &quot;</span> + ctx + <span class="string">&quot;, real path name: &quot;</span> + name)</span><br><span class="line">       , <span class="string">&quot;I am context.&quot;</span>);</span><br><span class="line"></span><br><span class="line">zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-async&quot;</span>, <span class="string">&quot;456&quot;</span>.getBytes(),</span><br><span class="line">        ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL,</span><br><span class="line">        (rc,path,ctx,name)-&gt; logger.warn(<span class="string">&quot;Create path result: [&quot;</span> + rc + <span class="string">&quot;, &quot;</span> + path + <span class="string">&quot;, &quot;</span> + ctx + <span class="string">&quot;, real path name: &quot;</span> + name)</span><br><span class="line">        , <span class="string">&quot;I am context.&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Create path result: [<span class="number">0</span>, <span class="regexp">/zk-test-ephemeral-, I am context., real path name: /</span>zk-test-ephemeral-</span><br><span class="line">Create path result: [-<span class="number">110</span>, /zk-test-ephemeral-, I am context., real path name: <span class="literal">null</span></span><br><span class="line">Create path result: [<span class="number">0</span>, <span class="regexp">/zk-test-ephemeral-, I am context., real path name: /</span>zk-test-ephemeral-<span class="number">0000000003</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<font color=purple>异步方式创建接</font>口用户需要实现<code>AsyncCallback.StringCallback()</code>接口即可。<font color=tomato>AsyncCallback包含了StatCallback, Datacallback, ACLCallback, ChildrenCallbackhildren2Callback, stringCallback和VoidCalLback</font>七种不同的回调接口,用户可以在不同的异步接口中实现不同的接口。</li>
<li>和<font color=tomato>同步接口方法最大的区别在于</font>,节点的创建过程(包括网络通信和服务端的节点创建过程)是<font color=orange>异步的</font>。并且,在同步接口调用过程中,我们需要<font color=red>关注接口抛出异常的可能</font>;但是在<font color=red>异步接口中,接口本身是不会抛出异常的</font>,所有的<font color=royalblue>异常都会在回调函数中通过Result Code (响应码)来体现</font>。下面来重点看下回调方法:<code> void processResult(int rc, String path,object ctx, String name)</code>,这个方法的几个参数:</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210703001230694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-3-3删除节点"><a href="#5-3-3删除节点" class="headerlink" title="5.3.3删除节点"></a>5.3.3删除节点</h3><p>在Zookeeper中,<font color=brown>只允许删除叶子节点</font>。也就是说,<font color=camel>如果一个节点存在至少一个子节点的话,那么该节点将无法被直接删除</font>,必须先删除掉其所有子节点。</p>
<p>客户端可以通过ZooKeeper的API来删除一个节点,有如下两个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void org.apache.zookeeper.ZooKeeper.delete(java.lang.String,int,org.apache.zookeeper.AsyncCallback$VoidCallback,java.lang.Object)</span><br><span class="line">public void org.apache.zookeeper.ZooKeeper.delete(java.lang.String,int) throws java.lang.InterruptedException,org.apache.zookeeper.KeeperException</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210703001921360.png" alt="在这里插入图片描述"></p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/test/java/com/liruilong/zookeeper_demo/ZookeeperDemoApplicationTests.java#L179">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;test&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;ZookeeperDemoApplicationTests.java#L179</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String path1 = zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-sync&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>.getBytes(),</span><br><span class="line">        ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">        CreateMode.EPHEMERAL);</span><br><span class="line">System.out.println(<span class="string">&quot;Success create znode: &quot;</span> + path1);</span><br><span class="line">zookeeper.delete(path1,-<span class="number">1</span>);</span><br><span class="line">String path2 = zookeeper.create(<span class="string">&quot;/zk-test-ephemeral-sync&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>.getBytes(),</span><br><span class="line">        ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">        CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">System.out.println(<span class="string">&quot;Success create znode: &quot;</span> + path2);</span><br><span class="line">zookeeper.delete(path2,-<span class="number">1</span>);</span><br><span class="line">TimeUnit.MICROSECONDS.sleep(Integer.MAX_VALUE);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-4读取数据"><a href="#5-3-4读取数据" class="headerlink" title="5.3.4读取数据"></a>5.3.4读取数据</h3><p>读取数据,<font color=seagreen>包括子节点列表的获取和节点数据的获取</font>。Zookeeper分别提供了不同的API来获取数据。<br><img src="https://img-blog.csdnimg.cn/20210703011130630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><font color=camel>注册Watcher</font>,如果<code>ZooKeeper客户端</code>在<code>获取</code>到指定节点的子节点列表后,还需要<code>订阅</code>这个子节点列表的<code>变化通知</code>,那么就可以<code>通过注册一个Watcher来实现</code>。当有子节点被添加或是删除时,<code>服务端就会向客户端发送一个NodeChildrenChanged (EventType.NodeChildrenChanged)类型的事件通知</code>。需要注意的是,在服务端发送给客户端的事件通知中,是<code>不包含最新的节点列表</code>的,<code>客户端必须主动重新进行获取</code>。通常客户端在收到这个<code>事件通知</code>后,就可以再次<code>获取最新的子节点列表</code>了。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210703003413744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><font color=brown>stat</font>, stat对象中记录了一个节点的<code>基本属性信息</code>,例如节点创建时的<code>事务ID (cZxid)、最后一次修改的事务ID (mZxid)和节点数据内容的长度(dataLength)</code>等。有时候,我们不仅需要获取节点最新的<code>子节点列表</code>,还要获取这个节点最新的<code>节点状态信息</code>。对于这种情况,我们可以<code>将一个旧的stat变量传入API接口,该stat变量会在方法执行过程中,被来自服务端响应的新stat对象替换</code>。</li>
</ul>
<p><strong>使用同步API获取子节点列表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.util.List org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,<span class="keyword">boolean</span>,org.apache.zookeeper.data.Stat) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> java.util.List org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,org.apache.zookeeper.Watcher,org.apache.zookeeper.data.Stat) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> java.util.List org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,<span class="keyword">boolean</span>) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> java.util.List org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,org.apache.zookeeper.Watcher) <span class="keyword">throws</span> org.apache.zookeeper.KeeperException,java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/ZooKeeper_GetChildren_API_Sync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;ZooKeeper_GetChildren_API_Sync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> ZooKeeper_GetChildren_API_Sync_Usage());</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        zk.create(path, <span class="string">&quot;&quot;</span>.getBytes(), </span><br><span class="line">        		  Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        zk.create(path+<span class="string">&quot;/c1&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), </span><br><span class="line">        		  Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; childrenList = zk.getChildren(path, <span class="keyword">true</span>);</span><br><span class="line">        System.out.println(childrenList);</span><br><span class="line">        </span><br><span class="line">        zk.create(path+<span class="string">&quot;/c2&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), </span><br><span class="line">        		  Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        </span><br><span class="line">        Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">            connectedSemaphore.countDown();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ReGet Child:&quot;</span>+zk.getChildren(event.getPath(),<span class="keyword">true</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[c1]</span><br><span class="line">ReGet Child:[c1, c2]</span><br></pre></td></tr></table></figure>
<p>关于<font color=orange>Watcher</font>,ZooKeeper服务端在向客户端发送<font color=seagreen>Watcher”NodeChildrenChanged”</font>事件通知的时候,仅仅只会发出一个通知,而不会把节点的变化情况发送给客户端,需要客户端自己重新获取。另外,<font color=green>由于Watcher通知是一次性的,即一旦触发一次通知后,该Watcher就失效了,因此客户端需要反复注册Watcher.</font><br><strong>使用异步AP1获取子节点列表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,org.apache.zookeeper.Watcher,org.apache.zookeeper.AsyncCallback$ChildrenCallback,java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,<span class="keyword">boolean</span>,org.apache.zookeeper.AsyncCallback$ChildrenCallback,java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,org.apache.zookeeper.Watcher,org.apache.zookeeper.AsyncCallback$Children2Callback,java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> org.apache.zookeeper.ZooKeeper.getChildren(java.lang.String,<span class="keyword">boolean</span>,org.apache.zookeeper.AsyncCallback$Children2Callback,java.lang.Object)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/ZooKeeper_GetChildren_API_ASync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;ZooKeeper_GetChildren_API_ASync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">        zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> ZooKeeper_GetChildren_API_ASync_Usage());</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        zk.create(path, <span class="string">&quot;&quot;</span>.getBytes(), </span><br><span class="line">        		  Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        zk.create(path+<span class="string">&quot;/c1&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), </span><br><span class="line">        		  Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        </span><br><span class="line">        zk.getChildren(path, <span class="keyword">true</span>, <span class="keyword">new</span> IChildren2Callback(), <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        zk.create(path+<span class="string">&quot;/c2&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), </span><br><span class="line">      		  Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">        </span><br><span class="line">        Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">	      <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">	          connectedSemaphore.countDown();</span><br><span class="line">	      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) &#123;</span><br><span class="line">	          <span class="keyword">try</span> &#123;</span><br><span class="line">	              System.out.println(<span class="string">&quot;ReGet Child:&quot;</span>+zk.getChildren(event.getPath(),<span class="keyword">true</span>));</span><br><span class="line">	          &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IChildren2Callback</span> <span class="keyword">implements</span> <span class="title">AsyncCallback</span>.<span class="title">Children2Callback</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, List&lt;String&gt; children, Stat stat)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Get Children znode result: [response code: &quot;</span> + rc + <span class="string">&quot;, param path: &quot;</span> + path</span><br><span class="line">                + <span class="string">&quot;, ctx: &quot;</span> + ctx + <span class="string">&quot;, children list: &quot;</span> + children + <span class="string">&quot;, stat: &quot;</span> + stat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get Children znode result: [response code: <span class="number">0</span>, param path: /zk-book, <span class="attr">ctx</span>: <span class="literal">null</span>, children list: [c1], <span class="attr">stat</span>: <span class="number">141</span>,<span class="number">141</span>,<span class="number">1625245212016</span>,<span class="number">1625245212016</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">142</span></span><br><span class="line">ReGet Child:[c1, c2]</span><br></pre></td></tr></table></figure>
<h4 id="getData"><a href="#getData" class="headerlink" title="getData"></a>getData</h4><p>客户端可以通过Zookeeper的API来获取一个节点的数据内容,有如下4个接口:<br><img src="https://img-blog.csdnimg.cn/20210703012000815.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210703012631528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>getData接口和上文中的getChildren接口的用法基本相同</code><br><strong>同步方法：</strong><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/GetData_API_Sync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;GetData_API_Sync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">    	zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> GetData_API_Sync_Usage());</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        zk.create( path, <span class="string">&quot;123&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(zk.getData( path, <span class="keyword">true</span>, stat )));</span><br><span class="line">        System.out.println(stat.getCzxid()+<span class="string">&quot;,&quot;</span>+stat.getMzxid()+<span class="string">&quot;,&quot;</span>+stat.getVersion());</span><br><span class="line">        </span><br><span class="line">        zk.setData( path, <span class="string">&quot;123&quot;</span>.getBytes(), -<span class="number">1</span> );</span><br><span class="line">        </span><br><span class="line">        Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">  	      <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">  	          connectedSemaphore.countDown();</span><br><span class="line">  	      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">  	          <span class="keyword">try</span> &#123;</span><br><span class="line">  	              System.out.println(<span class="keyword">new</span> String(zk.getData( event.getPath(), <span class="keyword">true</span>, stat )));</span><br><span class="line">  	              System.out.println(stat.getCzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">  	                                 stat.getMzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">  	            		             stat.getVersion());</span><br><span class="line">  	          &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">  	      &#125;</span><br><span class="line">  	    &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">162</span>,<span class="number">162</span>,<span class="number">0</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">162</span>,<span class="number">163</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>异步方法</strong> <a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/GetData_API_ASync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;GetData_API_ASync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">    	zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;domain1.book.zookeeper:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> GetData_API_ASync_Usage());</span><br><span class="line">        connectedSemaphore.await();</span><br><span class="line">        </span><br><span class="line">        zk.create( path, <span class="string">&quot;123&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );</span><br><span class="line">        </span><br><span class="line">        zk.getData( path, <span class="keyword">true</span>, <span class="keyword">new</span> IDataCallback(), <span class="keyword">null</span> );</span><br><span class="line">        </span><br><span class="line">        zk.setData( path, <span class="string">&quot;123&quot;</span>.getBytes(), -<span class="number">1</span> );</span><br><span class="line">        </span><br><span class="line">        Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">  	      <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">  	          connectedSemaphore.countDown();</span><br><span class="line">  	      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">  	          <span class="keyword">try</span> &#123;</span><br><span class="line">  	        	zk.getData( event.getPath(), <span class="keyword">true</span>, <span class="keyword">new</span> IDataCallback(), <span class="keyword">null</span> );</span><br><span class="line">  	          &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">  	      &#125;</span><br><span class="line">  	    &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataCallback</span> <span class="keyword">implements</span> <span class="title">AsyncCallback</span>.<span class="title">DataCallback</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, <span class="keyword">byte</span>[] data, Stat stat)</span> </span>&#123;</span><br><span class="line">        System.out.println(rc + <span class="string">&quot;, &quot;</span> + path + <span class="string">&quot;, &quot;</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">        System.out.println(stat.getCzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">                  		   stat.getMzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">		                   stat.getVersion());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, /zk-book, <span class="number">123</span></span><br><span class="line"><span class="number">179</span>,<span class="number">179</span>,<span class="number">0</span></span><br><span class="line"><span class="number">0</span>, /zk-book, <span class="number">123</span></span><br><span class="line"><span class="number">179</span>,<span class="number">180</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-5更新数据"><a href="#5-3-5更新数据" class="headerlink" title="5.3.5更新数据"></a>5.3.5更新数据</h3><p>客户端可以通过ZooKeeper的API来更新一个节点的数据内容:<br><img src="https://img-blog.csdnimg.cn/20210703125626372.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210703125712845.png" alt="在这里插入图片描述"></p>
<h5 id="指定数据版本的意义："><a href="#指定数据版本的意义：" class="headerlink" title="指定数据版本的意义："></a>指定数据版本的意义：</h5><p>在讲解这个问题之前,我们首先来看下<code>CAS (Compare and Swap)</code>理论的相关知识。CAS的意思就是: “<font color=chocolate>对于值v,每次更新前都会比对其值是否是预期值A,只有符合预期,才会将V原子化地更新到新值B</font>.” ZooKeeper的setData接口中的<font color=plum>version参数正是由CAS原理衍化而来的</font>。</p>
<p>从前面的介绍中,我们已经了解到, ZooKeeper每个节点都有数据版本的概念,在调用更新操作的时候,就可以添加version这个参数,该参数可以对应于CAS原理中的“预期值”,表明是针对该数据版本进行更新的。具体来说,假如一个客户端试图进行更新操作,它会携带上次获取到的version值进行更新。而如果在这段时间内, <font color=brown>ZooKeeper服务器上该节点的数据恰好已经被其他客户端更新了,那么其数据版本一定也发生了变化,因此肯定与客户端携带的version无法匹配,于是便无法更新成功-因此可以有效地避免一些分布式更新的并发问题,</font> </p>
<p><strong>异步方法</strong><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/SetData_API_ASync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;SetData_API_ASync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">    	zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> SetData_API_ASync_Usage());</span><br><span class="line">    	connectedSemaphore.await();</span><br><span class="line"></span><br><span class="line">    	zk.create( path, <span class="string">&quot;123&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );</span><br><span class="line">    	zk.setData( path, <span class="string">&quot;456&quot;</span>.getBytes(), -<span class="number">1</span>, <span class="keyword">new</span> IStatCallback(), <span class="keyword">null</span> );</span><br><span class="line">    	</span><br><span class="line">    	Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStatCallback</span> <span class="keyword">implements</span> <span class="title">AsyncCallback</span>.<span class="title">StatCallback</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, Stat stat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>同步方法</strong><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/SetData_API_Sync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;SetData_API_Sync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">    	zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">				<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">				<span class="keyword">new</span> SetData_API_Sync_Usage());</span><br><span class="line">    	connectedSemaphore.await();</span><br><span class="line"></span><br><span class="line">        zk.create( path, <span class="string">&quot;123&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );</span><br><span class="line">        zk.getData( path, <span class="keyword">true</span>, <span class="keyword">null</span> );</span><br><span class="line">        </span><br><span class="line">        Stat stat = zk.setData( path, <span class="string">&quot;456&quot;</span>.getBytes(), -<span class="number">1</span> );</span><br><span class="line">        System.out.println(stat.getCzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">			        	   stat.getMzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">			        	   stat.getVersion());</span><br><span class="line">        Stat stat2 = zk.setData( path, <span class="string">&quot;456&quot;</span>.getBytes(), stat.getVersion() );</span><br><span class="line">        System.out.println(stat2.getCzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">	        	   		   stat2.getMzxid()+<span class="string">&quot;,&quot;</span>+</span><br><span class="line">	        	   		   stat2.getVersion());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			zk.setData( path, <span class="string">&quot;456&quot;</span>.getBytes(), stat.getVersion() );</span><br><span class="line">		&#125; <span class="keyword">catch</span> ( KeeperException e ) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Error: &quot;</span> + e.code() + <span class="string">&quot;,&quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">        Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>版本“-1”代表了什么:在ZooKeeper中,数据版本都是从0开始计数的</code>,所以严格地讲, “-1”并不是一个合法的数据版本,它仅仅是一个标识符,如果客户端传入的版本参数是“-1”,<font color=camel>就是告诉ZooKeeper服务器,客户端需要基于数据的最新版本进行更新操作</font>。如<code>果对ZooKeeper数据节点的更新操作没有原子性要求,那么就可以使用“-1”</code></p>
<h3 id="5-3-6检测节点是否存在"><a href="#5-3-6检测节点是否存在" class="headerlink" title="5.3.6检测节点是否存在"></a>5.3.6检测节点是否存在</h3><p><img src="https://img-blog.csdnimg.cn/20210703131627455.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210703131441479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/blob/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/Exist_API_Sync_Usage.java">https://gitee.com/liruilonger/zookeeper_demo&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;Exist_API_Sync_Usage.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   	String path = <span class="string">&quot;/zk-book&quot;</span>;</span><br><span class="line">   	zk = <span class="keyword">new</span> ZooKeeper(<span class="string">&quot;39.97.241.18:2181&quot;</span>,</span><br><span class="line">			<span class="number">5000</span>, <span class="comment">//</span></span><br><span class="line">			<span class="keyword">new</span> Exist_API_Sync_Usage());</span><br><span class="line">   	connectedSemaphore.await();</span><br><span class="line"></span><br><span class="line">   	zk.exists( path, <span class="keyword">true</span> );</span><br><span class="line">   	</span><br><span class="line">   	zk.create( path, <span class="string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT );</span><br><span class="line">   	</span><br><span class="line">   	zk.setData( path, <span class="string">&quot;123&quot;</span>.getBytes(), -<span class="number">1</span> );</span><br><span class="line">   	</span><br><span class="line">   	zk.create( path+<span class="string">&quot;/c1&quot;</span>, <span class="string">&quot;&quot;</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT );</span><br><span class="line">   	</span><br><span class="line">   	zk.delete( path+<span class="string">&quot;/c1&quot;</span>, -<span class="number">1</span> );</span><br><span class="line">   	</span><br><span class="line">   	zk.delete( path, -<span class="number">1</span> );</span><br><span class="line">   	</span><br><span class="line">       Thread.sleep( Integer.MAX_VALUE );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (KeeperState.SyncConnected == event.getState()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (EventType.None == event.getType() &amp;&amp; <span class="keyword">null</span> == event.getPath()) &#123;</span><br><span class="line">                   connectedSemaphore.countDown();</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EventType.NodeCreated == event.getType()) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;Node(&quot;</span> + event.getPath() + <span class="string">&quot;)Created&quot;</span>);</span><br><span class="line">                   zk.exists( event.getPath(), <span class="keyword">true</span> );</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EventType.NodeDeleted == event.getType()) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;Node(&quot;</span> + event.getPath() + <span class="string">&quot;)Deleted&quot;</span>);</span><br><span class="line">                   zk.exists( event.getPath(), <span class="keyword">true</span> );</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EventType.NodeDataChanged == event.getType()) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;Node(&quot;</span> + event.getPath() + <span class="string">&quot;)DataChanged&quot;</span>);</span><br><span class="line">                   zk.exists( event.getPath(), <span class="keyword">true</span> );</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node(/zk-book)Created</span><br><span class="line">Node(/zk-book)DataChanged</span><br></pre></td></tr></table></figure>
<h3 id="5-3-7枚限控制"><a href="#5-3-7枚限控制" class="headerlink" title="5.3.7枚限控制"></a>5.3.7枚限控制</h3><p><code>ZooKeeper</code>提供了多种权限控制模式(Scheme),分别是<code>world, auth, digest, ip和super</code>,在本节中,我们主要讲解在<code>digest</code>模式下如何进行ZooKeeper的权限控制。开发人员如果要使用Zookeeper的权限控制功能,<code>需要在完成Zookeeper会话创建后,给该会话添加上相关的权限信息(AuthInfo), </code>ZooKeeper客户端提供了相应的API接口来进行权限信息的设置,如下:<br><img src="https://img-blog.csdnimg.cn/20210703132329244.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210703132400190.png" alt="在这里插入图片描述"><br>这里书里的代码有问题，以仓库代码为准。<br>全部代碼見：<a target="_blank" rel="noopener" href="https://gitee.com/liruilonger/zookeeper_demo/tree/master/src/main/java/com/liruilong/zookeeper_demo/book_demo/auth">https://gitee.com/liruilonger/zookeeper_demo&#x2F;tree&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;liruilong&#x2F;zookeeper_demo&#x2F;book_demo&#x2F;auth</a></p>
<h2 id="5-4开源客户端"><a href="#5-4开源客户端" class="headerlink" title="5.4开源客户端"></a>5.4开源客户端</h2><h3 id="5-4-1-ZkClient"><a href="#5-4-1-ZkClient" class="headerlink" title="5.4.1 ZkClient"></a>5.4.1 ZkClient</h3><p>ZkClient是Github上一个开源的ZooKeeper客户端,是由Datameer的工程师StefanGroschupf和Peter Voss一起开发的。ZkClient在ZooKeeper原生API接口之上进行了包装,是一个更易用的ZooKeeper客户端。同时, <code>ZkClient在内部实现了诸如Session超时重连、Watcher反复注册等功能,使得ZooKeeper客户端的这些繁琐的细节工作对开发人员透明</code>。<br>這裏先不看了，以後用到在學習：</p>
<ul>
<li>仓库地址:<a target="_blank" rel="noopener" href="https://gitee.com/mirrors/zkclient">https://gitee.com/mirrors/zkclient</a></li>
<li>学习文档：<a target="_blank" rel="noopener" href="https://www.oschina.net/p/zkclient">https://www.oschina.net/p/zkclient</a></li>
</ul>
<h3 id="5-4-2-Curator"><a href="#5-4-2-Curator" class="headerlink" title="5.4.2 Curator"></a>5.4.2 Curator</h3><p>Curator是Netlix公司开源的一套ZooKeeper客户端框架,作者是Jordan Zimmermans和ZkClient一样, <code>Curator解决了很多ZooKeeper客户端非常底层的细节开发工作,包括连接重连、反复注册Watcher和NodeExistsException异常等</code>, 目前已经成为了Apache的顶级项目,是全世界范围内使用最广泛的ZooKeeper客户端之一,  <code>Curator还在ZooKeeper原生API的基础上进行了包装,提供了一套易用性和可读性更强的Fluent风格的客户端API框架。除此之外, Curator中还提供了ZooKeeper各种应用场景(Recipe,如共享锁服务、Master选举机制和分布式计数器等)的抽象封装。</code></p>
<ul>
<li>官网： <a target="_blank" rel="noopener" href="https://curator.apache.org/">https://curator.apache.org/</a></li>
</ul>
<h1 id="第6章Zookeeper的典型应用场景"><a href="#第6章Zookeeper的典型应用场景" class="headerlink" title="第6章Zookeeper的典型应用场景"></a>第6章Zookeeper的典型应用场景</h1><p>ZooKeeper是一个<font color=brown>典型的发布&#x2F;订阅模式</font>的分布式<font color=orange>数据管理与协调框架</font>,开发人员可以使用它来进行<font color=orange>分布式数据的发布与订阅</font>。</p>
<p>通过对ZooKeeper中丰富的数据节点类型进行交叉使用,配合<code>Watcher事件通知机制</code>,可以非常方便地构建一系列分布式应用中都会涉及的核心功能,如<font color=royalblue>数据发布&#x2F;订阅、负载均衡,命名服务、分布式协调&#x2F;通知、集群管理、Master选举、分布式锁和分布式队列</font>等。</p>
<h2 id="6-1-典型应用场景及实现"><a href="#6-1-典型应用场景及实现" class="headerlink" title="6.1 典型应用场景及实现"></a>6.1 典型应用场景及实现</h2><p><code>ZooKeeper</code>是一个<code>高可用的分布式数据管理与协调框架</code>。基于对<code>ZAB算法</code>的实现,该框架能够很好地<code>保证分布式环境中数据的一致性</code>。也正是基于这样的特性,使得ZooKeeper成为了解决分布式一致性问题的利器<br>。</p>
<h3 id="6-1-1数据发布-x2F-订阅"><a href="#6-1-1数据发布-x2F-订阅" class="headerlink" title="6.1.1数据发布&#x2F;订阅"></a>6.1.1数据发布&#x2F;订阅</h3><p><font color=royalblue>数据发布&#x2F;订阅(Publish&#x2F;Subscribe)系统</font>,即所谓的<code>配置中心</code>,顾名思义就是 <strong><font color=orange>发布者将数据发布到<code>ZooKeeper的一个或一系列节点上</code>,供订阅者进行数据订阅,进而达到<code>动态获取数据的目的</code>,实现配置信息的<code>集中式管理和数据的动态更新</code>。</font></strong></p>
<p><code>发布/订阅系统</code>一般有两种设计模式,分别是<code>推(Push)模式</code>和<code>拉(Pull)模式</code>。</p>
<ul>
<li>在推模式中,<font color=amber>服务端主动将数据更新发送给所有订阅的客户端</font>,</li>
<li>拉模式则是由<font color=chocolate>客户端主动发起请求来获取最新数据,通常客户端都采用定时进行轮询拉取的方式</font>。</li>
</ul>
<p><code>ZooKeeper</code>采用的是<font color=brown>推拉相结合</font>的方式:</p>
<p>客户端向服务端注册自己需要关注的节点,一旦该<font color=orange>节点的数据发生变更</font>,那么服务端就会向相应的客户端发送<font color=yellowgreen>Watcher事件通知</font>,客户端接收到这个消息通知之后,需要主动到服务端获取最新的数据。如果将<font color=yellowgreen>配置信息</font>存放到ZooKeeper上进行集中管理,那么通常情况下,应用在<font color=purple>启动</font>的时候都会<font color=royalblue>主动到ZooKeeper服务端</font>上进行一次<font color=green>配置信息的获取</font>,同时,在指定节点上<font color=camel>注册一个<code>Watcher</code>监听</font>,这样一来,但凡<font color=blue>配置信息发生变更</font>,服务端都会实时<font color=plum>通知到所有订阅的客户端</font>,从而达到实时获取最新配置信息的目的。</p>
<h4 id="配置管理的实际案例："><a href="#配置管理的实际案例：" class="headerlink" title="配置管理的实际案例："></a>配置管理的实际案例：</h4><p>展示<code>ZooKeeper</code>在<code>“数据发布/订阅”</code>场景下的使用方式。在我们平常的应用系统开发中,经常会碰到这样的需求:系统中需要使用一些通用的配置信息,例如<code>机器列表信息、运行时的开关配置、数据库配置信息</code>等。这些<code>全局配置信息通常具备以下3个特性。</code></p>
<table>
<thead>
<tr>
<th>全局配置信息通常具备以下3个特性</th>
</tr>
</thead>
<tbody><tr>
<td>数据量通常比较小。</td>
</tr>
<tr>
<td>数据内容在运行时会发生动态变化。</td>
</tr>
<tr>
<td>集群中各机器共享,配置一致。</td>
</tr>
</tbody></table>
<p>对于这类配置信息,一般的做法通常可以选择将其存储在本地配置文件或是内存变量中。</p>
<table>
<thead>
<tr>
<th>配置信息存储位置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>本地配置文件</td>
<td>如果采用本地配置文件的方式,那么通常系统可以在应用启动的时候读取到本地磁盘的一个文件来进行初始化.</td>
</tr>
<tr>
<td>内存变量</td>
<td>借助内存变量来实现配置管理的方式也非常简单,以Java系统为例,通常可以采用JMX方式来实现对系统运行时内存变量的更新</td>
</tr>
</tbody></table>
<p>接下去我们就以一个“<font color=camel>数据库切换”</font>的应用场景展开,看看如何<font color=tomato>使用Zookeeper来实现配置管理</font>。<br><img src="https://img-blog.csdnimg.cn/20210703111009104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=amber>配置存储</font>:</td>
<td>在进行配置管理之前,首先我们需要将初始化配置存储到ZooKeeper上去。一般情,况下,我们可以在Zookeeper上选取一个数据节点用于配置的存储.</td>
</tr>
<tr>
<td><font color=amber>配置获取</font>:</td>
<td>集群中每台机器在<code>启动初始化阶段</code>,首先会从上面提到的<code>ZooKeeper配置节点上读取数据库信息</code>,同时,<code>客户端还需要在该配置节点上注册一个数据变更的Watcher监听</code>,一旦发生节点数据变更,所有订阅的客户端都能够获取到数据变更通知。</td>
</tr>
<tr>
<td><font color=seagreen>配置变更</font>：</td>
<td>在系统运行过程中,可能会出现需要进行数据库切换的情况,这个时候就需要进行配置变更。借助ZooKeeper,我们只需要<code>对ZooKeeper上配置节点的内容进行更新,ZooKeeper就能够帮我们将数据变更的通知发送到各个客户端</code>,每个客户端在接收到这个变更通知后,就可以重新进行最新数据的获取。</td>
</tr>
</tbody></table>
<h3 id="6-1-2负载均衡"><a href="#6-1-2负载均衡" class="headerlink" title="6.1.2负载均衡"></a>6.1.2负载均衡</h3><p>负载均衡可以分为<font color=purple>硬件和软件负载均衡</font>两类,Zookeeper在“软”负载均衡中的应用场景</p>
<p>分布式系统具有<code>对等性</code>,为了保证系统的<code>高可用性</code>,通常采用副本的方式来对<code>数据和服务进行部署</code>。而对于<code>服务消费者</code>而言,则需要在这些对等的服务提供方中选择一个来执行相关的业务逻辑,其中此较典型的就是<font color=red>DNS服务</font>。</p>
<p>通常情况下,我们可以向域名注册服务商申请域名注册,但是这种方式最大的缺陷在于<code>只能注册有限的域名</code>:</p>
<p>因此,在实际开发中,往往使用本地HOST绑定来实现域名解析的工作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@liruilong ~]<span class="comment"># more  /etc/hosts</span></span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">[root@liruilong ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>缺点:我们在应用上线的时候,需要在应用的<code>每台机器上去绑定域名</code>,但是在机器规模相当庞大的情况下,这种做法就相当不方便。另外,如果想要<code>临时更新城名,还需要到每个机器上去逐个进行变更</code>,要消耗大量时间,因此完全无法保证实时性。其实可以使用Ansible等运自动化维工具解决。</p>
<p><font color=camel>基于ZooKeeper实现的动态DNS方案(以下简称该方案为”DDNS” , Dynamic DNS)。</font><br><img src="https://img-blog.csdnimg.cn/20210703111346141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=plum>域名配置</font></td>
<td>和配置管理一样,我们首先需要在ZooKeeper上创建一个节点来进行域名配置</td>
</tr>
<tr>
<td><font color=yellowgreen>域名解析</font></td>
<td>DDNS方案和传统的域名解析有很大的区别–<font color=orange>在DDNS中,域名的解析过程都是由每一个应用自己负责的</font>。通常应用都会首先<code>从域名节点中获取一份IP地址和端口的配置</code>,进行自行解析。同时,每个<code>应用还会在域名节点上注册一个数据变更Watcher监听</code>,以便及时收到<code>域名变更的通知</code>。</td>
</tr>
<tr>
<td><font color=blue>域名变更</font></td>
<td>在DDNS中,我们只需要<code>对指定的域名节点进行更新操作</code>, ZooKeeper就会向订阅的客户端发送这个<code>事件通知</code>,应用在接收到这个事件通知后,就会再次进行<code>域名配置的获取</code>。</td>
</tr>
</tbody></table>
<p>通过<code>ZooKeeper</code>来实现动态<code>DNS</code>服务：</p>
<ul>
<li>可以避免域名数量无限增长带来的<code>集中式维护</code>的成本;</li>
<li>在<code>域名变更</code>的情况下,也能够避免<code>因逐台机器更新本地HOST</code>而带来的繁琐工作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210703114053619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhbmhld3V5YW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>首先来介绍整个<code>动态DNS系统</code>的架构体系中几个比较重要的组件及其职责。</p>
<ul>
<li><code>Register</code>集群负责域名的<font color=amber>动态注册</font>。</li>
<li><code>Dispatcher</code>集群负责<font color=royalblue>域名解析</font>。</li>
<li><code>Seanner</code>集群负责<font color=green>检测以及维护服务状态</font>(探测服务的可用性、屏蔽异常服务节点等)。</li>
<li><code>SDK</code>提供各种语言的<font color=camel>系统接入协议,提供服务注册以及查询接口</font>。</li>
<li><code>Monitor</code>负责收集服务信息以及对<font color=brown>DDNS自身状态的监控</font>。</li>
<li><code>ontroller</code>是一个<font color=tomato>后台管理的Console</font>,负责授权管理、流量控制、静态配置服务和手动屏蔽服务等功能,另外,系统的运维人员也可以在上面管理RegisterDispatcher和Scanner等集群。</li>
</ul>
<p>整个系统的核心当然是ZooKeeper集群,负责数据的存储以及一系列分布式协调。下面我们再来详细地看下整个系统是如何运行的。在这个架构模型中,<font color=purple>我们将那些目标IP地址和端口抽象为服务的<code>提供者</code>,而那些需要使用域名解析的客户端则被抽象成服务的<code>消费者</code>。</font></p>
<h5 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a><font color=royalblue>域名注册</font></h5><p>域名注册主要是针<code>对服务提供者</code>来说的。域名注册过程可以简单地概括为:<code>每个服务提供者在启动的过程中,都会把自己的域名信息注册到Register集群中去。</code></p>
<ol>
<li>服务提供者通过SDK提供的API接口,将域名、IP地址和端口发送给Register<br>集群。例如, A机器用于提供serviceA.xxx.com,于是它就向Register发送一个“域名-&gt;IP:PORT”的映射: “serviceA.xx.com-192.168.0.1:8080”</li>
<li>Register获取到域名、IP地址和端口配置后,根据城名将信息写入相对应的Zookeeper域名节点中。</li>
</ol>
<h5 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a><font color=brown>域名解析</font></h5><p>域名解析是针对<code>服务消费者</code>来说的,正好<code>和域名注册过程相反</code>:<code>服务消费者在使用域名的时候,会向Dispatcher发出域名解析请求。Dispatcher收到请求后,会从ZooKeeper上的指定域名节点读取相应的1P:PORT列表</code>,通过一定的策略选取其中一个返回给前端应用。</p>
<h5 id="域名探测"><a href="#域名探测" class="headerlink" title="域名探测"></a><font color=royalblue>域名探测</font></h5><p>域名探测是指DDNS系统需要对域名下所有注册的IP地址和端口的可用性进行检测,俗称“<code>健康度检测</code>”。健康度检测一般有两种方式,</p>
<ul>
<li>第一种是<code>服务端主动发起健康度心跳检测</code>,这种方式一般需要在服务端和客户端之间建立起一个TCP长链接;</li>
<li>第二种则是<code>客户端主动向服务端发起健康度心跳检测</code>。在DDNS架构中的域名探测,使用的是<code>服务提供者主动向Scanner进行状态汇报(即第二种健康度检测方式)的模式</code>,即每个服务提供者都会定时向Scanner汇报自己的状态。Scanner会负责记录每个服务提供者最近一次的状态汇报时间,<code>一旦超过5秒没有收到状态汇报</code>,那么就认为该<code>IP地址和端口已经不可用,于是开始进行域名清理过程</code>。在域名清理过程中, <code>Scanner会在ZooKeeper中找到该域名对应的域名节点,然后将该IP地址和端口配置从节点内容中移除。</code></li>
</ul>
<h3 id="6-1-3命名服务"><a href="#6-1-3命名服务" class="headerlink" title="6.1.3命名服务"></a>6.1.3命名服务</h3><p><code>Java语言中的JNDI</code>便是一种典型的命名服务。JNDI是Java命名与目录接口(JavaNaming and Directory Interface)的缩写,是J2EE体系中重要的规范之一,标准的J2EE容器都提供了对JNDI规范的实现。</p>
<p><code>Zookeeper提供的命名服务功能与JNDI技术有相似的地方</code>,都能够帮助应用系统通过一个资源引用的方式来实现对资源的定位与使用。另外,广义上命名服务的资源定位都不是真正意义的实体资源-在分布式环境中,<code>上层应用仅仅需要一个全局唯一的名字,类似于数据库中的唯一主键。</code>下面我们来看看如何使用ZooKeeper来实现一套<code>分布式全局唯一ID的分配机制</code>。</p>
<p><code>一说起全局唯一ID,相信读者都会联想到UUID</code>, UUID是通用唯一识别码(Universally Unique Identifier)的简称,是一种在分布式系统中广泛使用的用于唯一标识元素的标准,最典型的实现是GUID (Globally Unique Identifier,全局唯一标识符),缺点：</p>
<ul>
<li><font color=seagreen>长度过长</font>：UUID最大的问题就在于生成的字符串过长。显然,和数据库中的INT类型相比,存储一个UUID需要花费更多的空间。</li>
<li><font color=purple>含义不明</font>：一个典型的UUID是类似于”e70f1357-f260-46ff-a32d53a086c57ade”的一个字符串。</li>
</ul>
<p>一个分布式任务调度系统来看看如何使用 <strong><font color=green>ZooKeeper来实现这类全局唯一ID的生成</font>。</strong></p>
<p>通过调用<code>Zookeeper</code>节点创建的API接口可以<code>创建一个顺序节点,并且在API返回值中会返回这个节点的完整名字</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000028</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000029</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000030</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000031</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000032</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000033</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create -s -e /zk-liruilong</span><br><span class="line">Created /zk-liruilong0000000034</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] ls /</span><br><span class="line">[zk-liruilong, zk-liruilong0000000028, zk-liruilong0000000029, zk-liruilong0000000030, zk-liruilong0000000031, zk-liruilong0000000032, zk-liruilong0000000033, zk-liruilong0000000034, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-1-4分布式协调-x2F-通知"><a href="#6-1-4分布式协调-x2F-通知" class="headerlink" title="6.1.4分布式协调&#x2F;通知"></a>6.1.4分布式协调&#x2F;通知</h3><p><font color=seagreen>ZooKeeper</font>中特有的<font color=blue>Watcher注册与异步通知机制</font>,能够很好地<code>实现分布式环境下不同机器,甚至是不同系统之间的协调与通知,从而实现对数据变更的实时处理</code>。基于ZooKeeper实现分布式协调与通知功能,通常的做法是 **<font color=red><code>不同的客户端都对ZooKeeper上同一个数据节点进行Watcher注册</code>,监听数据节点的变化(包括数据节点本身及其子节点),如果数据节点发生变化,那么所有订阅的客户端都能够接收到相应的Watcher通知,并做出相应的处理</font>**。</p>
<h4 id="MySQL数据复制总线-Mysq-Replicator"><a href="#MySQL数据复制总线-Mysq-Replicator" class="headerlink" title="MySQL数据复制总线: Mysq-Replicator"></a>MySQL数据复制总线: Mysq-Replicator</h4><p>嗯，这个以后在看… :)</p>
<h3 id="6-1-5集群管理"><a href="#6-1-5集群管理" class="headerlink" title="6.1.5集群管理"></a>6.1.5集群管理</h3><p>嗯，这个以后在看… :)</p>
<h3 id="6-1-6-Master选举"><a href="#6-1-6-Master选举" class="headerlink" title="6.1.6 Master选举"></a>6.1.6 Master选举</h3><p>嗯，这个以后在看… :)</p>
<h3 id="6-1-7-分布式锁"><a href="#6-1-7-分布式锁" class="headerlink" title="6.1.7 分布式锁"></a>6.1.7 分布式锁</h3><p>分布式锁是<font color=orange>控制分布式系统之间<code>同步访问共享资源</code>的一种方式</font>。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源,那么访问这些资源的时候,往往需要通过一些<font color=seagreen>互斥手段来防止彼此之间的干扰,</font>以保证<font color=chocolate>一致性</font>,在这种情况下,就需要使用<font color=brown>分布式锁</font>了。</p>
<p>在平时的实际项目开发中,我们往往很少会去在意分布式锁,而是依赖于<code>关系型数据库固有的排他性</code>来实现不同<code>进程之间的互斥</code>。这确实是一种非常简便且被广泛使用的<code>分布式锁实现方式</code>。然而有一个不争的事实是,目前绝大多数大型分布式系统的性能瓶颈都集中在<code>数据库操作</code>上。因此,如果上层业务再给数据库添加一些额外的锁,例如<code>行锁、表锁</code>甚至是繁重的事务处理,]会让数据库更加不堪重负</p>
<p>我们来看看使用<code>ZooKeeper</code>如何实现<code>分布式锁</code>,这里主要讲解<code>排他锁</code>和<code>共享锁</code>两类分布式锁。</p>
<h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p><code>排他锁(Exclusive Locks,简称x锁)</code>,又称为<code>写锁</code>或<code>独占锁</code>,是一种基本的<code>锁类型</code>。</p>
<p>如果<code>事务T</code>,对<code>数据对象0</code>,加上了<code>排他锁</code>,那么在<code>整个加锁期间</code>,只允许<code>事务T</code>,对<code>0进行读取和更新操作</code>,其他任何事务都不能再对这个数据对象进行任何类型的操作直到<code>T释放了排他锁</code>。</p>
<p>从上面讲解的<code>排他锁</code>的基本概念中,我们可以看到,<code>排他锁</code>的<code>核心</code>是如何保证当前有且<code>仅有一个事务获得锁</code>,并且锁被释放后,所有正在等待获取锁的事务都<code>能够被通知到</code>。</p>
<h4 id="定义锁"><a href="#定义锁" class="headerlink" title="定义锁"></a>定义锁</h4><p>如何借助<code>ZooKeeper</code>实现<code>排他锁</code>。定义锁在通常的Java开发编程中,有两种常见的方式可以用来定义锁,分别是<code>synchronized机制</code>和<code>JDK5提供的ReentrantLock</code>,然而,在<code>ZooKeeper</code>中,没有类似于这样的API可以直接使用,而是通过<code>ZooKeeper</code>上的数据节点来表示一个锁,例如<code>/exclusivelock/lock</code>节点就可以被定义为一个<code>锁</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>在需要<code>获取</code>排他锁时,所有的客户端都会试图通过调用<code>create()</code>接口,在<code>lexclusive lock</code>节点下创建临时子节点<code>/exclusive lockllock</code>,在前面几节中我们也介绍了,<code>Zookeeper</code>会保证在所有的客户端中,最终只有一个<code>客户端能够创建成功</code>,那么就可以认为该<code>客户端获取了锁</code>。同时,所有<code>没有获取到锁</code>的客户端就需要到<font color=red>&#x2F;exclusivelock节点上注册一个子节点变更的<code>Watcher</code>监听</font>,以便实时<font color=chocolate>监听到lock节点的变更情况</font>。</p>
<p>在“定义锁”部分,我们已经提到, <code>/exclusivelock/lock</code> 是一个临时节点,因此在以下两种情况下,都有可能<code>释放锁</code>。</p>
<ul>
<li>当前获取锁的客户端机器发生<code>宕机</code>,那么<code>Zookeeper</code>上的这个临时节点就会被移除。</li>
<li>正常执行完业务逻辑后,客户端就会主动将自己创建的临时节点删除。</li>
</ul>
<p>无论在什么情况下移除了<code>lock</code>节点, <code>ZooKeeper</code>都会通知所有在<code>/exclusive lock</code>节点上注册了子节点变更<code>Watcher监听</code>的客户端。这些客户端在接收到通知后,再次重新发起<code>分布式锁</code>获取,即重复“获取锁”过程。整个<code>排他锁</code>的获取和释放流程,可以用图6-15来表示。 </p>
<h3 id="6-1-8-分布式队列"><a href="#6-1-8-分布式队列" class="headerlink" title="6.1.8 分布式队列"></a>6.1.8 分布式队列</h3><h2 id="6-2-ZooKeeper在大型分布式系统中的应用"><a href="#6-2-ZooKeeper在大型分布式系统中的应用" class="headerlink" title="6.2 ZooKeeper在大型分布式系统中的应用"></a>6.2 ZooKeeper在大型分布式系统中的应用</h2><h3 id="6-2-1-Hadoop"><a href="#6-2-1-Hadoop" class="headerlink" title="6.2.1 Hadoop"></a>6.2.1 Hadoop</h3><h3 id="6-2-2-HBase"><a href="#6-2-2-HBase" class="headerlink" title="6.2.2 HBase"></a>6.2.2 HBase</h3><h3 id="6-2-3-Kafka"><a href="#6-2-3-Kafka" class="headerlink" title="6.2.3 Kafka"></a>6.2.3 Kafka</h3><h2 id="6-3-ZooKeeper在阿里巴巴的实践与应用小结"><a href="#6-3-ZooKeeper在阿里巴巴的实践与应用小结" class="headerlink" title="6.3 ZooKeeper在阿里巴巴的实践与应用小结"></a>6.3 ZooKeeper在阿里巴巴的实践与应用小结</h2><h3 id="6-3-1案例一消息中间件-Metamorphosis"><a href="#6-3-1案例一消息中间件-Metamorphosis" class="headerlink" title="6.3.1案例一消息中间件: Metamorphosis"></a>6.3.1案例一消息中间件: Metamorphosis</h3><h3 id="6-3-2案例二RPC服务框架-Dubbo"><a href="#6-3-2案例二RPC服务框架-Dubbo" class="headerlink" title="6.3.2案例二RPC服务框架: Dubbo"></a>6.3.2案例二RPC服务框架: Dubbo</h3><h3 id="6-3-3案例三基于MySQL-Binlog的增量订阅和消费组件-Canal"><a href="#6-3-3案例三基于MySQL-Binlog的增量订阅和消费组件-Canal" class="headerlink" title="6.3.3案例三基于MySQL Binlog的增量订阅和消费组件:Canal"></a>6.3.3案例三基于MySQL Binlog的增量订阅和消费组件:Canal</h3><h3 id="6-3-4案例四分布式数据库同步系统-Otter"><a href="#6-3-4案例四分布式数据库同步系统-Otter" class="headerlink" title="6.3.4案例四分布式数据库同步系统: Otter"></a>6.3.4案例四分布式数据库同步系统: Otter</h3><h3 id="6-3-5案例伍轻量级分布式通用搜索平台-终搜"><a href="#6-3-5案例伍轻量级分布式通用搜索平台-终搜" class="headerlink" title="6.3.5案例伍轻量级分布式通用搜索平台:终搜"></a>6.3.5案例伍轻量级分布式通用搜索平台:终搜</h3><h3 id="6-3-6案例六实时计算引擎-JStorm"><a href="#6-3-6案例六实时计算引擎-JStorm" class="headerlink" title="6.3.6案例六实时计算引擎: JStorm"></a>6.3.6案例六实时计算引擎: JStorm</h3><h1 id="第7章Zookeeper技术内幕"><a href="#第7章Zookeeper技术内幕" class="headerlink" title="第7章Zookeeper技术内幕"></a>第7章Zookeeper技术内幕</h1><h1 id="第8章Zookeeper运维"><a href="#第8章Zookeeper运维" class="headerlink" title="第8章Zookeeper运维"></a>第8章Zookeeper运维</h1></div><div class="article-licensing box"><div class="licensing-title"><p>《从Paxos到Zookper分布式一致性原理与实践》读书笔记</p><p><a href="https://liruilongs.github.io/2021/06/30/Java/《从Paxos到Zookper分布式一致性原理与实践》读书笔记/">https://liruilongs.github.io/2021/06/30/Java/《从Paxos到Zookper分布式一致性原理与实践》读书笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-06-30</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2025/04/15/Linux-%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E9%99%90%E5%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F/" target="_blank">Linux 限制内存使用量：Linux 内存调优之限制进程、系统级别内存使用量</a><br></span><span>  3.<a class="is-size-6" href="/2022/03/11/Go/GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/" target="_blank">GO语言实战之函数与方法</a><br></span><span>  4.<a class="is-size-6" href="/2023/09/06/Go/GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B1%9E%E6%80%A7%E9%9A%90%E7%A7%81%E5%AE%9A%E4%B9%89/" target="_blank">GO语言实战之嵌入类型和属性隐私定义</a><br></span><span>  5.<a class="is-size-6" href="/2022/08/28/Go/GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%BA%8E%E6%96%B9%E6%B3%95%E9%9B%86/" target="_blank">GO语言实战之接口实现于方法集</a><br></span><span>  6.<a class="is-size-6" href="/2023/09/19/Go/GO%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%92%8C-goroutine/" target="_blank">GO语言实战之并发和 goroutine</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/01/Java/%E3%80%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《微服务架构设计模式》读书笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/06/28/web/%E4%B8%8D%E8%8A%B1%E9%92%B1%E9%9B%B6%E9%97%A8%E6%A7%9B%E3%80%8110%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BA%BF%E4%B8%8A%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/"><span class="level-item">不花钱零门槛、10分钟搭建自己的线上博客平台</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'f381f6f655b09178272310a799f16b99',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#笔记还在更新中…"><span class="mr-2">1.1.1</span><span>笔记还在更新中…..</span></a></li></ul></ul><li><a class="is-flex is-mobile" href="#第1章分布式架构"><span class="mr-2">2</span><span>第1章分布式架构</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-1从集中式到分布式"><span class="mr-2">2.1</span><span>1.1从集中式到分布式</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-1-1集中式的特点"><span class="mr-2">2.1.1</span><span>1.1.1集中式的特点</span></a></li><li><a class="is-flex is-mobile" href="#1-1-2分布式的特点"><span class="mr-2">2.1.2</span><span>1.1.2分布式的特点</span></a></li><li><a class="is-flex is-mobile" href="#三态"><span class="mr-2">2.1.3</span><span>三态</span></a></li><li><a class="is-flex is-mobile" href="#节点故障"><span class="mr-2">2.1.4</span><span>节点故障</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#1-2从ACID到CAP-x2F-BASE"><span class="mr-2">2.2</span><span>1.2从ACID到CAP/BASE</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#1-2-1-ACID"><span class="mr-2">2.2.1</span><span>1.2.1 ACID</span></a></li><li><a class="is-flex is-mobile" href="#1-2-2分布式事务"><span class="mr-2">2.2.2</span><span>1.2.2分布式事务</span></a></li><li><a class="is-flex is-mobile" href="#BASE理论"><span class="mr-2">2.2.3</span><span>BASE理论</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第2章一致性协议"><span class="mr-2">3</span><span>第2章一致性协议</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#2-1-2PC3PC"><span class="mr-2">3.1</span><span>2.1 2PC3PC</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#协议说明"><span class="mr-2">3.1.1</span><span>协议说明</span></a></li><li><a class="is-flex is-mobile" href="#阶段三-doCommit"><span class="mr-2">3.1.2</span><span>阶段三: doCommit</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#2-2-Paxos算法"><span class="mr-2">3.2</span><span>2.2 Paxos算法</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#2-2-1追本湖源"><span class="mr-2">3.2.1</span><span>2.2.1追本湖源</span></a></li><li><a class="is-flex is-mobile" href="#2-2-2-Paxos理论的诞生"><span class="mr-2">3.2.2</span><span>2.2.2 Paxos理论的诞生</span></a></li><li><a class="is-flex is-mobile" href="#2-2-3-Paxos算法详解"><span class="mr-2">3.2.3</span><span>2.2.3 Paxos算法详解</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第3章Paxos的工程实践"><span class="mr-2">4</span><span>第3章Paxos的工程实践</span></a></li><li><a class="is-flex is-mobile" href="#第4章Zookeeper与Paxos"><span class="mr-2">5</span><span>第4章Zookeeper与Paxos</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#4-1初识ZooKeeper"><span class="mr-2">5.1</span><span>4.1初识ZooKeeper</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#ZooKeeper的设计目标"><span class="mr-2">5.1.1</span><span>ZooKeeper的设计目标</span></a></li><li><a class="is-flex is-mobile" href="#4-1-2-Zookeeper从何而来"><span class="mr-2">5.1.2</span><span>4.1.2 Zookeeper从何而来</span></a></li><li><a class="is-flex is-mobile" href="#ACL"><span class="mr-2">5.1.3</span><span>ACL</span></a></li><li><a class="is-flex is-mobile" href="#4-1-4为什么选择Zookeeper"><span class="mr-2">5.1.4</span><span>4.1.4为什么选择Zookeeper</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#4-2-Zookeeper的ZAB协议"><span class="mr-2">5.2</span><span>4.2 Zookeeper的ZAB协议</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#4-2-1-ZAB协议"><span class="mr-2">5.2.1</span><span>4.2.1 ZAB协议</span></a></li><li><a class="is-flex is-mobile" href="#4-2-2协议介绍"><span class="mr-2">5.2.2</span><span>4.2.2协议介绍</span></a></li><li><a class="is-flex is-mobile" href="#4-2-3深入ZAB协议"><span class="mr-2">5.2.3</span><span>4.2.3深入ZAB协议</span></a></li><li><a class="is-flex is-mobile" href="#4-2-4-ZAB与Paxos算法的联系与区别"><span class="mr-2">5.2.4</span><span>4.2.4 ZAB与Paxos算法的联系与区别</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第5章使用Zookeeper"><span class="mr-2">6</span><span>第5章使用Zookeeper</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-1部署与运行"><span class="mr-2">6.1</span><span>5.1部署与运行</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-1-1系统环境"><span class="mr-2">6.1.1</span><span>5.1.1系统环境</span></a></li><li><a class="is-flex is-mobile" href="#单机模式"><span class="mr-2">6.1.2</span><span>单机模式</span></a></li><li><a class="is-flex is-mobile" href="#常见异常"><span class="mr-2">6.1.3</span><span>常见异常</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#5-2客户端脚本"><span class="mr-2">6.2</span><span>5.2客户端脚本</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-2-1创建"><span class="mr-2">6.2.1</span><span>5.2.1创建</span></a></li><li><a class="is-flex is-mobile" href="#5-2-2读取"><span class="mr-2">6.2.2</span><span>5.2.2读取</span></a></li><li><a class="is-flex is-mobile" href="#5-2-3更新"><span class="mr-2">6.2.3</span><span>5.2.3更新</span></a></li><li><a class="is-flex is-mobile" href="#5-2-4删除"><span class="mr-2">6.2.4</span><span>5.2.4删除</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#5-3-Java户端AP使用"><span class="mr-2">6.3</span><span>5.3 Java户端AP使用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-3-1创建会话"><span class="mr-2">6.3.1</span><span>5.3.1创建会话</span></a></li><li><a class="is-flex is-mobile" href="#5-3-2创建节点"><span class="mr-2">6.3.2</span><span>5.3.2创建节点</span></a></li><li><a class="is-flex is-mobile" href="#5-3-3删除节点"><span class="mr-2">6.3.3</span><span>5.3.3删除节点</span></a></li><li><a class="is-flex is-mobile" href="#getData"><span class="mr-2">6.3.4</span><span>getData</span></a></li><li><a class="is-flex is-mobile" href="#指定数据版本的意义："><span class="mr-2">6.3.5</span><span>指定数据版本的意义：</span></a></li><li><a class="is-flex is-mobile" href="#5-3-6检测节点是否存在"><span class="mr-2">6.3.6</span><span>5.3.6检测节点是否存在</span></a></li><li><a class="is-flex is-mobile" href="#5-3-7枚限控制"><span class="mr-2">6.3.7</span><span>5.3.7枚限控制</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#5-4开源客户端"><span class="mr-2">6.4</span><span>5.4开源客户端</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#5-4-1-ZkClient"><span class="mr-2">6.4.1</span><span>5.4.1 ZkClient</span></a></li><li><a class="is-flex is-mobile" href="#5-4-2-Curator"><span class="mr-2">6.4.2</span><span>5.4.2 Curator</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第6章Zookeeper的典型应用场景"><span class="mr-2">7</span><span>第6章Zookeeper的典型应用场景</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-1-典型应用场景及实现"><span class="mr-2">7.1</span><span>6.1 典型应用场景及实现</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#配置管理的实际案例："><span class="mr-2">7.1.1</span><span>配置管理的实际案例：</span></a></li><li><a class="is-flex is-mobile" href="#域名探测"><span class="mr-2">7.1.2</span><span>域名探测</span></a></li><li><a class="is-flex is-mobile" href="#6-1-3命名服务"><span class="mr-2">7.1.3</span><span>6.1.3命名服务</span></a></li><li><a class="is-flex is-mobile" href="#MySQL数据复制总线-Mysq-Replicator"><span class="mr-2">7.1.4</span><span>MySQL数据复制总线: Mysq-Replicator</span></a></li><li><a class="is-flex is-mobile" href="#6-1-5集群管理"><span class="mr-2">7.1.5</span><span>6.1.5集群管理</span></a></li><li><a class="is-flex is-mobile" href="#6-1-6-Master选举"><span class="mr-2">7.1.6</span><span>6.1.6 Master选举</span></a></li><li><a class="is-flex is-mobile" href="#获取锁"><span class="mr-2">7.1.7</span><span>获取锁</span></a></li><li><a class="is-flex is-mobile" href="#6-1-8-分布式队列"><span class="mr-2">7.1.8</span><span>6.1.8 分布式队列</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#6-2-ZooKeeper在大型分布式系统中的应用"><span class="mr-2">7.2</span><span>6.2 ZooKeeper在大型分布式系统中的应用</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-2-1-Hadoop"><span class="mr-2">7.2.1</span><span>6.2.1 Hadoop</span></a></li><li><a class="is-flex is-mobile" href="#6-2-2-HBase"><span class="mr-2">7.2.2</span><span>6.2.2 HBase</span></a></li><li><a class="is-flex is-mobile" href="#6-2-3-Kafka"><span class="mr-2">7.2.3</span><span>6.2.3 Kafka</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#6-3-ZooKeeper在阿里巴巴的实践与应用小结"><span class="mr-2">7.3</span><span>6.3 ZooKeeper在阿里巴巴的实践与应用小结</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#6-3-1案例一消息中间件-Metamorphosis"><span class="mr-2">7.3.1</span><span>6.3.1案例一消息中间件: Metamorphosis</span></a></li><li><a class="is-flex is-mobile" href="#6-3-2案例二RPC服务框架-Dubbo"><span class="mr-2">7.3.2</span><span>6.3.2案例二RPC服务框架: Dubbo</span></a></li><li><a class="is-flex is-mobile" href="#6-3-3案例三基于MySQL-Binlog的增量订阅和消费组件-Canal"><span class="mr-2">7.3.3</span><span>6.3.3案例三基于MySQL Binlog的增量订阅和消费组件:Canal</span></a></li><li><a class="is-flex is-mobile" href="#6-3-4案例四分布式数据库同步系统-Otter"><span class="mr-2">7.3.4</span><span>6.3.4案例四分布式数据库同步系统: Otter</span></a></li><li><a class="is-flex is-mobile" href="#6-3-5案例伍轻量级分布式通用搜索平台-终搜"><span class="mr-2">7.3.5</span><span>6.3.5案例伍轻量级分布式通用搜索平台:终搜</span></a></li><li><a class="is-flex is-mobile" href="#6-3-6案例六实时计算引擎-JStorm"><span class="mr-2">7.3.6</span><span>6.3.6案例六实时计算引擎: JStorm</span></a></li></ul></li></ul></li><li><a class="is-flex is-mobile" href="#第7章Zookeeper技术内幕"><span class="mr-2">8</span><span>第7章Zookeeper技术内幕</span></a></li><li><a class="is-flex is-mobile" href="#第8章Zookeeper运维"><span class="mr-2">9</span><span>第8章Zookeeper运维</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">440</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">144</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">191</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://mp.weixin.qq.com/s?__biz=MzkyNjIxNTYwMw==&amp;mid=2247496480&amp;idx=1&amp;sn=a9971fed3962ef2a1aeda1f0bda65f86&amp;chksm=c2380ffcf54f86eaba8daac6caca72a70f38e61a8d25dc2a66d3a17b87c02530e326dcaea14b#rd" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-15T01:51:14.000Z">2025-04-15</time></p><p class="title"><a href="/2025/04/15/Linux-%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E9%99%90%E5%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8F/">Linux 限制内存使用量：Linux 内存调优之限制进程、系统级别内存使用量</a></p><p class="categories"><a href="/categories/test3/">test3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-13T14:50:54.000Z">2025-04-13</time></p><p class="title"><a href="/2025/04/13/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%B0%B7%E6%AD%8C68%E9%A1%B5%E7%99%BD%E7%9A%AE%E4%B9%A6%E8%A7%A3%E5%AF%86%EF%BC%9A%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B%E5%A6%82%E4%BD%95%E9%87%8D%E5%A1%91AI%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91/">谷歌68页白皮书解密：提示工程如何重塑AI交互逻辑</a></p><p class="categories"><a href="/categories/LLM/">LLM</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-11T11:38:12.000Z">2025-04-11</time></p><p class="title"><a href="/2025/04/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%EF%BC%9ALinux-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%B7%B1%E5%BA%A6%E7%9B%91%E6%8E%A7/">Linux 进程内存监控：Linux 内存调优之进程内存深度监控</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-11T11:38:12.000Z">2025-04-11</time></p><p class="title"><a href="/2025/04/11/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%85%A8%E9%9D%A2%E7%9B%91%E6%8E%A7/">Linux 系统内存监控：Linux 内存调优之系统内存全面监控</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-04-07T23:32:10.000Z">2025-04-08</time></p><p class="title"><a href="/2025/04/08/%E5%BE%85%E5%8F%91%E5%B8%83/%E8%AE%A4%E8%AF%86%20Linux%20%E5%86%85%E5%AD%98%E6%9E%84%E6%88%90%EF%BC%9ALinux%20%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B9%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98/">认识 Linux 内存构成：Linux 内存调优之虚拟内存与物理内存</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AIGC/"><span class="level-start"><span class="level-item">AIGC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/BPF/"><span class="level-start"><span class="level-item">BPF</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/04/"><span class="level-start"><span class="level-item">四月 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">98</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">55</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91/"><span class="tag">华为云</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLM/"><span class="tag">LLM</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mysql/"><span class="tag">Mysql</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/BPF/"><span class="tag">BPF</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%91%84%E5%BD%B1%E6%9B%9D%E5%85%89/"><span class="tag">摄影曝光</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2025 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案中</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>