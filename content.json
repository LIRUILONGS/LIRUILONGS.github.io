{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}],"posts":[{"title":"Openstack 云计算管理平台“扫盲“ 学习笔记","text":"过自己想要的生活不是自私，要求别人按自己的意愿生活才是。 —-王尔德 写在前面 嗯，学K8S,看到这个。所以了解下。 这篇博客用于了解Openstack是什么，以及构成的基础组件。 笔记只是一些基础的东西，没有设计到Openstack基础环境配置及搭建，以后有这方面的需求，有时间在学。唉，要学的东西好多呀！**生活加油 ^ _ ^** 2021.06.15 过自己想要的生活不是自私，要求别人按自己的意愿生活才是。 —-王尔德 一、云介绍什么是云计算？对于到底什么是云计算，至少可以找到100种解释根据 美国国家标准与技术研究院（NIST）定义：云计算是一种按使用量付费的模式，这种模式提供可用、便捷、按需的网络访问，进入可配置的计算资源共享池（包括网络，服务器，存储，应用软件，服务）云服务，这些资源能够被快速提供，只需投入少量的管理工具，或与服务供应商进行很少的交互。通常涉及通过互联网来提供，动态易扩展的虚拟机的资源。 云计算的三大服务器模式 IaaS 云 Iaas（Infrastructure as a Service）(an si）,即基础设施即服务 提供给消费者的服务是对所有计算基础设施的使用 包括处理CPU、内存、存储、网络和其他基本的计算资源 用户能够部署和运行任意软件，包括操作系统和应用程序 IaaS 通常分为三种用法：公有云、私有云和混合云PaaS 云 PaaS (Platform-as-a-Service)(pa si)，意思是平台即服务 以服务器平台或者开发环境按需提供的服务 PaaS 不仅仅是单纯的基础平台，还包括对该平台的技术支持，应用系统开发、优化等服务 简单的说，PaaS也可以说是中间件即服务 例如：淘宝，京东， 只是提供了买卖双方交互的平台，卖方可以在平台上购买商铺，出售商品；买方可以到平台上选择不同的商铺购买商品（平台本身并不参与买卖过程），电商ERP等 SaaS 云 SaaS（Software-as-a-Service）(sa si)软件即服务 是一种通过 Internet 提供软件的模式 软件厂商将应用软件部署在服务器上，客户可以根据自己实际需求，通过互联网自助购买所需的应用软件服务 SaaS 云服务也可以说是一种软件云服务 #例如：苹果的APP，所有的软件都在苹果的app服务器上，用户可以根据自己的需求进行购买,或者在阿里云上租一个Mysql服务 知名云服务器商 远程控制云服务器远程控制协议 RDP (端口号3389)，适用于 Windows 服务器 步骤一：使用组合快捷键: “Win+R”组合键, 可打开“运行”对话框。步骤二：输入 “mstsc”，打开远程连接对话框。 SSH（端口号22），适用于 Linux 服务器、防火墙等设备 1234#lrzsz软件的功能，可以实现windows和linux系统直接进行文件传输#linux中的文件上传到windows系统中，格式：[root@localhost ~]# sz#windows中的文件上传到linux系统中指定目录下，先cd进入到指定目录下，然后拖拽即可[root@localhost ~]$ yum -y install lrzsz 使用 xshell 在多个终端同时执行相同的命令 第一步：选择 “查看”，选择 “撰写栏”第二步：选择图标，选择 “全部会话” 常用远程控制软件PC端：Xshell、SecureCRT、Putty等手机端：iTerminal、Termius、阿里云APP等 二、Openstack概述OpenStack 是一个由 NASA（美国国家航空航天局）和 Rackspace 合作研发并发起的项目 OpenStack 是一套 IaaS (基础云) 解决方案 OpenStack 是一个开源的云计算管理平台 以 Apache 许可证为授权Openstack 组件Openstack 结构图 组件名称 描述 Horizon组件 提供web页面环境，可以让用户注册账号，创建云主机，管理云主机； Keystone组件 为所有组件提供公共的授权和认证； Nova组件 被部署在多个节点上，提供了虚拟机的管理； Glance组件 提供了镜像的管理功能，镜像则是构成虚拟机最基础的块结构； Swift组件 对象存储组件，只有在搭建存储云的时候才会使用； Neutron组件 网络组件，为openstack提供庞大的网络管理功能【会和centos7的networkmanager冲突，需要停止或卸载掉】 Cinder组件 为openstack提供卷管理，永久存储的服务 Openstack 组件 — Horizon Horizon 组件: Horizon 为 OpenStack 服务的 Web 控制面板，它可以管理实例、镜像、创建密钥对，对实例添加卷、操作 Swift 容器等。 Horizon 具有如下一些特点： 实例管理：创建、终止实例，查看终端日志，VNC连接，添加卷等； 访问与安全管理：创建安全群组，管理密钥对，设置浮动 IP 等； 镜像管理：编辑或删除镜像 管理用户、配额及项目用 Openstack 组件 — Keystone Keystone 组件 为其他服务器提供认证和授权的集中身份管理服务 也提供了集中的目录服务 支持多种身份认证模式，如密码认证、令牌认证、以及 AWS（亚马逊web服务）登录 为用户和其他服务提供了SSO认证服务12#openstack部署完成以后，用户可以可以在openstack中创建很多台虚拟机，keystone组件可以提供对所有虚拟机的权限认证的管理服务 Openstack 组件 — Nova(镜像管理) Nova 组件 在节点上用于管理虚拟机的服务 Nova 是一个分布式的服务，能够与 Keystone 交互实现认证，与 Glance 交互实现镜像管理 Nova 被设计成在标准硬件上能够进行水平扩展,安装在多台机器。 启动实例时，如果有则需要下载镜像123#nova组件被部署在所有的节点上，用户在访问openstack要创建虚拟机时，openstack通过路由将请求发送给openstack集群中的其中一个nova节点，nova会在对应的节点上创建虚拟机，并将结果返回给用户(用户在虚拟机上进行的其他操作，也是由nova节点来完成的) Openstack 组件 — Glance Glance 组件(类似于面向对象设计模式的原型模式和享元模式的结合),镜像管理 扮演虚拟机镜像注册的角色 允许用户直接存储拷贝服务器镜像 这些镜像可以用于新建虚拟机的模板123`Glance组件` #类似于将镜像光盘上传到网络中，其他虚拟机要安装操作系统时，直接使用该镜像光盘即可，不需要重新下载【利用qcow2 —— 写时复制的技术】`COW`【copy on write】 #写时复制，例如：qcow2 Openstack 组件 — Swift Swift 组件 这是对象存储的组件 对于大部分用户来说，swift 不是必须的 你只有存储数量到一定级别，而且是非结构化数据才有这样的需求 Openstack 组件 — Neutron(网络虚拟) Neutron 组件,网络抽象。 一种软件，定义网络服务 用于创建网络、子网、路由器、管理浮动IP地址 可以实现虚拟交换机、虚拟路由器 可用于在项目中创建 VPN 1234`用户在openstack中创建多台云主机时，多台云主机可能在不同的nova节点上``例如：A,B,C三家公司，分别购买了多台云主机，这些云主机都在不同的nova节点上``对于不同公司而言，自己购买的云主机需要可以互相连通，但是又不能和其他公司的云主机连通，这些功能则由Neutron 组件可以实现` Openstack 组件 — Cinder(存储虚拟) Cinder 组件 为虚拟机管理存储卷的服务 为运行在 Nova 中的实例提供永久的块存储 可以通过快照进行数据备份 经常应用在实例存储环境中，如数据库文件 Openstack 集群集群结构 配置 yum 与 时间服务器 搭建 yum 服务器 搭建 chronyd 服务器 嗯，需要学的东西挺多的，下周估计要工作了，时间不够，还要刻几方印，还有其他的东西要看，没法实战，所以暂时不看了，有这方面的需求，有时间在学。唉，要学的东西好多呀！ ^ _ ^ 2021.06.15","link":"/2021/06/15/Openstack%20%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E2%80%9C%E6%89%AB%E7%9B%B2%E2%80%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"kubernetes(K8S) 容器管理“扫盲“ 学习笔记","text":"太多人活得不像自己。思想是别人的意见,生活是别人的模仿,情感是别人的引述。—-王尔德 写在前面 看着Activiti官网的博客教程学Activiti7，需要用这个，之前看有些运维岗需要学，所以了解一下。 笔记是看视频学的时候做的 笔记内容包含对K8S的一个基本认识。 太多人活得不像自己。思想是别人的意见,生活是别人的模仿,情感是别人的引述。—-王尔德 一、kubernetes 概述1、kubernetes 基本介绍kubernetes 是什么kubernetes，简称 K8s，是用 8 代替 8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。说白了，K8S，就是基于容器(Docker单机版)的集群管理平台,用于管理多个Docker的。Docker 非常适合在一台主机上运行容器，并为此提供所有必需的功能。但在当今的分布式服务环境中，真正的挑战是管理跨服务器和复杂基础架构的资源和工作负载。 传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。 新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署(虚拟机可以理解为硬件抽象,容器可以理解为系统抽象,共用Linux内核)，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在 build 或 release 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更“透明”，这更便于监控和管理。 Kubernetes 是 Google 开源的一个容器编排引擎Kubernetes 是 Google 开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。 2、kubernetes 功能和架构2.1 概述Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载 15 年的经验，并吸收了来自于社区的最佳想法和实践。 2.2 K8s 功能(Kubernetes 适用场景): （1）自动装箱:基于容器对应用运行环境的资源配置要求自动部署应用容器 （2）自我修复(自愈能力):当容器失败时，会对容器进行重启,当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度,当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务 （3）水平扩展:通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁 （3）服务发现:用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡 （4）滚动更新:可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新 （5）版本回退:可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退 （6）密钥和配置管理:在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。 （7）存储编排:自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务 （8）批处理:提供一次性任务，定时任务；满足批量数据处理和分析的场景 2.3 应用部署架构分类(1) 无中心节点架构： GlusterFS(2) 有中心节点架构： HDFS、K8S 2.4 k8s 集群架构 12345Pod#1》一个服务，是k8s管理的`最小单元`，k8s从 Pod中启动和管理容器；#2》由Pod来管理一组相同功能的容器；#3》一个Pod可以管理一个容器,也可以管理多个容器； 2.5 k8s 集群架构节点角色功能 Master Node:==集群主控制节点==，对集群进行调度管理，接受集群外用户去集群操作请求；Master Node 由 API server (管理接口):是整个系统的对外接口，供客户端和其他组件调用，相当于“营业厅” scheduler（调度器）:负责对集群内部的资源进行调度，相当于 “调度室” controller (控制器):负责管理控制器，相当于“大总管”。 etcd (键值对数据库):是一个键值存储仓库，存储集群的状态Worker Node:==集群工作节点==，运行用户业务应用容器；Worker Node 包含 ` docker：容器管理 kubelet：主要负责监视指派到它所在的 Pod，包括创建、修改、监控、删除等。 kube-proxy：主要负责为Pod对象提供代理 其他附加服务分布式键值存储服务Etcd 服务etcd是什么： etcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。在分布式系统中，各种服务的配置信息的管理分享，服务的发现是一个很基本同时也是很重要的问题。CoreOS 项目就希望基于 etcd 来解决这一问题。 我们使用 etcd 来存储网络配置，解决容器互联互通的问题。2.6 K8S核心概念：通过Service统一入口进行访问，Controller用于创建Pot，Pot是一组容器的集合。 Pod:最小部署单元,一组容器的集合,共享网络,生命周期是短暂的 controller：**确保预期的pod副本数量、无状态应用部署（无约定）、有状态应用部署(有特定条件)、确保所有的node运行同一个pod、一次性任务和定时任务** Service：**定义一组pod的访问规则** 搭建k8环境平台规划 服务器硬件配置要求搭建测试环境： master：2核+4G+20G node：4核+8G+40G生产环境：二、kubernetes 集群搭建(kubeadm 方式)搭建方式目前生产部署 Kubernetes 集群主要有两种方式： （1）kubeadmKubeadm 是一个 K8s 部署工具，提供kubeadm init和 kubeadm join，用于快速部署 Kubernetes 集群。官方地址 （2）二进制包从 github 下载发行版的二进制包，手动部署每个组件，组成 Kubernetes 集群。Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署 Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。 kubeadm 部署方式介绍kubeadm 是官方社区推出的一个用于快速部署 kubernetes 集群的工具，这个工具能通过两条指令完成一个 kubernetes 集群的部署： 第一、创建一个 Master 节点 kubeadm init 第二， 将 Node 节点加入到当前集群中 $ kubeadm join &lt;Master 节点的 IP 和端口 &gt; 安装要求在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件： 一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多 集群中所有机器之间网络互通 可以访问外网，需要拉取镜像 禁止 swap 分区最终目标 角色 IP k8s-master 192.168.31.61 k8s-node1 192.168.31.62 k8s-node2 192.168.31.63 6、系统初始化123456789101112131415161718192021222324252627282930313233#关闭防火墙：$ systemctl stop firewalld$ systemctl disable firewalld#关闭 selinux：$ sed -i 's/enforcing/disabled/' /etc/selinux/config # 永久$ setenforce 0 # 临时# swap：$ swapoff -a # 临时$ vim /etc/fstab # 永久# 主机名：$ hostnamectl set-hostname &lt;hostname&gt;# 在 master 添加 hosts：$ cat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.31.61 k8s-master192.168.31.62 k8s-node1192.168.31.63 k8s-node2EOF#将桥接的 IPv4 流量传递到 iptables 的链：$ cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF$ sysctl --system # 生效#时间同步：$ yum install ntpdate -y$ ntpdate time.windows.com 7、所有节点安装 Docker/kubeadm/kubeletKubernetes 默认 CRI（容器运行时）为 Docker，因此先安装 Docker。12345678910111213141516171819202122232425262728#（1）安装 Docker$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo$ yum -y install docker-ce-18.06.1.ce-3.el7$ systemctl enable docker &amp;&amp; systemctl start docker$ docker --version#（2）添加阿里云 YUM 软件源#设置仓库地址$ cat &gt; /etc/docker/daemon.json &lt;&lt; EOF{&quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]}EOF#添加 yum 源$ cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF#（3）安装 kubeadm，kubelet 和 kubectl$ yum install -y kubelet kubeadm kubectl$ systemctl enable kubelet 8、部署 Kubernetes Master1234567891011121314#（1）在 192.168.31.61（Master）执行$ kubeadm init \\--apiserver-advertise-address=192.168.31.61 \\--image-repository registry.aliyuncs.com/google_containers \\--kubernetes-version v1.17.0 \\--service-cidr=10.96.0.0/12 \\--pod-network-cidr=10.244.0.0/16#由于默认拉取镜像地址 k8s.gcr.io 国内无法访问，这里指定阿里云镜像仓库地址。#（2）使用 kubectl 工具：mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config$ kubectl get nodes 9、安装 Pod 网络插件（CNI）123$ kubectl apply –f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kubeflannel.yml#检查一下kubect1 get pods -n kube-system 确保能够访问到 quay.io 这个 registery。如果 Pod 镜像下载失败，可以改这个镜像地址 10、加入 Kubernetes Node12345#（1）在 192.168.31.62/63（Node）执行向集群添加新节点，执行在 kubeadm init 输出的 kubeadm join 命令：$ kubeadm join 192.168.31.61:6443 --token esce21.q6hetwm8si29qxwn \\--discovery-token-ca-cert-hashsha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5 11、测试 kubernetes 集群12345#在 Kubernetes 集群中创建一个 pod，验证是否正常运行：$ kubectl create deployment nginx --image=nginx$ kubectl expose deployment nginx --port=80 --type=NodePort$ kubectl get pod,svc#访问地址：http://NodeIP:Port 三、kubernetes 集群搭建(二进制方式)这个先不看 嗯，先了解到这里，以后有机会在学。","link":"/2013/07/13/kubernetes(K8S)%20%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E2%80%9C%E6%89%AB%E7%9B%B2%E2%80%9C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"程序人生之缘起","text":"傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 写在前面 看到这个活动，有奖，所以写一波，整理一下自己。 傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 毕业刚好满一年了，工作算起来有一年半的时间。编码时间要久一点，从C算起，有大概五六年了，没有刻意选择，走了这条路。可能是运气吧，叔本华说在世上存在三种力：明智、力量、运气。我相信运气至为重要。我喜欢叔本华，喜欢木心先生的《素履之往》，虽然读不太懂。感觉叔本华就像一个混子一样，吃喝不愁，言语无忌，写些让人活不下去的话。自己不痛不痒的。但是我还是喜欢他，比如他在《人生的智慧》(选至《附录和补遗》)里说礼貌的话我就很喜欢。他说 礼貌之于人就犹如温暖之于蜡。 他定义人生智慧的话我也很喜欢 人生智慧的要点之一，是在关注现在和计划将来这两者之间达到一种恰到好处的平衡，这样，现在与将来才不至于互相干扰。许多人太过沉迷于现在，这些是无忧无虑、漫不经心的人；也有的人则更多地关注将来，他们则是谨小慎微、忧心忡忡的杞人。 选择并热爱编码，可能和性格有一部分原因吧。我喜欢开源精神，喜欢做出东西，学会技术的那种成就感，满足感 。因为程序是写出来了，不是说出来，而且，编码终究是自己的事。作为开发来讲，不需要和人沟通太多，不需要面对人性晦暗的一面。我是一个对不熟悉的人很内向的人，有些厌世，有些社交恐惧。喜欢简单生活的人， 我不知道大多数程序员是什么状态，聊技术，我可是夸夸其谈，说不完的话，问不完的问题。其实懂得不多，就是感兴趣。聊生活，我可能都不愿意看别人的眼睛，感觉眼睛里更多的是经历了生活磨难的人生，我理解，但不愿意妥协。你可以说我不谙世事，或者说我没情商，不会和人相处。 我大学学的是信息与计算科学，数学系专业，有一些编程课程，但是同学大都不爱编程，所以学的同学很少，我那时也不爱学，我上大学那时就与旁人有些不一样。总觉的那般活着人生没意义，生命浪费了，放假在家里，夜晚躺着睡不着，看着月光从阳台照进来，照在墙上，就像王小波讲的那样，心里寂寞而凄凉，感到自己的生命被剥夺了。半夜2点多，我绕着县城跑了一圈，我无法承受那种生命之轻。我也不知道自己怎么办。 所以读完大一，有招兵，想去，所以家里花了点钱，我去当兵了。在部队里的两年在现在看来，是最无忧无虑的两年快乐时光，可那时却想着早些退伍。回来之后，我开始好好学习，可能在部队里好多都是第一，回来有些难受，什么都不懂，不会。之后大概就是一直好好学习，早起晚归的样子。当然和小伙伴们的努力没法子比。 人生意义吗，那时候还是迷茫，但是自己知道走着了，即使不知道想干啥，活着有啥意义，但是知道不能一步也不走坐在哪里想。班级的学习氛围不是特别好，但是那时候遇到Y，一个学哲学的台湾大学生。打开了我的眼界，对于定义自己未来有了一个大概方向。 嘻嘻，晒几张大学的早上拍的照片，就是一个楼道，其实没啥可拍的。。。哈哈 嗯，之后就是一路飘摇，去年毕业后在北京工作，期间情感上遇到了倍受打击的事，一度想离开这个世界。其实是我不懂事。索性都过去了。不能释怀又如何。从那以后，感觉生活也就那样了，可能浪漫这种东西永久的在我身上消失了。我剩下的就只剩焦虑了。曾经深以为然的那种苦难会给人带来崇高感 的感觉消失了。 今年5月份，因为要回老家考驾照处理一些其他事，时间定不下，项目又着急，而且家里希望我回去，所以离职了。那是我的第一份正式工作，自己状态一直很不好。很感谢公司的同事，在一个陌生的城市，大概也只有工作中让我时不时有一丝丝的温暖。回老家后，家里不太想让出去，所以离开北京在呼和浩特找了一份工作。谈好了准备入职，结果和我说工资申请不下来，很郁闷，我也不太喜欢这种干啥事都慢半拍的生活节奏，而且好多事太繁琐，一点都不干净利索，所以打算还去北京一次。不管未来怎么样，首先不要让自己内心过不去。 不管是我选择程序员，还是程序员选择了我，我觉得都挺好，虽然工作一年了，我离自己想的不依靠父母，自己攒首付买房，自己娶媳妇还很远，但是，我至少不用做自己不喜欢的工作，我至少可以通过大学的努力去选择一份自己满意的工作。我总认为，生活不仅仅是工作，但以我现在的能力还做不到，所以为我为之努力。我总认为在当下的年代里，《平凡的世界》里孙少平的那种诗与生活的距离是可以缩短的，因为有那么多大佬见证过。我总认为年轻人不应该读《瓦尔登湖》，因为《瓦尔登湖》中总是诉说着年轻人，希望年轻人怎么样，年轻人不应该被大众期望，应该走自己的路；应该多读读《在路上》、《月亮与六便士》之类的，去做一个年轻人，毕竟生活理想化的那些岁月终究会被无情的抹去，扼杀。剩下的大都是满眼混浊，活着慢慢的就仅仅是活着了，不是说在不疯狂就老了吗？ 与其坐以待毙，不如试着杀出一条血路。 最后想说， 人生就这样，其实大家都很忙，没人注意到你，所以，想怎么活就怎么活，如果可能，尽量让爱你的人开心一点。别的不重要。没啥事过不去的，诸多前提，首先要爱自己。生活加油 ^ _ ^ ^ _ ^ 2021年还有5个月，希望努力的小伙伴都能进大厂、发大财。$ _ $","link":"/2021/06/20/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F%E4%B9%8B%E7%BC%98%E8%B5%B7/"},{"title":"关于 MVVM和MVC的一些总结","text":"爱自己，是终生浪漫的开始 ——王尔德 我的需求： 晚上练完车之后,之前参考我毕设的一个小伙伴要答辩，问了我一个问题，结果问的一下不知道怎么回答….以下是我回答他问题的答案：所以在回答完他之后，赶快整理一波.. 我需要解决的问题： MVVM到底是个什么东东，和前后端有没有关系，它和MVC区别是啥，有啥优势。 我是这样做的： 百度寻找，找了一些关于MVVM论文，博客，梳理出自己的答案。 嗯，资源比较零散，准确性有待考量，**所以不对的地方请小伙伴指出来**。 爱自己，是终生浪漫的开始 ——王尔德 对于MVC想来小伙伴是不陌生的，但是网上的资源各抒己见….我也整的晕头转向的，可能有前(后)端,有胖(瘦)客户端框架应用，具体还有细微的差异。 If you put ten software architects into a room and have them discuss what the Model-View-Controller pattern is, you will end up with twelve different opinions. –Josh Smith[^3]如果你把10个软件架构师放在一个房间里，让他们讨论模型-视图-控制器模式是什么，你最终会得到12种不同的观点。 我们这里讨论的MVC和MVVM是以BS架构为基础的java Web中的应用，因为博主只接触了这方面的，关于网上提到的IOS和一些客户端框架，没有接触过。本博客也不涉及。所以如果听都没听过java Web的,或者没了解过 Web框架的小伙伴个人感觉这篇博客不太适合，不太建议继续读下去。 我们先看看MVVM吧！嘻嘻 ^ _ ^ MVVM 名词解释： MVVM是Model-View-ViewModel的简写。它本质上就是MVC的改进版。MVVM 就是将其中的View的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事ViewModel已经帮我们做了，它可以取出 Model 的数据同时帮忙处理View中由于需要展示内容而涉及的业务逻辑。MVVM（Model-View-ViewModel）框架的由来便是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。^1 MVVMupright=1.5 MVVM（Model–view–viewmodel）是一种软件架构模式。 MVVM有助于将图形用户界面的开发与business logic(业务逻辑)或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集(Model)的后端逻辑的访问。 ^2 MVVM 的发展历程MVVM是马丁·福勒的PM（Presentation Model）设计模式的变体。MVVM以相同的方式抽象出视图的状态和行为， 但PM以不依赖于特定用户界面平台的方式抽象出视图（建立了视图模型）。 MVVM和PM都来自MVC模式。 MVVM由微软架构师Ken Cooper和Ted Peters开发，通过利用WPF（微软.NET图形系统）和Silverlight（WPF的互联网应用衍生品）的特性来简化用户界面的事件驱动程式设计。 微软的WPF和Silverlight架构师之一John Gossman于2005年在他的博客上发表了MVVM。 MVVM也被称为model-view-binder，特别是在不涉及.NET平台的实现中。ZK（Java写的一个Web应用框架）和KnockoutJS（一个JavaScript库）使用model-view-binder。^2 MVC到MVVM 的发展历程二十世纪八十年代施乐帕克实验室提出了MVC的概念，MVC的全称即Model-View-Controller，是模型(model)一视图(view)一控制器(controller)的缩写“…，它是一种客户端软件开发框架[^4]，个人认为，其实最初的Java Web来讲，Model2 即Servlet+JSP也是用的这个结构，所以说Model2(MVC)它相对已Model1(Javabean+JSP)来讲，已经实现了View和Model的部分解耦，但是不彻底，如图 view负责显示，Model负责提供数据，Controller负责逻辑的处理，其实现的流程大概是：[^4] (1)当用户需要发送请求时，首先是在View发送请求，由View将指令传送到Controller里。 (2)Controller接收到指令之后，先完成所需要的业务逻辑，然后要求Model根据业务逻辑改变状态； (3)Model将新的数据发送给View，View则根据新的数据更新视图，从而用户的请求得到反馈。 在MVC框架中，View是可以直接访问Model的(JSP里直接使用JavaBean)，这样不可避免的使View里面也需要包括一些业务逻辑，同时还需要Model保持不变，而Model又对应着多个不同的显示(View)，所以总体说来就是，在MVC模型里面，Model不依赖View，但是View是依赖于Model的。这样就导致更改View比较困难，且业务无法重用。从而MVC框架的弊端就显现出来[^4]，这也是使用Servlet+JSP的弊端。前后端没有解耦，Model与View没有彻底解耦。 为了解决MVC框架中View和Model联系紧密的问题，开发者研究开发了MVP模式，MVP即Model-View-Presenter，即把MVC中的Controller换成了Presenter，目的就是为了完全切断View跟Model之间的联系，在MVP模式中，View负责视图的显示,Model负责提供数据，Presenter则主要负责逻辑业务的处理。[^4] 有些SSM+JSP的开发方式也是基于这种，我之前的公司就这样写，前后端不分离使用的JSP，但是交互全是Ajax，传递的全是JSON，也没有返回ModelAndView，个人感觉这里其实是使用了MVP的模式。以前后端不分离的方式丢弃模板引擎的服务端渲染，追求前后端分离中彻底解耦了View和Model。看上去怪怪的，其实有时候项目开发更多的是和业务、体量、成本、效益等有关系，综合考虑，选最合适，不一定要按照常规的构建方式考虑，比如正常思考可能不分离是为了服务端渲染，首屏快载，SEO等，分离是为了降低服务器压力，接口复用，前后端工作职责解耦. 对于SSM+模板引擎的开发方式 如何是返回Modelandview的话，那缺点就是后端路由，前后端没有彻底解耦，优点就是服务端渲染，返回的是整个构建好的页面. 如果返回JSON的话，那优点就是前后端彻底解耦，接口复用，但是没有利用模板引擎的服务端渲染。 如果体量很大，那前后端是两个人写，那使用Modelandview的方式就很麻烦，需要接口协调，而且工作职责不清晰。会浪费好多时间。JSON就方便很多。 如果体量不是他大，前端的东西也不是特别多，考虑成本问题，前后端一个人写，那Modelandview就很合适，节省了接口协调，对接等时间成本问题。 在MVP框架中，View无法直接再与Model交互，View和Model之间的通信都是通过Presenter进行完成的，所有的交互都在Presenter内部发生，即由Presenter充当了View和Model的桥梁，做到View-Model之间通信的完全隔离。Presenter完全把Model和View进行分离，将主要的程序逻辑放在Presenter里实现。[^4] **Presenter与View也是没有直接相关联的，而是通过已定义的接口进行交互**，从而使得在变更View的时候可以保持Presenter的不变，即保证了Presenter的可重用性(接口的复用性)，同时也解决了MVC框架中的View和Model关联紧密的问题。[^4] 这样之后，对于Web项目来讲，前后端都是通过数据进行交互，那路由怎么处理，前端只能实现简单一部分跳转，涉及到复杂的需要通过Controller(Presenter)来处理的路由怎么处理，或者带状态的路由如何跳转，即Controller无法控制使用那个View。个人感觉，Web系统来讲这个时候完全的前后端分离可能不是适合所有项目，而且分离之后留给前端要解决的问题可能也不是能很好的解决。所以这个时候…. 有个叫Rod Johnson 带领一帮人搞出的SpringMVC，不像桌面应用的MVC， 这里的Model没法给View 发通知。[^5]也不像MVP, 这里的Controller 可以控制View来实现路由。即前后后端没有分离，但是将原来的View的构建解耦了。由模板和数据构成： 12345678public class MyGlobalException { @ExceptionHandler(MaxUploadSizeExceededException.class) public ModelAndView customException(MaxUploadSizeExceededException e) { ModelAndView mv = new ModelAndView(&quot;javaboy&quot;); mv.addObject(&quot;error&quot;, e.getMessage()); return mv; }} 即降低了View和Model耦合，同时又实现了后端路由。对于大型项目而言，前端的东西原来越多，造成服务端的压力越来越大，而且由于MVP的出现，逐渐向前后端分离靠拢，分离之后，View分担服务端的压力，或者说是浏览器分担了服务器压力，包括页面渲染，路由等问题，这时侯MVVM出现了..（**这里是自己猜的，没找到相关资料**） MVVM框架便是前后端分离框架发展史上的一次思想的完全变革。它是将数据模型双向绑定的思想作为变革的核心，即View的变动，自动反映在ViewModel上面，而ViewModel的变动也会随即反映在View上面，从而实现数据与模型的双向绑定。[^4] 在MVVM框架中，View用于发送用户的交互请求，之后将用户请求转交给ViewModel，ViewModel即可根据用户请求操作Model数据更新，待Model数据更新完毕，便会通知ViewModel数据发生了变化，然后ViewModel就会即刻更新View数据，完成视图的更新，从而完成用户的请求。[^4] 虽然MVVM框架和之前的MVC、MVP模式的目的相同，即完成视图(View)和模型(Model)的分离，但它却有着明显的优势。[^4] 首先，MVVM框架中的View完全可以独立于Model发生变化和修改，彻底解耦，View发生变化时Model可以不变，同样，当Model发生变化时View也可以不变化，并且一个ViewModel可以绑定到多个不同的View上面，这就体现了MVVM框架的低耦合性。 其次，绑定在一个ViewModel上面的多个View都可以使用ViewModel里面的视图逻辑，完成了框架可重用性的特性。除此之外，MVVM框架还具有可独立开发、可测试等特性，把框架作用发挥到最大化，也因此成为了开发者们青睐的框架。。 对于MVVM这种模式主要用于构建基于事件驱动的 UI 平台，对于前端开发领域中数据与界面相混合的情况特别适用[^6]，其中 Model 仅仅只是代表应用程序所需的数据信息，它不关注任何行为； View 是软件中与用户进行直接交互的部分，它需要响应 ViewModel 的事件并格式化数据，不负责控制应用的状态； ViewModel 用于封装业务逻辑层，这点类似于 MVC 模式中的控制器，它控制View 的很多显示逻辑，它可以把数据模型的变化传递给视图，也可以把视图中数据的变化传递给数据模型，即在 Model 和View 之间建立了双向绑定。 Vue与MVVM我第一次看到MVVM是因为Vue，相信好多小伙伴也是Vue认识MVVM架构模式。Vue官网中讲到：**虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例**通过双向数据绑定连接视图层和数据，而实际的界面 UI 操作（DOM 操作）被封装成对应的指令（Directives）和过滤器（Filters） MVVM原理：[^7]实现数据绑定的做法有大致如下几种： 脏值检查（angular.js）: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，angular只有在指定的事件触发时进入脏值检测. DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持（vue.js）:数据劫持，指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。简单地说，就是当我们触发函数的时候 动一些手脚做点我们自己想做的事情，也就是所谓的 &quot;劫持&quot;操作 在Vue中其实就是通过Object.defineProperty来劫持对象属性的setter和getter操作，并“种下”一个监听器，当数据发生变化的时候发出通知:Object.defineProperty(obj,prop,descriptor)参数：obj:目标对象prop:需要定义的属性或方法的名称descriptor:目标属性所拥有的特性可供定义的特性列表：value:属性的值writable:如果为false，属性的值就不能被重写。get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。set:一旦目标属性被赋值，就会调回此方法。configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。 Proxy数据代理:Proxy 可以被认为是 Object.defineProperty() 的升级版。外界对某个对象的访问，都必须经过这层拦截。因此它是针对 整个对象，而不是 对象的某个属性。 12345678910111213141516171819var data = {name:'test'}Object.keys(data).forEach(function(key){ Object.defineProperty(data,key,{ enumerable:true, configurable:true, get:function(){ console.log('get'); }, set:function(newValue){ console.log('监听到数据发生了变化'); document.getElementById(‘myText’).value=newValue; } })});document.getElementById(‘myText’).addEventListener(‘keyup’,function(e){ data.name=e.target.value; // 监听 View 的变化，同步更新 Model});data.name //控制台会打印出 “get”data.name = 'hxx' //控制台会打印出 &quot;监听到数据发生了变化&quot; 1234567891011121314151617var arr = [1,2,3]var handle = { //target目标对象 key属性名 receiver实际接受的对象 get(target,key,receiver) { console.log(`get ${key}`) // Reflect相当于映射到目标对象上 return Reflect.get(target,key,receiver) }, set(target,key,value,receiver) { console.log(`set ${key}`) return Reflect.set(target,key,value,receiver) }}//arr要拦截的对象，handle定义拦截行为var proxy = new Proxy(arr,handle)proxy.push(4) //可以翻到控制台测试一下会打印出什么 发布者-订阅者模式（backbone.js）: 上述介绍了简单的一对一双向绑定的实现，即一个数据模型只与一个视图进行绑定。当多个View与一个 Model 进行绑定时，每次更新 Model 时需要在 Model 的set访问器属性中更新多个 View，这样硬编码的方式不利于后期的维护。为了解决硬编码带来的耦合性过强的问题，在在实际实现中，需要使用到设计模式中的发布 - 订阅模式。 发布 - 订阅模式（又称观察者模式）是一种常用的设计模式，该模式包含发布者和订阅者两种角色。可以让多个订阅者订阅同一个发布者发布的主题，当发布者的主题发生变化时，对外发送一个通知，所有订阅了该主题的订阅者都会接收到更新的消息。因此，观察者模式定义的是一种一对多的关系。发布 - 订阅模式非常适合于 MVVM 双向绑定中多个视图绑定到同一个数据模型的情形。 实现双向数据绑定步骤[^7]要实现mvvm的双向绑定，就必须要实现以下几点： 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者（Dep） 实现一个Watcher，Watcher是订阅 - 发布模式中订阅者的实现，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回函数 （发布），从而更新视图 MVVM入口函数，整合以上三者当新建一个 Vue 对象时，框架进入初始化阶段。Vue 在初始化阶段主要执行两个操作： 第一个是遍历系统中数据的所有属性，来对各个属性的变化添加监听； 第二个操作是利用指令编译器 Compile 对视图中绑定的指令进行扫描进行视图的初始化，然后订阅 Watcher 来更新视图，此时 Watcher 会将自己添加到消息订阅器Dep中。至此，Vue的初始化过程结束。 在系统运行过程中，一旦系统中的数据模型发生了变化，观察者 Observer 的 setter 访问器属性就会被触发，此时消息订阅中心 Dep 会遍历它所维护的所有订阅者，对于每一个订阅了该数据的对象，向它发出一个更新通知，订阅者收到通知后就会对视图进行相应的更新。以上过程不断往复循环，这就是 MVVM 模式在 Vue.js 中的运行原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Two-way data-binding&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; {{ text }} &lt;/div&gt; &lt;script&gt; function observe (obj, vm) { Object.keys(obj).forEach(function (key) { defineReactive(vm, key, obj[key]); }); } function defineReactive (obj, key, val) { var dep = new Dep(); Object.defineProperty(obj, key, { get: function () { if (Dep.target) dep.addSub(Dep.target); return val }, set: function (newVal) { if (newVal === val) return val = newVal; dep.notify(); } }); } function nodeToFragment (node, vm) { var flag = document.createDocumentFragment(); var child; while (child = node.firstChild) { compile(child, vm); flag.appendChild(child); } return flag; } function compile (node, vm) { var reg = /\\{\\{(.*)\\}\\}/; // 节点类型为元素 if (node.nodeType === 1) { var attr = node.attributes; // 解析属性 for (var i = 0; i &lt; attr.length; i++) { if (attr[i].nodeName == 'v-model') { var name = attr[i].nodeValue; // 获取v-model绑定的属性名 node.addEventListener('input', function (e) { // 给相应的data属性赋值，进而触发该属性的set方法 vm[name] = e.target.value; }); node.value = vm[name]; // 将data的值赋给该node node.removeAttribute('v-model'); } } new Watcher(vm, node, name, 'input'); } // 节点类型为text if (node.nodeType === 3) { if (reg.test(node.nodeValue)) { var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); new Watcher(vm, node, name, 'text'); } } } function Watcher (vm, node, name, nodeType) { // this为watcher函数 Dep.target = this; // console.log(this); this.name = name; this.node = node; this.vm = vm; this.nodeType = nodeType; this.update(); Dep.target = null; } Watcher.prototype = { update: function () { this.get(); if (this.nodeType == 'text') { this.node.nodeValue = this.value; } if (this.nodeType == 'input') { this.node.value = this.value; } }, // 获取daa中的属性值 get: function () { this.value = this.vm[this.name]; // 触发相应属性的get } } function Dep () { this.subs = [] } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; function Vue (options) { this.data = options.data; var data = this.data; observe(data, this); var id = options.el; var dom = nodeToFragment(document.getElementById(id), this); // 编译完成后，将dom返回到app中 document.getElementById(id).appendChild(dom); } var vm = new Vue({ el: 'app', data: { text: 'hello world' } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我的理解 **架构意义角度(Web端的角度)**：MVC和MVVM在本质上都是为了实现View和Model的解耦，MVC是通过Controller实现了View和Model的解耦，一般用与客户端，或者Web端的整个架构过程；而MVVM是在MVC发展到MVP后(为了彻底解决View和Model的耦合问题)，在提出前后端分离的基础上(考虑Coltroller的复用性，接口复用性)，对View层进行了增强(Vue.js)，或者说细化了View层的表现手法，提出了通过ViewModel对视图层的View和Model解耦。个人感觉MVVM和MVP的整体架构是有相似的地方的，不同的是面对的问题域不同，MVP是Web架构整体的解决方案，MVVM主要用于构建基于事件驱动的 UI 平台(界面)，适用于前端开发领域中数据与界面相混合的情况，所以它只专注于视图层，抽象出视图的状态和行为，实现了用户界面的UI(View)和数据(Model)的解耦。这个View和Model虽然和MVC中描述的一样，但是不相同的，可以理解为MVC中View中包含了MVVM的架构方式。一般前后端分离的Web开发中会结合MVC和MVVM两种架构模式。使用MVC构建整体的Web架构，使用MVVM解决View层DOM和data的耦合问题。 设计模式角度考虑 ：MVC是基于观察者设计模式的，Model作为一个主题，View作为观察者，当一个Model变化时，会通知更新一个或多个依赖的View，反之；MVVM可以看做是基于中介者设计模式和观察者设计模式，View和Model通过ViewModel这个中介者对象进行交互，解耦了View和Model的同时实现数据双向绑定。同时ViewModel 作为一个主题对象，View和Model为两个观察者(或者可以理解为View为主题时，Model为观察者，反之。这里的Model View起到一个注册，通知的作用，对于观察者模式的定义，ModelView是主题的行为，但实际变化的是View或者Model，**个人觉得两种理解都没问题，理解不对的请小伙伴指出来**)，当Model变化时，ViewModel由数据绑定通知并更新与之相关的多个View，反之，当View变化时，ViewModel由DOM监听通知更新相关的多个Model。 引用文献资料[^3]:浅析 web 前端 MVVM[db/ol].https://zhuanlan.zhihu.com/p/54355504[^4]:程桂花.MVVM前后端数据交互中安全机制的研究与实现[D].浙江理工大学硕士学位设计,2017:6-7[^5]:你真的理解了MVC, MVP, MVVM吗？[db/ol].https://blog.csdn.net/wdr2003/article/details/79811767[^6]:易剑波.基于 MVVM 模式的 WEB 前端框架的研究[D].计算机工程应用技术,2016.19:76][^7]:Vue MVVM理解及原理实现[db/ol].https://juejin.cn/post/6844903929298288647","link":"/2021/06/26/%E5%85%B3%E4%BA%8E%20MVVM%E5%92%8CMVC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"},{"title":"关于JAVA 反射 基础知识_编码经验的一些总结","text":"傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 写在前面 温习一下毕业以来学习的东西。准备做成一个系列。所以对于每一部分技术点进行一个笔记整理。更多详见 java面试的一些总结 笔记主要是以网上开源的一本《Java核心面试知识整理》面试笔记为原型，结合工作中学习的知识。《Effective Java》、《编写高质量代码(改善Java程序的151个建议)》这两本书为方向进行整理。 笔记立足DevOps。开发+运维+测试三个方向 ,面向对JAVA有一定了解的小伙伴用于温习，因为理论较多一点。**在不断更新，博文内容理解不足之处请小伙伴留言指正**。 傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 二、JAVA 反射动态语言动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。 反射机制概念(运行状态中知道类所有的属性和方法)反射(Reflection)机制允许程序在运行时借助Reflection API取得任何类的内部信息，并不能直接操作对象的内部属性及方法。反射被视为动态语言的关键。 白话讲解：在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。 JAVA 反射 API如果面试被问到，对于反射API了你了解多少？怎么回答。 Reflection API 提供了Constructor，Field和Method类，这三个类定义在java.lang.reflect包中，分别用于描述类的构造方法，属性和方法。JAVA8之后在在java.lang.reflect包中添加了Executable抽象类，parameterl类这两个API，Executable描述类的执行对象，parameter描述方法参数信息。 当然，获取这些反射APl的实例信息，还需要一个最重要对象元类Class，java.lang.Class类封装一个对象和接口运行时的状态。当类加载时Class类型的对象自动创建，Class没有公共构造方法，其对象是JVM在类加载时通过类加载器中的defineClass()方法自动构造的，不能显示的实例化一个class对象。 如果面试被问到你刚才说了类加载，你可以讲讲类加载么？ 所谓类加载，就是指将类的class文件读入内存，并为之创建一个Java.lang.class对象。即当线程使用任何一个类时，系统都会为之创建一个java.lang.Class对象。java可以使用使用forName动态加载类文件，动态加载(Dynamic Loading)是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时决定是否要加载一个类，一个类文件只有在被加载到内存中才可能生成实例对象，即加载到内存中，生成Class对象，通过new关键字生成实例对象。 每个类被加载之后，会生成一个Class对象，通过Class对象可以访问JVM中该类的信息，一旦类被载入JVM中，同一个类将不会被再次载入，被载入的类都有一个唯一的标识，是该类得到全限定类名(包括包名和类名)。 ClassClass常用方法：如果面试被问到你对Class对象了解多少,说几个常用方法，怎么回答？ Class常用方法 描述 static Class forName(String className) 返回指定类名的Class对象 T newInstance() 调用默认的构造方法，返回该Class对象的一个实例 String getName() 返回Class对象锁对应的类名 构造器相关方法 描述 Constructor&lt;?&gt;[] getConstructors() 返回Class对象所对应类的所有public构造方法 Constructor&lt;T&gt;getConstructors(Class&lt;?&gt;...parameterType) 返回Class对象所对应的类的指定参数列表的public构造方法 Constructor&lt;?&gt;[]getDeclaredConstructors() 返回Class对象所对应的所有构造方法，与访问权限无关 Constructor&lt;T&gt;getDeclaredConstructors(Class&lt;?&gt;...parameterTypes) 返回Class对象所对应类的指定参数列表的所有构造方法，与访问权限无关,如果使用私有构造器构造，需要开启访问权限setAccessible(true)：设置通过反射访问该成员变量时取消访问权限检查。 方法相关方法 描述 Method[] getMethod() 返回Class对象所对应类的所有public方法 Method getMethod(String name,Class&lt;?&gt;...parameterType) 返回Class对象所对应的指定参数列表的public方法 Method[] getDeclaredMechods() 返回Class对象所对应的所有方法，与访问权限无关 Method getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes) 返回Class对象对应类的指定参数列表的方法，与访问权限无关 属性相关方法 描述 Field[] getFields() 返回Class对象所对应类的所有public成员变量 Field getField(String name) 返回Class对象所对应的类的指定参数的public成员变量 Field[] getDeclaredFields( ) 返回Class对象所对应类的所有成员变量,与访问权限无关 Field getDeclaredField(String name) 返回Class对象所对应类指定参数的成员变量，与访问权限无关 这里需要注意的是(Method、Constructor的也一样): 调用getDeclaredFields()方法可以获取包括私有和受保护的所有属性，但不包括父类的属性； 调用getField()方法可以获得所有的public属性。包括从父类继承的。 注解相关方法 描述 Annotation [] getAnnotation() 返回Class对象所对应类上存在的所有注解 &lt; A extends Annotation&gt;A getAnnotation(Class &lt; A &gt;annotationClass ) 返回Class对象所对应类上存在的指定类型的注解 Class自身信息相关方法 描述 Class&lt;?&gt;getDeclaringClasses() 返回Class对象所对应的外部类 Class&lt;?&gt;[] getDeclaredClasses() 返回Class对象所对应的类里包含的所有内部类 Class&lt;? super T&gt;getSuperclass() 返回Class对象所对应的类里的父类的Class对象 int getModifiers() 返回Class对象所对应类的修饰符，返回的整数是修饰符的对应常量，需要是使用Modified工具类解码 Class [] getInterfaces() 返回Class对象所对应类实现的所用接口 Class LoadergetClassLoader() 返回该类的类加载器 包相关方法 描述 Package getPackage() 返回Class对象所对应的包 Class谓词相关方法 描述 boolean isArray() 判断Class对象是否表示一个数组类 boolean isEnum() 判断Class对象是否表示一个枚举 boolean isInterface() 判断Class对象是否表示一个接口 boolean isInstance(Object obj) 判断obj对象是否是该Class对象的一个实例 boolean isAnnottation() 返回Class对象是否标识一个注解类型 获取Class对象的四种方式：如果面试被问到如何获取Class对象，怎么回答？ 使用Class类的forName(String classNmae)静态方法,参数class代表所需要类的全限定类名。forName()方法声明抛出ClassNotFoundException受检异常，调用必须捕获或抛出异常。1Class&lt;?&gt; reflection_demoClass = Class.forName(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); 调用某个类的class属性来获取该类对应的Class对象，对象.class;类的Class属性获得该类所对应的Class对象，会始代码更安全。程序性更好。string类型的字符串不能使用String.class方式。需要使用Class.forName（“java.lang.String”），Object类的.class文件默认是不包含参数信息的。1Class&lt;Reflection_Demo&gt; reflection_demoClass = Reflection_Demo.class; 调用某个类的getclass()方法来获取该类对应的class对象，该方法是Object类中的一个方法1Class&lt;? extends Reflection_Demo&gt; aClass = new Reflection_Demo().getClass(); 调用元类Class对应的getClassLoader()获取类加载器，ClassLoader，这个有点牵强，姑且算一种吧，嘻嘻。。12ClassLoader classLoader = Reflection_Demo.class.getClassLoader();Class&lt;?&gt; bClass = classLoader.loadClass(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); 下面我们看看剩下的API吧！ ExecutableExecutable抽象类：JAVA8在java.lang.reflect包下新增了一个Executable抽象类，代表可执行的类成员。Executable抽象类派生了Constructor和Method两个子类。Executable抽象类提供了大量方法来获取参数，修饰符或注解等信息。 方法 描述 parameter [] getparameters() 获取所有形参，返回一个parameter [] 数组 int getParameterCount() 获取形参个数 abstract int getModifiers() 获取修饰符，返回的整数是修饰符关键字对应的常量 boolean isVarArgs() 判断是否包含数量可变的形参 ConstructorConstructor类：用于表示类的构造方法。通过Class的getConstructor()方法来获取构造方法的集合。 方法 描述 String getName() 返回构造器的名称 Class [] getParameterTypes() 返回当前构造方法的参数类型 int getModifiers() 返回修饰符的整型标识，返回的整数是修饰符是标识常量，需要使用Modified工具类方法解码Modified.toSting(int mod),可以通过Modified.PUBLIC 查看对应的值 MethodMethod类：用于封装方法的信息，调用Class对象的getMethods(）方法或getMethod()可以获取当前类的所有方法或指定的方法。 常用方法 功能描述 String getName(） 返回方法的名称 Class[] getparameterType() 返回方法的参数类型 int getModifieds() 返回修饰符的整型标识 Class getReturnType() 返回当前方法的返回类型 FieldField类：用于封装属性信息，调用Class对象的getFields()或getField()方法可以获取当前类的所有属性或指定属性。 常用方法 描述 String getName() 获取属性的名称 int getMOdifiers() 返回修饰符的整型标识 getXxx(Object obj) 获取属性的值，此处的Xxx对应的java8中的基本类型，如果属性是引用类型，直接使用get(Object obj)方法 setXxx(Object obj,Xxx val) 设置属性的值，此处的Xxx对应Java8中的基本类型，如果属性是引用类型，直接使用set(Object obj，Object val)方法 Class [] getType() 返回当前属性的类型 parameterparameter类：是JAVA8中新增的API，每个paramtete 对象代表一个参数。Parameter类提供许多方法来获取参数信息 方法 功能 int getModifiers() 获取参数的修饰符 String getName() 获取参数的形参名 Type getparameterizedType() 获取带泛型的形参类型 Class&lt;?&gt;getType() 获取形参类型 boolean isVarArgs() 判断该参数是否为可变参数 boolean isNamePreaent() 判断.class文件中是否包含方法的形参名信息 利用反射创建对象的的两种方式：如果面试被问到使用反射如何创建对象，怎么回答？ Class 对象的 newInstance(): 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。1234Class&lt;?&gt; reflection_demoClass = Class.forName(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); Reflection_Demo o = (Reflection_Demo) reflection_demoClass.newInstance(); System.out.println(o);// com.liruilong.Reflection.Reflection_Demo@677327b6 调用Constructor对象的 newInstance(): 先使用 Class 对象获取指定的 Constructor 对象，再调用Constructor对象的newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。12345Class&lt;?&gt; reflection_demoClass = Class.forName(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); Constructor&lt;?&gt; constructors = reflection_demoClass.getConstructor(null); Reflection_Demo o1 = (Reflection_Demo) constructors.newInstance(null); System.out.println(o1); // com.liruilong.Reflection.Reflection_Demo@14ae5a5 关于反射的一些其他编码经验：如果面试问关于反射，平常开发中有哪些经验，要怎么回答？ **注意Class类本身的特殊性**：Java语言把Java源文件编译为后缀为class的字节码文件，然后通过ClassLocale机制把类文件加载到内存中，最后生成实例执行，Java使用元类(MetaClass）来描述加载到内存中的类数据，即Class类，描述类的类对象，需要注意Class的一些特性。 无构造函数，不能主动实例化，Class对象在加载时由java虚拟机通过类加载器中的defineClass自动构造。 可以描述基本类型 Class as=int.class;8个基本类型执行JVM中并不是一个对象，一般存在于栈中，通过Class可以描述它们，可以使用int.calss描述int类型的类对象。 Class对象都是单例模式，一个Class对象描述一个类，只描述一个类，即一个类只有一个Class对象。Class是java 的反射入口，只有在获得一个类的动态描述时才能动态的加载调用。 **适时选择getDeclaredXXX和getXXX**：getDeclaredMethod方法获得的是所有public访问级别的方法，包括从父类继承来的方法，而getDeclareMethod获得自身类的所有方法，包括公有的(public)，私有(private),方法等，不受访问权限限制。如果需要列出所有继承自父类的方法，可以先获得父类，然后使用getDeclareMethods，之后持续递归。 反射访问属性或方法时将Accessible设置为true，java中通过反射执行方法的步骤，获取一个对象的方法，然后根据isAccessible返回值确定是否能执行，如果返回false，则需要调用setAccessible(true),在调用invoke执行方法。 Access并不是语法层次理解的访问权限，而是指是否更容易获得，是否进行安全检查。动态的修改一个类或方法或执行方法时都会受到Java安全体系的制约，而安全处理非常消耗资源，所以对于运行期要执行的方法或修改的属性就提供了Accessible可选项，由开发者决定是否要逃避安全体系的检查。 AccessibleObject是field，Method，constructor的父类，决定其是否可以快速访问而不进行访问控制检查，AccessobleObject类中是以override变量保存该值的。 Accessible属性只是用来判断是否需要进行安全检查的，如果不需要则直接执行，可以提升系统性能. AccessibleObject的其他两个子类field和 constructor也相似，所以要设置Accessible为true。1234567891011121314Method method= genericDemo.class.getMethod(&quot;toArray&quot;); if(!method.isAccessible()) method.setAccessible(true); method.invoke(obj, args); public class Foo { public final void doStuff() { System.out.println(&quot;Do liruilong ___$# ^_^&quot;); } public static void main(String[] args) throws Exception, Throwable { Method method = Foo.class.getMethod(&quot;doStuff&quot;); System.out.println(&quot;可以访问吗！！&quot;+method.isAccessible()); method.invoke(new Foo()); } 动态加载不适合数组，当使用forName加载一个类时，8个基本类型排除，它不是一个具体的类，还要具有可追索的类路径，否则包ClassNotFoundException异常。数组虽然是一个类，但没有定义类路径，可以加载编译后的对象动态动态加载一个对象数组，但是没有意义。在java中数组是定长的，没有长度的数组是不允许存在的。可以使用Array数组反射类来动态加载一个数组。 123//动态创建一个数组String [] strs = (String[]) Array.newInstance(String.class,8);int[][] ints = (int [][])Array.newInstance(int.class,2,3); 元素类型 编译后的类型 byte[] [B char[] [C Double[] [D Float[] [F Int[] [I Long[] [J Short[] [S Boolean [Z 引用类型(如String) [L引用类型 动态可以让代理模式更灵活，java的反射框架提供了动态代理(Dynamic Proxy)机制，允许在运行期对目标对象生成代理，静态代理：通过代理主题角色和具体主题角色共同实现抽象主题角色的逻辑的，只是代理主题角色把相关的执行逻辑委托给了具体主题角色而已。 123456789101112131415161718192021222324interface subject{ public void request();}class RealSubject implements subject{ public void request(){ }}class Proxy implements subject{ private subject subjects = null; public Proxy(){ subjects = new RealSubject(); } public Proxy(subject subjects){ this.subjects =subjects; } public void request(){ befoer(); subjects.request(); afert(); } public void befoer(){} public void afert(){}} java基于java.lang.reflect.Proxy用于实现动态代理，使SubjectHandler作为主要的逻辑委托对象，invoke是必须要实现的，完成对真实方法的调用。即通过InvocationHandler接口的实现类来实现，所有被代理的方法都是由InvocationHandler接管实际的处理任务。 12345678910111213141516171819202122232425262728293031323334interface subject{ public void request();}class RealSubject implements subject{ public void request(){ }}class SubjectHandler implements InvocationHandler{ private subject subjects; private SubjectHandler(subject subjects) { this.subjects = subjects; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;预处理&quot;); Object obj = method.invoke(subjects,args); System.out.println(&quot;后处理&quot;); return obj; }}//场景类 public static void main(String[] args) { subject subjects = new RealSubject(); InvocationHandler handler = new SubjectHandler(subjects); //当前加载器 ClassLoader cl = subjects.getClass().getClassLoader(); //动态代理 subject proxy = (subject) Proxy.newProxyInstance(cl,subjects.getClass().getInterfaces().request(),handler); //执行具体的角色方法 proxy.request(); } 使用反射增加装饰模式的普遍性，装饰模式：动态的给一个对象添加一些额外的职责。使用动态代理可以实现装饰模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//动物interface Animal{ public void doStuff();}//老鼠class Rat implements Animal{ @Override public void doStuff(){ System.out.println(&quot;Jetty Tom&quot;); }}//定义某种能力interface Featuer{ public void load();}class FlyFeatuer implements Featuer{ public void load(){ System.out.println(&quot;增加 一支翅膀&quot;); }}class DigFeatuer implements Featuer{ public void load(){ System.out.println(&quot;增加钻地能力！&quot;); }}class DecorateAnimal implements Animal{ private Animal animal; private Class&lt;? extends Featuer&gt; clz; public DecorateAnimal(Animal animal,Class&lt;? extends Featuer&gt; clz){ this.animal = animal; this.clz = clz; } @Override public void doStuff(){ InvocationHandler handler = new InvocationHandler() { //具体的包装行为 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object obj = null; //设置包装 // public class Modifier // extends ObjectModifier类提供了static方法和常量来解码类和成员访问修饰符。 修饰符集合被表示为具有表示不同修饰符的不同位位置的整数。 //method.getModifiers()返回由该对象表示的可执行文件的Java语言modifiers 。 if (Modifier.isPublic(method.getModifiers())){ obj = method.invoke(clz.newInstance(),args); } animal.doStuff(); return obj; } }; ClassLoader cl = getClass().getClassLoader(); Featuer Proxy = (Featuer) java.lang.reflect.Proxy.newProxyInstance(cl,clz.getInterfaces(),handler); Proxy.load(); }}public class Demo { public static void main(String[] args) { //定义Jerry老树 Animal Jerry = new Rat(); Jerry = new DecorateAnimal(Jerry,FlyFeatuer.class); Jerry = new DecorateAnimal(Jerry,DigFeatuer.class); Jerry.doStuff();}} 反射让模板方法模式更强大，模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可定义该算法的某些特定的步骤，即父类定义抽象模板为骨架，其中包括基本方法(由子类实现的方法，并且在模板方法被调用)和模板方法(实现对基本方法的调用，完成固定的逻辑) 123456789101112131415161718192021222324252627282930313233343536373839public abstract class AbsPopulator{ public final void dataInitialing() throws Exception{ doInit(); } protected abstract void doInit();}public class UserPopulator extends AbsPopulator{ protected void doInit(){} /*初始化用户表，如创建，加载数据等*/}//基于反射增强的模板方法 public abstract class AbsPopulator{ public final void dataInitialing() throws Exception{ doInit(); //获得所有public方法 Method[] methods = getClass().getMethods(); for(Method m:methods){ //判断是否是数据初始化方法 if(isIinitDataMethod(m)){ m.invoke(this); } } } private boolean isIinitDataMethod(Method m) { return m.getName().startsWith(&quot;init&quot;)&amp;&amp;//init开始 Modifier.isPublic(m.getModifiers())&amp;&amp;//公开的方法 m.getReturnType().equals(&quot;Void.Type&quot;)&amp;&amp;//返回类型为void !m.isVarArgs()&amp;&amp;//输入参数不为空 !Modifier.isAbstract(m.getModifiers());//不能为抽象方法 } public class UserPopulator extends AbsPopulator{ public void Inituser(){} public void InitPassword(){} public void InitJobz(){} public void Inituser(){} /*初始化用户表，如创建，加载数据等*/ } 使用反射后，不需要定义任何抽象方法，只需要定义一个基本的方法鉴别器，即可加载否和规则的基本方法，模板方法根据鉴别器返回执行相应的方法。 不需要太多的关注反射效率，获得一个泛型类的实际泛型类型。这个Demo有点问题，以后再研究 123456789101112131415161718class Utils{ //获得一个泛型类的实际泛型类型 public static &lt;T&gt; Class&lt;T&gt; getGenricClassType(Class clz) { //返回 Type表示此所表示的实体（类，接口，基本类型或void）的直接超类 类 Type type = clz.getGenericSuperclass(); //ParameterizedType表示一个参数化类型，如Collection &lt;String&gt;。 if(type instanceof ParameterizedType){ ParameterizedType pt = (ParameterizedType){ ParameterizedType pt = (ParameterizedType)type; Type[] types = pt.getActualTypeArguments(); if (types.length&gt;0&amp;&amp;types[0] instanceof Class){ return (Class)types[0]; } } return (Class)Object.class; } }}","link":"/2021/06/26/%E5%85%B3%E4%BA%8EJAVA%20%E5%8F%8D%E5%B0%84%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86_%E7%BC%96%E7%A0%81%E7%BB%8F%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"},{"title":"Linux红帽证书RHCAS考试笔记","text":"“你当然自在了，你是被爱的那一个！” —-非流 写在前面笔记是报班考红帽的笔记，大都是老师的笔记，有些地方有自己的补充，这是CSA 的笔记。CE的在下面 CE的笔记(Ansible) 配置网卡RHEL7/8的系统管理器init（systemd） 配置单元（unit）：service(服务)、target（启动级别）关于网络服务设置： network --&gt; NetworkManager（RHEL8已经没有network服务） 临时设置：命令工具:1234hostname、hostname 新主机名 ifconfig [-a]、ifconfig 连接名 IP地址/掩码长度 route -n、route add|del default gw 默认网关地址 host 查询对象 [DNS服务器地址] 固定/永久设置：改配置文件、重载服务123/etc/hostname /etc/sysconfig/network-scripts/ifcfg-连接名 hostnamectl set-hostname 新主机名 辅助配置工具： nmcli（命令行）、nmtui（文本用户界面）、nm-connection-editor（图形） 接口名：内核识别的网卡设备的物理名称 连接名：网卡所使用的这一份网络配置的逻辑名称12345678910111213nmcli基本用法： nmcli device status nmcli connection show nmcli connection show &quot;连接名&quot; nmcli connection modify &quot;连接名&quot; ipv4.method man ipv4.addresses &quot;IP地址/掩码&quot; nmcli connection modify &quot;连接名&quot; ipv4.gateway 默认网关地址 nmcli connection modify &quot;连接名&quot; ipv4.dns DNS服务器地址 nmcli connection modify &quot;连接名&quot; connection.autoconnect yes nmcli connection up &quot;连接名&quot; nmcli connection down &quot;连接名&quot; nmcli connection add con-name &quot;连接名&quot; ifname 接口名 type ethernet nmcli connection del &quot;连接名 1234[root@server1 ~]$ ifconfig #查看ip地址[root@server1 ~]$ nmtui #文本方式配置ip地址为ens33网卡配置ip，如果找不到ens33网卡，可按以下方式添加[root@server1 ~]$ nmcli connection add con-name ens33 ifname ens33 type ethernet #添加ens33网卡[root@server1 ~]$ nmtui #然后再使用该命令配置ip， vmnet的虚拟网络编辑器添加虚拟网卡，用来让真机和虚拟机互联，虚拟网卡构建 123456[root@server1 ~]# nmnm nm-connection-editor nmtui nmtui-editnmcli nm-online nmtui-connect nmtui-hostname[root@server1 ~]# nmtui[root@server1 ~]# 配置网卡分三步，配置ip。网关，激活网卡，修改域名修改获取方式为手动，Manual， 配置IP/掩码、网关、DNS、demo: 192.168.1.8/24、192.168.1.254、192.168.1.254激活或者使用命令行的方式配置 1234567nmcli connection modify enp1s0 ipv4.method manual ipv4.addresses 172.25.0.25/24 命令行修改ipnmcli connection up enp1s0 命令行激活网卡显示所有包括不活动连接：nmcli con show显示所有活动连接： nmcli con show –active显示网络连接配置：nmcli con show &quot;System eth0“显示设备状态：nmcli dev status显示网络接口属性：nmcli dev show eno16777736 linux常见目录 图形环境，通过 Activities -&gt; Files -&gt; Other Locations -&gt; Computer 命令行环境，ls /Linux目录的层次分隔：斜杠 / + 最顶层 就是 一个 / ，表示根目录 名称 描述 bin、sbin 存放可执行文件 home 存放普通用户的家目录 dev 存放硬件设备 mnt 可挂载外部设备 media 自动识别并挂载的目录 proc 内存数据的映射，临时数据，不占硬盘空间 tmp 存放临时文件的目录 var 存放经常变化的数据 ，比如日志、邮件 boot 存放内核文件 etc 存放配置文件 opt 可以存放第三方文件 usr 存放用户相关数据 命令行的基本格式：命令名字 [-选项…] [参数…] 选项的作用，控制命令的执行方式、效果 参数的作用，为命令提供操作对象基本命令 命令行常用的快捷键 CTRL-A 将光标移到行首（在命令行下） CTRL-E 将光标移动到行尾（在命令行下） CTRL-U 擦除从光标位置开始到行首的所有字符内容。在某些设置下，CTRL-U会不以光标位置为参考而删除整行的输入。 CTRL+ K ·： 从光标处向后删除指令串 CTRL-J 新行(换行[line feed]并到行首)。在脚本中，也可能表示为八进制形式(‘/012′)或十六进制形式(‘/x0a’)。 CTRL-B 退格 (非破坏性的)，这个只是将光标位置往回移动一个位置。 CTRL-H 擦除(Rubout)(破坏性的退格)。在光标往回移动的时候，同时擦除光标前的一个字符。 CTRL-C 中断，终结一个前台作业。 CTRL-D “EOF” (文件结尾：end of file)。它用于表示标准输入（stdin）的结束。在控制台或xterm 窗口输入文本时，CTRL-D 删除在光标下的字符。从一个shell中退出 (类似于exit)。如果没有字符存在，CTRL-D 则会登出该会话。在一个xterm窗口中，则会产生关闭此窗口的效果。 CTRL-F 将光标向前移动一个字符（在命令行下） CTRL-G BEL。在一些老式打印机终端上，这会引发一个响铃。在xterm终端上可能是哔的一声。 CTRL-I 水平制表符。 CTRL-O 产生一个新行（在命令行下）。 CTRL-P 从history缓冲区召回上一次的命令（在命令行下）。此快捷键召回的顺序是由近及远的召回，即按一次，召回的是前一次的命令，再按一次，是召回上一次之前的命令，这和CTRL-N都是以当前的输入为起点，但是两个命令操作刚好相反，CTRL-N是从起点开始由远及近（如果起点是历史命令的话）。 CTRL-Q Resume (XON)。恢复/解冻，这个命令是恢复终端的stdin用的，可参见CTRL-S。 CTRL-R 回溯搜索(Backwards search)history缓冲区内的文本（在命令行下）。注意：按下之后，提示符会变成(reverse-i-search)”:输入的搜索内容出现在单引号内，同时冒号后面出现最近最匹配的历史命令。 CTRL-S Suspend(XOFF)，挂起。这个是冻结终端的stdin。要恢复可以按CTRL-Q。 CTRL-T 交换光标位置与光标的前一个位置的字符内容（在命令行下）。比如：echo $var;，假设光标在a上，那么，按下C-T之后，v和a将会交换位置：echo $avr;。 CTRL-V 在输入文本的时候，按下C-V之后，可以插入控制字符。比如：echo -e ‘/x0a’;和echo ;这两种效果一样。这点功能在文本编辑器内非常有效。 CTRL-W 当在控制台或一个xterm窗口敲入文本时, CTRL-W 会删除从在光标处往后（回）的第一个空白符之间的内容。在某些设置里, CTRL-W 删除光标往后（回）到第一个非文字和数字之间的字符。 CTRL-X 在某些文字处理程序中，这个控制字符将会剪切高亮的文本并且将它复制到剪贴板中。 CTRL-Y 将之前已经清除的文本粘贴回来（主要针对CTRL-U或CTRL-W）。 CTRL-Z 暂停一个前台的作业；在某些文本处理程序中也作为替换操作；在MSDOS文件系统中作为EOF（End-of-file)字符。 ctrl+l 清屏 ctrl+c 终止任务 tab键 补全命令 (如果不好用，要装bash-completion软件包) esc+. 调用上个指令的最后一个参数，使用alt+.可以实现相同效果 ls -l 查看文件详细信息 ls -lh 详细信息+易读容量单位 ls -ld /opt 查看opt目录本身的详细信息 ls -A 查看隐藏文件 pwd 看当前所在位置 cd /opt 切换到/opt目录 mkdir a 创建a目录 mkdir -p e/e 创建多级目录 touch x 创建普通文件，名字叫x cat x 查看x文件里面的内容 cat /etc/hosts 查看ip域名对应关系 less /etc/passwd 查看长篇文档，可以使用键盘方向键手动翻页，而不是像cat命令直接看到最后一页 su - test 切换到名为test的账户，管理员切换到其他账户无需密码，但是普通账户切换到其他账户需要密码 rm a 删除a文件 rm -r a 如果a是个目录，需要加r选项 rm -rf a 强制删除无提示 rm -rf * 删除当前目录下所有文件，高风险命令，慎用！！ cp /etc/passwd /opt 拷贝etc下的passwd文件，到根目录下opt，常用选项 -r，recursive，复制多级目录的时候需要加 mv passwd /root 移动passwd文件到管理员的家目录 mv passwd abc 为passwd文件改名为abc 获取命令的帮助man 执行 man 命令名 来获取这个命令的使用帮助 重点看SYNOPSIS（语法格式）、DESCRIPTION（选项的含义和用法描述） 按/word查找包含word的文字描述，按 n或N来切换不同查找结果 按 PgUp、PgDn翻页，按q键退出文本编辑器vi / vim三种工作模式： 1，命令模式 刚进入编辑器时，可以查看文档内容，可以进行复制yy、粘贴p操作、剪切dd（可以当删除使用），u可以撤销上一次操作 2，输入模式 在命令模式按i 键 ，再按esc可以返回命令模式 3，末行模式 在命令模式输入：1yum -y install vim-enhanced 可以安装增强版的vim编辑器 客户端配置文件：/etc/yum.conf、/etc/yum.repos.d/*.repo 配置软件仓库用途：软件仓库/YUM源为其他客户机集中提供软件包及关联信息 ,RHEL8光盘预设源：BaseOS、AppStream 1234567[仓库1标识] name = 仓库描述 baseurl = 仓库的地址 enabled = 1|0 gpgcheck = 1|0 #gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release[仓库2标识] 123456789101112cd /etc/yum.repos.d/vi abc.repo[BaseOS] 仓库名称name=BaseOS 仓库描述baseurl=http://server1.net0.example.com/rhel8/BaseOS 仓库软件来源enabled=1 仓库是否开启 ，1是开启0是关闭，默认不写这行也行，不写就是开启gpgcheck=0 检测软件合法性，通常是0无需检测[AppStream]name=AppStreambaseurl=http://server1.net0.example.com/rhel8/AppStreamenabled=1gpgcheck=0 常见的软件包安装： 1# yum -y install bash-completion net-tools vim-enhanced bind-utils 阿里云 yum文件 12345678910111213yum repolist 查询仓库yum -y install vim 利用仓库安装vim软件yum -y install bash-completion 安装支持tab键的软件，安装完后需要退出，再登陆yum provides ifconfig 查询ifconfig命令来自于哪个软件包yum -y install net-tools 安装支持ifconfig等命令的软件包#yum配置好之后使用yum或者dnf命令都可以调用仓yum clean all 清除软件仓库缓存yum repolist 查询软件仓库信息yum -y install vsftpd 安装软件包（vsftpd服务）yum -y remove vsftpd 删除软件包yum provides ifconfig 查询ifconfig命令来自哪个软件包yum search 关键词 //根据关键词搜索相关的软件yum -y update 软件名.. .. //升级软件包 systemctl服务控制： systemctl，系统控制器，用来管理Linux系统的开机/关机/服务资源运行状态 直接执行 systemctl 列出可以管理的系统资源，包括各种系统服务 控制服务当前运行状态：systemctl start|stop|restart|status 服务名.. .. 控制服务开机自启状态：systemctl enable|disable 服务名.. .. [--now] firewalld、SELinux安全开关： 防火墙的作用，内核的一套网络保护机制，通过firewalld服务来控制 如何停止防火墙：systemctl disable firewalld --now SELinux的作用，内核的一套系统保护机制，通过内核启动参数或者启动配置来控制 如何关闭SELinux机制（三种状态 —— Enforcing强制保护、Permissive宽松模式、Disabled禁用 1234# vi /etc/selinux/configSELINUX=Permissive ==》重启后生效# setenforce 0|1 ==》立即变成宽松|强制模式# getenforce ==》查看结果 服务管理：123456789systemctl start vsftpd 开启服务systemctl stop vsftpd 关闭服务systemctl restart httpd 重启服务systemctl status vsftpd 查服务详细状态，可以看到服务是否开启等信息systemctl is-active vsftpd 查服务精简状态，仅仅看是否开启systemctl is-enabled vsftpd 查看服务是否开机自启systemctl enable vsftpd 设置服务开机自启systemctl disable firewalld --now 取消服务的开机自启，并关闭服务systemctl enable firewalld --now 设置开机自启，并且开启服务 忘记服务名字查看 1234[root@liruilong tmp]# systemctl list-unit-files | grep ^fire*firewalld.service disabled[root@liruilong tmp]# 防火墙 ： 12systemctl stop firewalld 关闭systemctl disable firewalld 取消开机自启 selinux ： 美国NSA国家安全局提供的一套基于内核的增强的强制安全保护机制，主要针对用户、进程、文档做了一些安全标签及相关限制。getenforce 查selinux是否开启，可以看到下列3种状态Enforcing是开启状态 ，Permissive是关闭(宽松)，disabled是永久关闭setenforce 1 临时设置selinux，1是开启，0是关闭 安全策略谁来提供：NSA、RedHat 查看文件、进程的安全上下文： ls -Z .. .. ps -Z .. .. 1vim /etc/selinux/config 此配置文件决定了服务器重启后，selinux处于什么状态，永久设置 可设置项目： 1，设置布尔值（对某些软件工具提前预设的开关） 12 getsebool -a 查看布尔值setsebool -P ftpd_anon_write=on 修改某服务对应的布尔值开关on是开启，off是关闭 2，设置安全的上下文123ls -Z abc.html 查看某文件上下文值chcon -t admin_home_t abc.html 修改文件上下文值，-t是指定文件的归属restorecon abc.html 根据服务的预设值自定定义abc文件的上下文值 3，设置端口 1234567yum -y install setroubleshoot-server selinux排错工具包semanage port -l 查询semanage port -l | grep http 过滤查询，只看http相关内容semanage port -a -t http_port_t -p tcp 82 在selinux管理的服务端口中，为http添加82端口-a 是添加，如果是-d 就是删除-t 指定某服务类型 -p 是定义协议和要添加的端口 防火墙系统服务：firewalld 预设安全区域： block：阻止所有数据包 drop：丢弃所有数据包 public：公共区域，允许SSH等极个别服务，默认区域 rusted：信任区域，允许任何访问 work：办公区域，允许SSH、Samba少数几个服务 预设保护服务： http、https、dns…… 防火墙管理工具： firewall-cmd、firewall-config 防火墙规则的作用范围： 运行配置 —— 当前有效，重启firewalld服务后失效 永久配置 —— 当前无效，重启firewalld服务后有效 ，通过添加 –permanent 选项设置 查看/修改默认区域： 12# firewall-cmd --get-default-zone# firewall-cmd --set-default-zone=trusted 如何设置具体的防火墙规则： 12# firewall-cmd --add-service=服务名 --zone=区域名# firewall-cmd --add-source=源地址 --zone=区域名 常用配置 12345678910111213141516171819202122#执行如下命令，查看防火墙状态，是否为running。firewall-cmd --state#执行如下命令，重新载入配置。比如在添加规则等之后，需要执行此命令。firewall-cmd --reload#执行如下命令，列出支持的zone。firewall-cmd --get-zones#执行如下命令，列出支持的服务，在列表中的服务是放行的。firewall-cmd --get-services#执行如下命令，查看FTP服务是否支持，返回yes表示支持，返回no表示不支持。firewall-cmd --query-service ftp#执行如下命令，临时开放FTP服务。firewall-cmd --add-service=ftp#执行如下命令，永久开放FTP服务。firewall-cmd --add-service=ftp --permanent#执行如下命令，永久移除FTP服务。firewall-cmd --remove-service=ftp --permanent#执行如下命令，永久添加80端口。firewall-cmd --add-port=80/tcp --permanent#执行如下命令，查看规则，此命令和iptables相同。iptables -L -n#执行如下命令，查看帮助。man firewall-cmd 12345678910111213141516171819202122#查看 firewalld 服务当前所使用的区域： firewall-cmd --get-default-zone #查询 eno16777728 网卡在 firewalld 服务中的区域： firewall-cmd --get-zone-of-interface=eno16777728 #把 firewalld 服务中 eno16777728 网卡的默认区域修改为 external，并在系统重启后生效。分 别查看当前与永久模式下的区域名称：firewall-cmd --permanent --zone=external --change-interface= eno16777728firewall-cmd --get-zone-of-interface=eno16777728 firewall-cmd --permanent --get-zone-of-interface=eno16777728 #把 firewalld 服务的当前默认区域设置为 public： firewall-cmd --set-default-zone=public #启动/关闭 firewalld 防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器 时请慎用）：firewall-cmd --panic-on firewall-cmd --panic-off #查询 public 区域是否允许请求 SSH 和 HTTPS 协议的流量： firewall-cmd --zone=public --query-service=ssh firewall-cmd --zone=public --query-service=https #把 firewalld 服务中请求 HTTP 协议的流量设置为永久拒绝，并立即生效： firewall-cmd --permanent --zone=public --remove-service=http firewall-cmd --reload #把在 firewalld 服务中访问 8080 和 8081 端口的流量策略设置为允许，但仅限当前生效： firewall-cmd --zone=public --add-port=8080-8081/tcp firewall-cmd --zone=public --list-ports 账户管理：12345678910111213141516useradd abc 添加账户userdel -r xyz01 删除用户，-r是删除与用户有关的文件echo xxxxx | passwd --stdin abc 为abc账户非交互式配置密码 xxxxxid abcd 查看用户基本信息 uid是用户id号码 gid是用户所在基本组的号码 groups是用户附加组信息---------------------------tail -1 /etc/passwd 查看系统刚刚创建的用户信息grep abc: /etc/passwd 查看系统种名字包含abc字符串的用户信息usermod -u 1600 xyz02 为已经创建好的xyz02账户修改id号usermod -d /opt xyz03 修改xyz03的家目录为/optgpasswd -a xyz03 xyz02 为xyz03添加一个附加组(附属组)xyz02gpasswd -d xyz03 xyz02 为xyz03从附加组xyz02中删除usermod -s /sbin/nologin abcd 修改abcd账户的解释器为不可交互的状态groupadd admins 创建组adminsuseradd -G admins zhsan 创建账户zhsan的同时添加附加组admins组su - zhsan 切换账户 -------------------------------- 定义计划任务： 123456789crontab -e 为当前账户添加计划任务crontab -e -u lisi 指定lisi账户添加计划任务* * * * * date &gt;&gt; /opt/test 每分钟执行date任务5-15 * * * * date &gt;&gt; /opt/test 每小时的5-15分钟10,13,17 * * * * date &gt;&gt; /opt/test 每小时的10，13，17分钟执行*/5 * * * * date &gt;&gt; /opt/test 每隔3分支执行一次10-15/2 * * * * date &gt;&gt; /opt/test 每小时的10-15分钟里，每隔2分钟执行一次crontab -r 删除计划任务systemctl is-enabled crond.service 检测计划任务服务是否开机自启 设置基本权限：12345678910111213141516171819基本权限 r 读 w写 x执行（目录是进入权限）chmod o+w abcd 为abcd文件的其他人添加写权限chmod u-x abcd 为abcd文件的所属主删除x权限chmod g+x abcd 为abcd文件的所属组 添加x权限所属主 所属组 其他人u g o------------------数字方式定义文件权限r=4 w=2 x=1chmod 777 abcd 将abcd文件的所属主 所属组 其他人 的权限都设置成拥有rwxchmod 700 abcd 将abcd文件的所属主设置成拥有rwx权限 而所属组与其他人没有任何权限-----------------------修改所属chown lisi test 只修改所属用户chown :lisi test 只修改所属组chown abcd:abcd test 修改用户:组 chown -R lisi abc 递归修改abc目录以及目录中所有文件的所属主为lisi -R表示递归，对chmod命令也适用-------------------- acl 访问控制列表1234setfacl -m user:zhsan:rw /var/tmp/hosts 给zhsan用户单独针对hots文件的rw权限setfacl -m group:zhsan:rw /var/tmp/hosts 给zhsan组单独针对hots文件的rw权限setfacl -b /var/tmp/hosts 清除acl权限getfacl /var/tmp/hosts 查看acl权限 特殊权限,创建共用目录 附加权限： 4 set uid：附加到 “属主” 的x位上，变成 s使普通的程序具有特殊属性（任何人在执行这个程序的时候，自动拥有这个程序的所有者的权限） 2 set gid：附加到 “属组” 的x位上，变成 s使普通的程序具有特殊属性（任何人在执行这个程序的时候，自动拥有这个程序的所属组的权限） 使普通的目录的属组权限能够自动往下继承（在目录下新建的文档自动属于这个目录的属组） 1 粘滞位：附加到 “其他人” 的x位上，变成 t使用户在拥有w权限的目录下不能够删除其他人的文件 附加权限设置示例： chmod u+s 文件.. .. //比如：/usr/bin/passwd chmod g+s 文件.. .. chmod o+t 文件.. .. //比如：/tmp chmod 4755 文件.. .. chmod 1777 目录.. .. chmod 2770 目录.. .. 123set uid 可以使某用户在执行拥有此权限的文件时自动拥有此文件所属主的权限set gid 可以使某用户在执行此文件时，自动拥有此文件的所属组权限，如果是目录拥有此权限，表示在该目录下创建的文件自动属于此目录的属组粘滞位（t权限） 在一个拥有w权限的目录中，使用户之间不可以任意删除别人的文件 配置时间同步NTP，Network Time Protocol,时间同步：将计算机与指定服务器的时间保持一致 NTP服务端（考试服务器）：ntpd或chronyd NTP客户端：软件包chrony（系统服务chronyd） 客户端配置文件：/etc/chrony.conf pool 时间服务器的域名 iburst //适合一个域名解析为多个IP地址的情况（服务器池） server 时间服务器的域名 iburst //适合一个域名解析为单个服务器IP地址的情况iburst 参数的作用： 1）第一次同步时，头4个包的间隔为2秒，以便能更快的获得标准时间。 2）如果在一个标准轮询间隔内没有应答，会向NTP服务器再发送8个包（而不是通常的一个）。 3）如果NTP 服务器仍没有给出可识别的应答，那么本机的时间将不会变化。 NTP验证/设置工具：12timedatectl //查看时间日期状态信息 chronyc sources -v//检查当前使用的NTP源信息 手动设置系统日期、时间： 1234date -s 'HH:MM'date -s 'HH:MM:SS'date -s 'yyyy-mm-dd'date -s 'yyyy-mm-dd HH:MM' 补充： 根据BIOS时间设置系统时间： hwclock -s 根据系统时间设置BIOS时间：hwclock -w123456systemctl status chronyd 查看同步服务状态，通常都是开启状态vim /etc/chrony.conf 修改配置文件server server1.net0.example.com iburst 将有iburst字样那行注释掉，从新添加此内容systemctl restart chronyd 重启服务chronyc sources -v 检查结果 带^*表示同步时间成功 date -s 20:20:00 随意修改时间后，在重启服务器检测是否同步 远程复制： 配置autofs自动挂载，在网络资源使用时自动挂载，不使用时自动卸载，达到节约资源的目的。 本地文件系统：文档存放在本机连接的磁盘上EXT4、XFS、SWAP,FAT32 网络文件系统：文档存放在网络中的一台服务器上，通过共享方式提供（比如NFS）NFS，Network File Systemmount挂载（本地）：12 mount /dev/cdrom /mnt/dvd mount /dev/sda1 /mnt/tdir NFS客户端 ——查看共享资源列表： showmount -e 目标主机 //需要软件包 nfs-utils挂载NFS共享资源： mount 服务器地址:共享文件夹路径 /mnt/tdir 文件系统的挂载方式 1）手动挂载：mount 设备路径 挂载点目录 2）开机自动挂载：修改 /etc/fstab 配置文件 设备路径 挂载点目录 文件系统类型 defaults,_netdev 0 0 3）半自动挂载（已经配置好/etc/fstab）： mount 设备路径 mount 挂载点目录 4）触发挂载（按需自动挂载）：autofs服务 软件包/系统服务：autofs nfs-utils 主配置：/etc/auto.master目标文件夹监控策略配置文件 监控策略配置：/etc/*子目录名 -挂载选项:设备路径子目录名 -挂载选项NFS服务器地址:共享目录绝对路径 通过部署autofs服务，可以代替管理员按需、自动完成以下任务： 1）当有用户需要使用 /rhome/ 目录下的 ldapuser0 子目录时，提前创建此目录，并将服务器上的 classroom.example.com:/rhome/ldapuser0 挂载到本机的 /rhome/ldapuser0 2）当用户不再使用 /rhome/ 目录下的 ldapuser0 子目录时，自动卸载此目录上已挂载的资源，并删除此目录 本地账号：存放在本机的/etc/passwd、/etc/shadow，家目录一般位于 /home/用户名网络账号：存放在网络（AD域、LDAP域）中的认证服务器上，家目录也存在认证服务器上 12345678910showmount -e server1yum -y install autofs nfs-utils 安装所需软件包vim /etc/auto.master 修改主配置文件/rhome /etc/rhome.rule 在第一行添加，/rhome是在本地什么位置作为远程资源的挂载目录，/etc/rhome.rule是远程资源配置文件所在路径，可以自定义vim /etc/rhome.rule 修改上一步定义的远程资源配置文件，添加以下内容：ldapuser0 -fstype=nfs 172.25.0.254:/rhome/ldapuser0 定义账户、文件系统类型、远程资源路径systemctl restart autofs 重启服务ls /rhome 查看原本没有的/rhome目录，发现已经自动生成ls rhome/ldapuser0 再查看里面的内容，报权限错误 ，正常，已经激活自动挂载ls /rhome 再次查看目录，已经看到远程资源，成功 find搜索按照条件查找系统当中的任何文件：find [目录范围] [查找条件1] -o [查找条件2] .. .. find [目录范围] [查找条件1] -a [查找条件2] .. .. 常见的查找条件表示： -name 文档名称 -type 文档类型 【f、d、l、b、c】 -size +|-文档大小 -mtime +|-修改时间 【1 之前24小时~48小时】 -user 所属用户 -group 所属组处理find查找结果： -exec 命令行（嵌入 {} 替代查找结果） ; 修改文件的时间戳： 1touch -d '2015-12-31 12:30' f2.txt demo123456789101112131415161718可以按条件查找文件-type 按文件类型搜索 f 普通文件 d 目录 l 连接文件 b 块设备 find /opt -type f //在/opt下查找所有普通文件-name 按名称搜索 find /opt -name abc //在/opt下查找名字叫abc的文件-size + - 按文件大小搜索find / -size +50M //在根目录下找大于50M的文件-user 按用户名搜索find . -user root //再当前目录找所属主是root的文件-----------------------------------o 或者 -a 并且 可以实现多个条件的逻辑组合 find . -type f -a -name abc // 找当前目录下的普通文件并且名字叫abc，此处的-a也也可省略不写 find . -type f -o -name abc //找当前目录下的普通文件或者名字叫abc的文件----------------------------------#找出/etc/目录下大小超过 5MB 的文件，并将其副本放入/root/findfiles 目录。find /etc -size +5M -exec cp -p {} /root/findfiles \\; -exec代表有继续执行的指令 cp 是拷贝 -p保持原文件属性权限，{}是find搜索到的文件 \\;是结束 grep查找字符串可以找到文档中的字符串，并且以行为单位输出. grep基本用法： grep ‘关键词’ 文件.. .. grep ‘正则表达式’ 文件.. ..常见的选项： -v：将条件取反 –color：突出显示结果 -w：单词匹配 -c：统计匹配行数 简单正则表达式： ^word：查找以word开头 word$：查找以word结尾 ^$：查找空行 -E：支持使用扩展正则表达式（egrep）1234 grep &quot;abc&quot; abc //在abc文档中找有abc字符串的行grep &quot;ab&quot; abc //在abc文档中找有ab字符串的行 grep &quot;^ab&quot; abc //在abc文档中找以ab字符串开头的行 grep &quot;ab$&quot; abc //在abc文档中找以ab字符串结尾的行 找到的内容还可以利用重定向保存到文件中重定向 &gt;， &gt;&gt;123echo 123 &gt; xyz.txt //喊出123 覆盖保存在文件xyz.txt中，如果xyz.txt中之前有内容，将会被覆盖echo 123 &gt;&gt; xyz.txt //喊出123 追加保存在文件xyz.txt中，不会覆盖原有内容grep &quot;sbin&quot; /etc/man_db.conf &gt; /root/out.txt //使用grep在man_db.conf 文件中搜索到的包含sbin的行都保存到 out.txt文件中 tar归档将多个文件合成一个文件，方便保存和管理 ,还可以配合gzip、bzip2 、xz三种压缩工具进行压缩 -c 创建 -f指定文件名 -x 释放 -P 保存原始路径-z 使用gzip方式在归档时压缩，扩展名可以写.gz-j 使用bzip2 方式在归档时压缩，扩展名可以写.bz2-J 使用xz 方式在归档时压缩，扩展名可以写.xz 归档：把很多文件归纳到一起 tar 压缩：减小文件占用空间的大小 gzip、bzip2、xz tar命令的选项： -c：创建新文档 -x：释放备份文档 -f：指定文档名称 -z：处理 .gz 格式 -j：处理 .bz2 格式 -J：处理 .xz 格式 -t：显示文档列表 -p：保持原有权限 -P：保持绝对路径 -C：指定释放备份文件时的目标位置 –exclude=排除的子目录 tar 制作备份文件： tar -zcf 备份文件名.tar.gz 被备份的文档…. tar -jcf 备份文件名.tar.bz2 被备份的文档…. tar -Jcf 备份文件名.tar.xz 被备份的文档…. tar 从备份文件恢复： tar -xf 备份文件名 [-C 目标文件夹] tar 查看备份文件内容： tar -tf 备份文件名 12345yum -y install tar //安装tar工具yum -y install bzip2 //安装压缩工具tar -czPf test.tar.gz /var/log //将/var/log打包压缩成test.tar.gz，使用的压缩方式是gziptar -cjPf test.tar.bz2 /var/logtar -cJPf test.tar.xz /var/log 破解密码123456789//重启 系统，按 e 键打断启动过程//修改 linux 行（ro 改 rw，末尾添加 rd.break）然后按 ctrl+x 启动按ctrl+x //以无需密码的方式启动系统chroot /sysroot/ //切换到根系统echo redhat | passwd --stdin root //改密码touch /.autorelabel //重置selinux标记exitreboot //重启 yum -y install vim net-tools bash-completion //在blue主机安装常用软件包 磁盘的使用123456789101112131415lsblk //查看分区状态fdisk /dev/vdc //使用fdisk分区工具，对/dev/vdc硬盘进行分区p 查询分区状态 q 不保存退出n 新建分区Select (default p): //回车，默认是主分区Partition number (1-4, default 1): //第一个分区默认序号是1First sector ： //起始扇区，直接回车Last sector +500M //创建500M分区w //保存退出mkfs.xfs /dev/vdc1 //使用xfs文件系统为vdc1这个分区格式化mount /dev/vdc1 /mnt //将新分区挂载到/mnt目录df -h umount /dev/vdc1 //卸载分区 调整逻辑卷大小在计算机上使用磁盘空间的过程： 识别磁盘 –&gt; 分区 –&gt; 格式化 –&gt; 挂载 –&gt; 访问挂载点lsblk –&gt; fdisk -l –&gt; fdisk(MSDOS分区表)/gdisk(GPT分区表 &gt;2.2TB磁盘)/parted –&gt; mkfs相关 –&gt; mount –&gt; ls、vim 磁盘分区操作 ——fdisk -lfdisk /dev/vdbparted /dev/vdb 分区模式msdos：四个主分区、扩展分区、逻辑分区分区模式gpt（支持&gt;2T空间）：主分区（操作系统支持一般&lt;128个） 刷新硬盘分区表： partprobe /dev/vdb 或者 partx -a /dev/vdb reboot格式化操作： mkfs.ext3 分区设备 mkfs.ext4 分区设备 mkfs.xfs 分区设备 mkfs.vfat 分区设备逻辑卷管理LVM逻辑卷管理机制 —— 化零（物理卷PV）为整（卷组VG）、动态扩容伸缩，按需（逻辑卷LV）分配 把零散的分区（PV物理设备(物理卷)） ===》整编的大卷组（VG虚拟磁盘） ===》 根据需要获取空间（虚拟分区LV）游击队 ===》 八路军 ===》按需增编/简编人员 识别磁盘 –&gt; 分区 –&gt; 卷组 –&gt; 逻辑卷 –&gt; 格式化 –&gt; 挂载 –&gt; 访问挂载点 实现方式：分区/物理卷（2G、4G、6G） –&gt; 卷组（12G） –&gt; 逻辑卷（10G、1G） LVM管理工具 物理卷操作（不常用）：pvscan、pvdisplay、pvcreate 卷组操作：vgscan(扫描)、vgdisplay（显示）、vgcreate、vgremove、vgextend（扩容） 逻辑卷操作：lvscan、lvdisplay、lvcreate、lvremove、lvextend PE：分配逻辑卷空间的时候，最小的单位,默认为4M 创建卷组： 1vgcreate [-s PE大小] 卷组名 分区.. .. 创建逻辑卷： 12lvcreate -L 大小 -n 名称 卷组名lvcreate -l PE个数 -n 名称 卷组名 扩展逻辑卷： 1lvextend -L +大小 /dev/卷组名/逻辑卷名 扩展卷组： 1vgextend 卷组名 分区.. .. 通知内核新的文件系统大小： 12resize2fs /dev/卷组名/逻辑卷名 //适用于EXT2/3/4文件系统（blkid检查）xfs_growfs 逻辑卷名的挂载点//适用于XFS文件系统（blkid检查） 逻辑卷的设备位置： 123/dev/卷组名/逻辑卷名或者/dev/mapper/卷组名-逻辑卷名 ​​ 1234567891011121314151617181920212223242526272829303132[root@blue ~]# vgscan Reading all physical volumes. This may take a while... Found volume group &quot;myvg&quot; using metadata type lvm2 Found volume group &quot;test&quot; using metadata type lvm2 Found volume group &quot;rhel&quot; using metadata type lvm2[root@blue ~]# pvscan PV /dev/vdb2 VG myvg lvm2 [1008.00 MiB / 208.00 MiB free] PV /dev/vdb1 VG test lvm2 [&lt;2.00 GiB / &lt;1.67 GiB free] PV /dev/vda2 VG rhel lvm2 [&lt;29.00 GiB / 0 free] Total: 3 [&lt;31.98 GiB] / in use: 3 [&lt;31.98 GiB] / in no VG: 0 [0 ][root@blue ~]# lvscan ACTIVE '/dev/myvg/mylv' [800.00 MiB] inherit ACTIVE '/dev/test/vo' [336.00 MiB] inherit ACTIVE '/dev/rhel/swap' [&lt;2.17 GiB] inherit ACTIVE '/dev/rhel/root' [&lt;26.83 GiB] inherit[root@blue ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsr0 11:0 1 1024M 0 rom vda 252:0 0 30G 0 disk ├─vda1 252:1 0 1G 0 part /boot└─vda2 252:2 0 29G 0 part ├─rhel-root 253:0 0 26.8G 0 lvm / └─rhel-swap 253:1 0 2.2G 0 lvm [SWAP]vdb 252:16 0 10G 0 disk ├─vdb1 252:17 0 2G 0 part │ └─test-vo 253:2 0 336M 0 lvm /vo└─vdb2 252:18 0 1G 0 part └─myvg-mylv 253:3 0 800M 0 lvm vdc 252:32 0 10G 0 disk └─vdc1 252:33 0 500M 0 part /mnt[root@blue ~]# 创建卷组逻辑卷 化零为整 更自由的使用磁盘空间 创建逻辑卷之前先要创建卷组，然后从卷组中划分空间给逻辑卷 1234vgcreate /dev/myvg /dev/vdb2 //正常创建卷组，默认扩展单元是4M（不满足目前题意，目前要求是16M）vgdisplay /dev/myvg //可以在PE一栏中看到扩张单元的大小vgremove /dev/myvg //删除卷组myvgvgcreate -s 16MiB /dev/myvg /dev/vdb2 //创建扩展单元为16MiB的卷组（目前练习题要求），之后可以用vgdisplay查看PE的大小 创建逻辑卷123lvcreate -n mylv -L 800M /dev/myvg //正常创建lvcreate -n mylv -l 50 /dev/myvg //按照扩展单元的数量创建（目前练习题要求），之后可以用vgs查看vgs // 查看邏輯卷 创建逻辑卷根据以下要求，创建新的逻辑卷：1） 逻辑卷的名字为mylv，属于myvg卷组，大小为50个扩展单元2） 卷组myvg中的逻辑卷的扩展块大小应当为16MiB3） 使用vfat文件系统将逻辑卷mylv格式化4） 此逻辑卷应当在系统启动时自动挂载到/mnt/mydata目录下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[root@blue ~]# fdisk /dev/vdbWelcome to fdisk (util-linux 2.32.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nPartition type p primary (2 primary, 0 extended, 2 free) e extended (container for logical partitions)Select (default p): Using default response p.Partition number (3,4, default 3): First sector (2074624-20971519, default 2074624): Last sector, +sectors or +size{K,M,G,T,P} (2074624-20971519, default 20971519): +1000MCreated a new partition 3 of type 'Linux' and of size 1000 MiB.Command (m for help): wThe partition table has been altered.Syncing disks.[root@blue ~]# partparted partprobe partx [root@blue ~]# partprobe /dev/vdb[root@blue ~]# vgcreate -s 16MiB myvg /dev/vdb3 Physical volume &quot;/dev/vdb3&quot; successfully created. Volume group &quot;myvg&quot; successfully created[root@blue ~]# lvcreate -l 50 -n mylv myvg Logical volume &quot;mylv&quot; created.[root@blue ~]# lvscan ACTIVE '/dev/myvg/mylv' [800.00 MiB] inherit ACTIVE '/dev/test/vo' [300.00 MiB] inherit ACTIVE '/dev/rhel/swap' [2.16 GiB] inherit ACTIVE '/dev/rhel/root' [&lt;46.84 GiB] inherit[root@blue ~]# vgscan Found volume group &quot;myvg&quot; using metadata type lvm2 Found volume group &quot;test&quot; using metadata type lvm2 Found volume group &quot;rhel&quot; using metadata type lvm2[root@blue ~]# lsblik-bash: lsblik: command not found[root@blue ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsr0 11:0 1 1024M 0 rom vda 252:0 0 50G 0 disk ├─vda1 252:1 0 1G 0 part /boot└─vda2 252:2 0 49G 0 part ├─rhel-root 253:0 0 46.9G 0 lvm / └─rhel-swap 253:1 0 2.2G 0 lvm [SWAP]vdb 252:16 0 10G 0 disk ├─vdb1 252:17 0 500M 0 part │ └─test-vo 253:2 0 300M 0 lvm /vo├─vdb2 252:18 0 512M 0 part [SWAP]└─vdb3 252:19 0 1000M 0 part └─myvg-mylv 253:3 0 800M 0 lvm vdc 252:32 0 10G 0 disk [root@blue ~]# mkfs.vfat /dev/myvg/mylv -bash: mkfs.vfat: command not found[root@blue ~]# yum -y install dosfstoolsUpdating Subscription Management repositories.Unable to read consumer identity.......[root@blue ~]# mkfs.vfat /dev/myvg/mylv mkfs.fat 4.1 (2017-01-24)[root@blue ~]# vim /etc/fstab [1]+ Stopped vim /etc/fstab[root@blue ~]# mkdir /mnt/mydata[root@blue ~]# fgvim /etc/fstab[root@blue ~]# mount -a[root@blue ~]# dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 483592 0 483592 0% /devtmpfs 501328 0 501328 0% /dev/shmtmpfs 501328 6880 494448 2% /runtmpfs 501328 0 501328 0% /sys/fs/cgroup/dev/mapper/rhel-root 49087060 1765620 47321440 4% //dev/vda1 1038336 163540 874796 16% /boot/dev/mapper/test-vo 301728 12732 288996 5% /votmpfs 100264 0 100264 0% /run/user/0/dev/mapper/myvg-mylv 817584 4 817580 1% /mnt/mydata[root@blue ~]# 逻辑卷扩容12345lvextend -L 300M /dev/test/vo //将名字叫vo的逻辑卷扩容到300Mblkid /dev/test/vo //查看vo逻辑卷的文件系统lsblk //再查看该逻辑卷的挂载点xfs_growfs /vo //刷新大小，如果是xfs的文件系统resize2fs /vo //刷新大小，如果是ext的文件系统 交换分区相当于win的虚拟内存，在物理内存不足时借用硬盘空间,硬盘中预先划分一定的空间，然后将把内存中暂时不常 用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的， 速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源. 交换分区：虚拟内存，一般设置成物理内存的1~2倍，&lt;16G 格式化交换分区 1234567swapon -s //查询交换分区状态，通常有可能会存在个默认的交换分区，不能删除先用fdisk /dev/vdb //再创建一个512M的分区比如创建了vdb3mkswap /dev/vdb3 //格式化交换分区vim /etc/fstab //修改开机挂载磁盘的文件/dev/vdb3 swap swap defaults 0 0swapon -a //测试上述文件是否修改正确swapon -s //再次查看会多出swap分区 启用/停止控制： 12swapon 设备路径swapoff 设备路径 查看交换分区使用情况： 12swapon -sfree 添加交换分区为你的系统额外添加一个512MiB的交换分区，此交换分区应在系统启动时自动挂载，不要删除或以任何方式改动系统上原有的交换分区。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[root@blue ~]# fdisk /dev/vdbWelcome to fdisk (util-linux 2.32.1).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nPartition type p primary (1 primary, 0 extended, 3 free) e extended (container for logical partitions)Select (default p): Using default response p.Partition number (2-4, default 2): First sector (1026048-20971519, default 1026048): Last sector, +sectors or +size{K,M,G,T,P} (1026048-20971519, default 20971519): +512MCreated a new partition 2 of type 'Linux' and of size 512 MiB.Command (m for help): wThe partition table has been altered.Syncing disks.[root@blue ~]# partparted partprobe partx [root@blue ~]# partparted partprobe partx [root@blue ~]# partprobe /dev/vdvda vda1 vda2 vdb vdb1 vdb2 vdc [root@blue ~]# partprobe /dev/vdb[root@blue ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsr0 11:0 1 1024M 0 rom vda 252:0 0 50G 0 disk ├─vda1 252:1 0 1G 0 part /boot└─vda2 252:2 0 49G 0 part ├─rhel-root 253:0 0 46.9G 0 lvm / └─rhel-swap 253:1 0 2.2G 0 lvm [SWAP]vdb 252:16 0 10G 0 disk ├─vdb1 252:17 0 500M 0 part │ └─test-vo 253:2 0 300M 0 lvm /vo└─vdb2 252:18 0 512M 0 part vdc 252:32 0 10G 0 disk [root@blue ~]# mkswap /dev/vdvda vda1 vda2 vdb vdb1 vdb2 vdc [root@blue ~]# mkswap /dev/vdvda vda1 vda2 vdb vdb1 vdb2 vdc [root@blue ~]# mkswap /dev/vdb2Setting up swapspace version 1, size = 512 MiB (536866816 bytes)no label, UUID=ac1a1ba6-7f1a-4b92-80bc-11836d4236c0[root@blue ~]# vim /etc/fstab 1234567[root@blue ~]# swapon -a[root@blue ~]# swapon -sFilename Type SizeUsed Priority/dev/dm-1 partition 2265084 0 -2/dev/vdb2 partition 524284 0 -3[root@blue ~]# VDO卷虚拟数据优化器，可以对数据进行重删过滤,VDO（Virtual Data Optimize）是RHEL8/Centos8上新推出的一个存储相关技术（最早在7.5测试版中开始测试），是Redhat收购的Permabit公司的技术。VDO的主要作用是节省磁盘空间，比如让1T的磁盘能装下1.5T的数据，从而降低数据中心的成本。那vdo是如何实现的呢，关键原理主要是重删和压缩，重删就是硬盘里拷贝来相同的数据，以前要占多份空间，现在只需要1份空间就可以了。类似我们在百度网盘中上传一个大型软件安装包，能实现秒传，其实是之前就有，所以无需再传一遍，也无需再占百度一份空间。另一方面是数据压缩，类似于压缩软件的算法，也可以更加节省磁盘空间。VDO是一个内核模块，目的是通过重删减少磁盘的空间占用，以及减少复制带宽，VDO是基于块设备层之上的，也就是在原设备基础上映射出mapper虚拟设备，然后直接使用即可，功能的实现主要基于以下技术。 1）零区块的排除：在初始化阶段，整块为0的会被元数据记录下来，这个可以用水杯里面的水和沙子混合的例子来解释，使用滤纸（零块排除），把沙子（非零空间）给过滤出来，然后就是下一个阶段的处理。 2）重复数据删除：在第二阶段，对于输入的数据会判断是不是冗余数据（在写入之前就判断），这个部分的数据通过UDS内核模块来判断（Universal Deduplication Service），被判断为重复数据的部分不会被写入，然后对元数据进行更新，直接指向原始已经存储的数据块即可。 + 3）压缩：一旦消零和重删完成，LZ4压缩会对每个单独的数据块进行处理，然后压缩好的数据块会以固定大小4KB的数据块存储在介质上，由于一个物理块可以包含很多的压缩块，这个也可以加速读取的性能。 123456789yum -y install vdo //装包systemctl restart vdo //启动服务，并设置开机自启找到vdc磁盘（此盘之前不能有配置）man vdo //搜索 /example ，在例子中查找相关配置命令 vdo create --name=vdo0 --device=/dev/sdb1 --vdoLogicalSize=10T //然后按题目稍作修改，name是vdo卷的名称，device是使用哪个物理磁盘，最后是定义虚拟磁盘大小格式化 mkfs.xfs -K /dev/mapper/myvdo // `-K可以加快速度`设置/etc/fstab文件，并且使用mount -a检测/dev/mapper/myvdo /vblock xfs _netdev 0 0 // _netdev的作用是等待网络相关程序启动后再执行挂载任务，通常网络启动之后vdo服务也就起来了，就可以挂载了 vdo基本操作： vdo create –name=VDO卷名称 –device=设备路径 –vdoLogicalSize=逻辑大小 vdo list vdo status -n VDO卷名称 vdostats [–human-readable] [/dev/mapper/VDO卷名称] vdo remove -n VDO卷名称 系统调优使用tuned服务,RHEL7/8的调优服务tuned：提供了大量预设的调优方案，旨在于简化调优的实施，充分利用系统资源与能效。管理员可以针对不同的业务选择不同的优化策略 12345tuned-adm 命令直接回车 可以看到选项提示信息tuned-adm list //列出可用的优化方案tuned-adm recommend 查询建议的优化方案tuned-adm profile XXXXX 使用某优化方案tuned-adm active 查看当前使用的优化方案 CocKpit驾驶舱于SSH类似，用于远程控制，类似于阿里云的控制台。为初级管理员提供基本操作，通过web端的控制台，访问地址：服务器IP:9090 yum包安装并开启服务： 123yum -y install cockpit cockpit-dashboard cockpit-machinessystemctl enable cockpit.socket --now Web浏览器访问 https://虚拟机的IP地址:9090：本机访问虚拟机的cockpit：本机的虚拟机网卡的ip要和虚拟机的网卡ip设置为同一个网段的才可以访问。 实战","link":"/2020/11/14/Linux%E7%BA%A2%E5%B8%BD%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/"},{"title":"企业级网络架构(搭建)学习笔记(网管)","text":"技不压身，了解下企业级网络的搭建，虽然偏硬件，但是有利于知识体系的构建。和学TCP/IP协议时的一些东西互通，同时为以后回老家当网管做准备，哈哈，生活加油！是一起参加红帽考试的小伙伴分享的资源，然后稍作整理，时间原因，这篇笔记后面部分没有实际敲Demo，先知道个大概，以后涉及到这方面在深入研究，补充一些实战的东西。 写在前面 技不压身，了解下企业级网络的搭建，虽然偏硬件，但是有利于知识体系的构建。和学TCP/IP协议时的一些东西互通，同时为以后回老家当网管做准备，哈哈，生活加油！是一起参加红帽考试的小伙伴分享的资源，然后稍作整理，时间原因，这篇笔记后面部分没有实际敲Demo，先知道个大概，以后涉及到这方面在深入研究，补充一些实战的东西。 另：如果想详细的了解HTTP、TCP/IP 等协议，小伙伴可以看看这几篇博客： 《图解TCP/IP》读书笔记《图解HTTP》读书笔记 一、计算机硬件、在线攒机显示器 (输出设备) 屏幕尺寸：20.1寸、27寸、32寸… 一寸=2.54cm #计算方式： 显示器和电视机都是采用测试对角线的方式来定义的. 分辨率： 1280x720 高清、1920x1080 全高清、3840x2160 超高清 接口： HDMI：高清晰度多媒体(音频+视频) 接口 老式显示接口：DVI (视频数字接口)、VGA (视频图阵接口)键盘、鼠标（输入设备）鼠标接口： PS2 圆口 不支持热插拔； USB 扁口 支持热插拔； 无线收发主机 (核心)一台计算机的最核心构件：容纳处理器、内存、磁盘等计算和存储元件；提供人机交互的各种输入/输出接口；主机的组成： CPU处理器；CPU(Central Processing Unit)，中央处理器是整个计算机运算与控制的核心,CPU性能指标： 核心数：单核、双核、四核、八核等； 线程数：四线程、八线程、等； 主频：2.8GHz、3.4GHz、3.9GHz、、4.2GHz等； 缓存：3.0MB、6.0MB、8.0MB、20MB等；1234CPU ( 缓存 ) &lt;——&gt; 内存 &lt;——&gt; 硬盘:cpu不能直接处理硬盘中的数据，需要先将硬盘中的数据读取内存中，然后再从内存中读取数据；为了提高处理效率，在CPU中也有一个缓存区，处理数据时，先将内存里的数据读取CPU的缓存中，CPU处理完自己的内容后，直接从自己的CPU缓存中读取数据，CPU缓存继续从内存中读取数据，内存再从硬盘中读取数据，循环往复。 CPU的散热方式：风冷、水冷、液冷； 内存： 内部存储器：用于暂时存放CPU中的程序运算数据，以及与硬盘等外部存储器交互的数据主要指标： 容量：4G、8G、16G 频率：DDR3 8002133MHz、DDR4 2133 2666MHz 主板；也称主机板、系统板：集成了计算机的主要电路系统；提供一系列芯片及扩展槽以连接其他配件；主要指标： 芯片组（Inter、AMD、NVIDIA）; 主板尺寸 (标准型、紧凑型、迷你型) 显卡、声卡、网卡；处理图像、音频、网络数据的专用设备：通常由主板集成，有特殊需求也可独立配备 (性能更优)；主要指标： 显存大小(1G, 2G, 4G) 、显卡接口 (AGP、PCI-E)； 网卡速度 (百兆、千兆)、双网口、无线网卡 硬盘、光驱；硬盘 主要的外接存储器，光驱 用来读取光盘介质的驱动器设备(已经淘汰，不再使用：DVD ROM 只读光驱；DVD RW 刻录机；DVD 移动(USB接口) 刻录机)，硬盘属性： 容量 (500GB、1TB、2TB、4TB)； 转速（5400、7200、10000）； 类型（SATA、SSD固态） 机箱及电源；机箱用来固定主板、硬盘、光驱及各种扩展卡；电源及风扇用来提供能源及散热 主板BLOS设置；Basic Input/Output System 基本输入输出系统固化在主板的一个芯片中，用于加电自检/初始化计算机； 进入BlOS设置的方法根据计算机加电后的提示操作，通常为 Del键或 F2 键 常见的BLOS设置 开启虚拟化支持、设置启动顺序、设置安全密码； 清除BLOS自定义设置；​​​​​​​​ 在线攒机浏览器中输入在线攒机即可：例如：http://zj.zol.com.cn/ 二、网络概述什么是计算机网络 硬件方面：通过线缆将网络设备和计算机连接起来； 软件方面：操作系统，应用软件，应用程序通过通信线路互联；作用： 实现资源共享，信息传递，增加可靠性，提高系统处理能力标准化组织ISO（国际标准化组织）；IEEE（电气和电子工程师协会）WAN与LANWAN（广域网):范围：几十到几千千米；作用：用于连接远距离的计算机网络；应用：Internet；LAN(局域网)：范围：1km左右；作用：用于连接较短距离内的计算机；应用：企业网，校园网；网络设备生产厂商华为；Cisco(思科)路由交换设备 路由器(Router)； 交换机(Switch)； 网络拓扑结构 点对点拓扑结构：两台设备之间有一条单独的连接；作用：专用于广域网中连接两台路由器； 星型拓扑： 优点：易于实现；易于网络扩展；易于故障排查； 缺点：中心节点压力大；组网成本较高 网状拓扑结构：一个节点与其他节点相连； 优点：提供冗余性和容错性；可靠性高； 缺点：组网成本高； 三、OSI参考模型OSI 七层模型分层思想：梳理网络体系，便于相关人员能够更精确的定位到问题所在将复杂的流程分解，复杂问题简单化；更容易发现问题并针对性的解决问题 国际标准化组织 ( ISO )：规定将网络分为七层，从下往上依次是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层 OSI理论七层模型更多见博客： https://blog.csdn.net/sanhewuyang/article/details/86369071 应用层：为应用程序提供服务并规定通信相关的细节，针对特定应用的协议，包括文件传输，电子邮件，远程登录等协议。 表示层：将应用处理的信息转换为适合网络传输的格式，或者将下一层的数据转化为上一层能够处理的格式，主要负责数据格式的转换。将设备固有的数据格式转换为网络标准传输格式，不同设备对同一比特流的解释可能不同，使他们保持一致。 会话层：通信管理，负责建立和断开通信连接(数据流动的逻辑通路)，管理传输层以下的分层，以及数据的分割等数据传输相关的管理。(何时建立/断开连接，保持多久的连接) 传输层：起着可靠传输的作用，只在通信双方节点上进行处理（确保数据被可靠的传输送到目标地址），无需路由器上处理。 网络层：将数据传输到目标地址，目标地址可以是多个网络通过路由器连接的而成的某一个地址，负责寻址和路由选择。（经过那个路由传递到目标地址） 数据链路层：负责物理层面上的互连的，节点之间的通信出传输，将0，1序列划分为具有意义的数据帧传送给对端(数据帧 的生成与接收，数据帧与比特流的之间的准换) 物理层：负责0,1比特流与电压高低，光的闪灭之间的互换，界定连接器与网络的规格。 TCP/IP 五层模型 应用层： 上层数据 —–》 计算机 HTTP, FTP, TFTP, SMTP, SNMP, DNS 传输层： 数据段 —–》 防火墙TCP, UDP 网络层： 数据包 —–》 路由器 ICMP, IGMP, IP, ARP 数据链路层： 数据帧 —–》 交换机 VLAN, TRUNK, MSTP 物理层： 比特流 —–》 网卡123456# HTTP协议：超文本传输协议,例：互联网的访问;# FTP协议：文件传输协议，例：文件的共享与互相传递；# TFTP协议：简单的文件传输协议，例：只能传递小文件，文件的大小以KB来衡量；# SMTP协议：电子邮件传输协议，例：发送邮件；# SNMP协议：简单网络管理协议，例：远程控制；# DNS协议：域名解析协议，将IP地址解析为域名，例：www.baidu.com（域名） 什么是协议:为了使数据可以在网络上从源传递到目的地，网络上所有设备需要“讲”相同的“语言”；描述网络通信中“语言”规范的一组规则就是协议常用的以太网接口 RJ-11: 四根线序，连接电话； RJ-45: 八根线序，最常用的规范（廉价稳定）；线序的类型 T568A: 白绿，绿，白橙，蓝，白蓝，橙，白棕，棕 T568B: 白橙，橙，白绿，蓝，白蓝，绿，白棕，棕 标准网线(直通线)：12T568A --------------- T568AT568B --------------- T568B 交叉网线(交叉线)：1T568A --------------- T568B 线序的选择 直通线：线缆两头的线序相同； 交叉线：线缆两头的线序不同； 有交换机时用直通线 ( 一条线连接的两台设备 )； 没有交换机时用交叉线 ( 一条线连接的两台设备 )； 双绞线（网线）目前使用最广，价格相对便宜的一种传输介质；由两根绝缘铜导线相互缠绕组成，以减少对邻近线的电气干扰； 双绞线的标准：|类型| 传输速率||–|–||cat5 |100Mbps||cat5e| 100Mbps||cat6 |1000Mbps ——&gt; 服务器||cat7 |10000Mbps —–&gt; 使用需要万兆网卡，少用| 中继器（物理层设备）放大信号；延长网络传输距离；网线一般不要超过150米，否则会丢失数据，可以加一个中继器。数据封装和解封装协议数据单元 (PDU) 设备与层的对应关系 应用层： 上层数据 —–》 计算机 HTTP, FTP, TFTP, SMTP, SNMP, DNS 传输层： 数据段 —–》 防火墙TCP, UDP 网络层： 数据包 —–》 路由器 ICMP, IGMP, IP, ARP 数据链路层： 数据帧 —–》 交换机VLAN, TRUNK, MSTP 物理层： 比特流 —–》 网卡 四、IP地址分类IP地址的组成IP地址由32个二进制数构成。总体上可以分为两部分：网络位＋主机位；为了方便表示，人为地，将8位换算成10进制数，共4段。4段数字用小数点分隔，称作点分10进制的表示方式； 相同的网络，网络部分相同；主机部分一定不同； 不同的网络，网络部分一定不同；主机部分可以相同；子网掩码：用于判定一个IP地址的网络部分和主机部分；网络部分全写为1，主机部分写为0；1对应的部分是网络，0对应的部分是主机；IP地址分类 A类： 1 - 127 网络位+主机位+主机位+主机位 255.0.0.0 （127常用于表示本机） B类： 128 - 191 网络位+网络位+主机位+主机位 255.255.0.0 C类： 192 - 223 网络位+网络位+网络位+主机位 255.255.255.0 D类： 用于多播，也叫组播 E类：保留私有IP地址(网段) A：10.0.0.0/8 /8表示网络位是8位 10.0.0.1 ~ 10.255.255.255 B：172.16.0.0 - 172.31.0.0/16 176.16.0.1 ~ 176.31.255.255 C：192.168.0.0/24 192.168.0.1 ~ 192.168.255.255五、windows网络配置查看当前网络的IP地址信息选择“网络” ——&gt; 右键 “属性” ——&gt; 选择“更改适配器设置” ——&gt; 双击“以太网”或者“WLAN” 或者其他虚拟网卡(必须是已经启用或者能够已连接的) ——&gt; 点击“详细信息 windows系统的常用操作 打开命令提示符： 点击搜索，输入“cmd” 或者使用快捷方式 “Windows”徽标键 + “R” 打开运行界面，输入“cmd”; 查看网卡信息：输入 ipconfig ; 验证网络连通性： ping IP地址 —&gt; (例如：ping 127.0.0.1(自己ping自己) 或者验证能否连通外网:ping www.baidu.com) 修改网卡的IP地址首先，按照 P3.1 操作，显示出所有的网卡；然后，选择一个要修改的网卡 ( 例如：以太网 )，右键“属性”；再次，双击 “Internet 协议版本4 (TCP/IPV4)”;最后，选择 “使用下面的IP 地址” 配置 IP地址，子网掩码和网关； 六 、交换机的命令行视图华为交换机的命令行 123456789&lt;Huawei&gt; #用户视图&lt;Huawei&gt;system-view #进入系统视图[Huawei] #系统视图[Huawei]interface Ethernet 0/0/1 #进入接口视图#interface: 接口，Ethernet: 接口类型，0/0/1: 第一个“0”代表槽位号，第二个“0”代表子卡号，最后一个“1”代表接口号[Huawei-Ethernet0/0/1] #接口视图[Huawei]ospf #进入协议视图[Huawei-ospf-1] #协议视图#在系统视图下，输入相关路由协议命令即可进入路由协议视图 命令行的层次关系1234用户视图 #查看运行状态或其他参数 系统视图 #配置设备的系统参数等 接口视图 #配置接口参数 协议 #配置路由协议 视图间的转换1234567891011&lt;Huawei&gt; #用户视图&lt;Huawei&gt;system-view #进入系统视图[Huawei] #系统视图[Huawei]quit #退出系统视图，一次只能退一层&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei][Huawei]interface Ethernet 0/0/1 #由系统视图进入到接口视图[Huawei-Ethernet0/0/1] #接口视图[Huawei-Ethernet0/0/1]return #直接退回到最初的用户视图下，快捷键 “Ctrl + Z”&lt;Huawei&gt; 七、交换机的基本配置配置主机名12345#主机名的配置必须在系统视图模式下进行&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]sysname yunduan #更改设备的名字[yunduan] 显示VRP的版本信息1&lt;Huawei&gt;display version 查看交换机的所有配置1234&lt;Huawei&gt;&lt;Huawei&gt;display current-configuration&lt;Huawei&gt;system-view #进入系统视图[Huawei]display current-configuration 使用账户和密码登录终端123456789101112131415&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei][Huawei]aaa #进入aaa模式，此模式下才可以设置用户名和登录密码[Huawei-aaa]local-user admin01 password cipher 123 #设置用户名和密码(加密的，安全性更高)[Huawei-aaa]display this #查看aaa模式做过哪些配置[Huawei-aaa]undo local-user admin01 #删除创建的用户，可以不操作[Huawei-aaa]quit #退回到系统视图[Huawei] #此时用户名密码并没有生效，需要进入console 0来通过aaa认证[Huawei]user-interface console 0 #进入console 0 接口[Huawei-ui-console0]authentication-mode aaa #通过aaa认证[Huawei-ui-console0]return #返回到用户模式下&lt;Huawei&gt;save #保存配置，保证重启后仍然有效&lt;Huawei&gt;reboot #重启交换机验证，或者Ctrl + ]使用这个，不用重启就可以验证 保存交换机的配置12#我们之前在交换机上做的配置，交换机并不会给我们永久保存，重启后所有配置失效，需要在用户视图下保存配置&lt;Huawei&gt;save #永久保存配置信息，只能在用户视图下进行 恢复设备出厂默认值1234567891011121314&lt;Huawei&gt;reset saved-configuration #恢复出厂默认值Warning: The action will delete the saved configuration in the device.The configuration will be erased to reconfigure. Continue? [Y/N]: y #询问你是否确认操作，y是同意的意思&lt;Huawei&gt;reboot #重启设备Info: The system is now comparing the configuration, please wait.Warning: All the configuration will be saved to the configuration file for the next startup:, Continue?[Y/N]: n#第一次的提示，警告所以的配置会被保存到配置文件，下次重启会再次加载以前的配置文件，所以要选择 n,否则会报错Info: If want to reboot with saving diagnostic information, input 'N' and then execute 'reboot save diagnostic-information'.System will reboot! Continue?[Y/N]: y#第二条信息提示我们，系统将被重启，是否继续，选择 y 同意，设备将进入重启状态 避免自动退出配置界面1234567#空闲一段时间后(默认控制台会话时间为10分钟)#配置控制台会话时间(避免老是进入自动待机状态)&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]user-interface console 0 #进入console 0 接口[Huawei-ui-console0]idle-timeout 100 #设置控制台会话时间（100分钟）[Huawei-ui-console0]display this #查看当前接口下做的配置(必须切换到对应的接口) 常用技巧更改语言为中文1&lt;Huawei&gt;language-mode Chinese #用户视图下 信息不提示命令123456789101112131415#取消控制台的错误，日志等各种提示信息&lt;Huawei&gt;undo terminal debugging&lt;Huawei&gt;undo terminal monitor&lt;Huawei&gt;undo terminal logging&lt;Huawei&gt;undo terminal trapping&lt;Huawei&gt;system-view #进入系统视图，测试#华为模拟器支持命令的批量执行，一起执行上述命令，在用户视图下，复制，粘贴，即可一键运行undo terminal debuggingundo terminal monitorundo terminal loggingundo terminal trappingsystem-view#让华为设备命令行不输出任何的提示信息&lt;Huawei&gt;system-view[Huawei]undo info-center enable 配置设备永不自动关机1234&lt;Huawei&gt;[Huawei]system-view[Huawei]user-interface console 0[Huawei]idle-timeout 0 #0代表会话一直存在(不推荐使用，有安全风险) 查看系统配置信息12345678&lt;Huawei&gt;[Huawei]system-view #切换系统视图[Huawei]display current-configuration #查看当前设备的所有配置配置[Huawei]interface Ethernet0/0/1[Huawei-Ethernet0/0/1]display this #查看ethernet 0/0/1 接口下都做过哪些配置[Huawei]user-interface console 0[Huawei-ui-console0]display this #查看console 0接口下都做过哪些配置#注：此条命令适用于其他所有的接口视图模式，前提必须进入相应的接口或视图 查看当前设备简要的接口信息123&lt;Huawei&gt;&lt;Huawei&gt;system-view #系统视图下进行[Huawei]display interface brief 查看历史命令12&lt;Huawei&gt;&lt;Huawei&gt;display history-command #必须是在用户视图下 查看MAC地址表12&lt;Huawei&gt;&lt;Huawei&gt;display mac-address #用户视图下使用 八、数据链路层 以太网MAC地址用来识别一个以太网上的某个单独的设备或一组设备。 以太网帧格式数据链路层的协议数据单元 什么是交换机 交换机是用来连接局域网的主要设备 交换机能够根据以太网帧中目标地址智能的转发数据，因此交换机工作在数据链路层交换机转发原理 初始状态(一无所知)； MAC地址学习(将源地址记录到MAC地址表中)； 广播未知数据帧(广播目的地址，接收方回应，交换机记录接收方的源MAC地址到MAC地址表中) 交换机的工作原理 学习–》MAC地址表是交换机通过学习接收的数据帧的源MAC地址来形成的； 广播–》如果目标地址在MAC地址表中没有，交换机就向发送该数据帧的接口外的其他所有接口广播该数据帧； 转发–》交换机根据MAC地址表单播转发数据帧； 更新–》交换机MAC地址表的老化时间是300秒，交换机如果发现一个帧的源接口和MAC地址表中的源MAC地址的所在接口不同，交换机将MAC地址重新学习到新的接口；注意：断电，拔网线，过300秒都会使MAC地址表变化查看MAC地址表 12&lt;Huawei&gt;&lt;Huawei&gt;display mac-address #用户视图下使用 VLAN：交换机按照其端口区分了多个网段,从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。,然而异构的两个网段之间,就需要利用具有路由功能的交换机(如3层交换机),或在各段中间通过路由器的连接才能实现通信。 九、VLAN技术与应用广播域广播域指接收同样广播消息的节点的集合：在该集合中的任何一个节点传输一个广播帧，则其他所有能接收到这个帧的节点都被认为是该广播帧的一部分；交换机的所有接口默认属于同一个广播域； VLAN概述什么是VLAN:Virtual LAN(虚拟局域网)是物理设备上连接的不受物理位置限制的用户的一个逻辑组；为什么引入VLAN:交换机的所有接口默认属于同一个广播域；随着接入设备的增多，网络中广播增多，降低了网络的效率；为了分割广播域，引入了VLAN VLAN的作用 广播控制； 增加安全性； 提高带宽利用； 降低延迟静态VLAN的配置VLAN的最大数量(默认)：4096个(vlan0默认保留，从vlan1开始，vlan1是默认存在的，所有接口默认属于vlan1)配置VLAN的步骤 创建VLAN； 将接口加入到相应的VLAN中； 验证查看VLAN 123&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]display vlan #查看当前设备下定义了哪些vlan，vlan下都有哪些接口 创建单个VLAN12345&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]vlan 10 #创建vlan 10[Huawei-vlan10]quit #创建后会默认进入vlan10中，退出即可[Huawei]display vlan #查看我们创建的vlan 批量创建VLAN12345&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]vlan batch 10 15 20 #同时创建多个不连续的vlan[Huawei]vlan batch 30 to 35 #同时创建多个连续的vlan[Huawei]display vlan #验证我们的创建结果 删除VLAN1234567&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]display vlan #查看设备下都有哪些vlan[Huawei]undo vlan 10 #删除vlan 10[Huawei]undo vlan batch 10 15 #删除vlan 10和vlan 15[Huawei]undo vlan batch 30 to 35 #删除30到35之间的vlan[Huawei]display vlan #验证我们的操作 将接口加入VLAN 首先将接口视图的类型修改成 access; 然后再将接口加入到 VLAN中 将单个接口加入到vlan12345678&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]interface ethernet 0/0/1 #进入接口视图[Huawei-ethernet0/0/1]port link-type access #修改接口视图的类型为access[Huawei-ethernet0/0/1]port default vlan 2 #将接口ethernet 0/0/1加入到vlan 2中[Huawei-ethernet0/0/1]undo port default vlan #将接口从vlan中删除[Huawei-ethernet0/0/1]undo port link-type[Huawei]display vlan #验证我们的操作 将不连续多个接口加入到vlan12345678#将不连续的端口加入到vlan2,首先创建端口组，再对端口进行配置：&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]port-group 1 #接口组的组号可以自己定义，1或2或3或4等等[Huawei-port-group-1]group-member ethernet0/0/2 ethernet0/0/5 #将接口加入到接口组中[Huawei-port-group-1]port link-type access #修改接口视图的类型为access[Huawei-port-group-1]port default vlan 2 #将接口组中所有的接口加入到vlan 2中[Huawei]display vlan #验证我们的操作 将连续多个接口加入到vlan123456789#将连续的端口加入到vlan 3中,首先创建端口组，再对端口进行配置：&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]port-group 2 #接口组的组号可以自己定义，1或2或3或4等等[Huawei-port-group-2]group-member ethernet0/0/2 to ethernet0/0/5#将接口加入到接口组中[Huawei-port-group-2]port link-type access #修改接口视图的类型为access[Huawei-port-group-2]port default vlan 3 #将接口组中所有的接口加入到vlan 4中[Huawei]display vlan #验证我们的操作 十、Trunk中继链路Trunk出现的原因：接入链路只能实现一个vlan通信，终极链路可以实现多个vlan通信。 Trunk概念和特点trunk干道类型，一般应用在交换机和交换机相连的接口上；特点： 用在交换机之间，可以实现不同交换机上相同VLAN通信; 中继链路不属于任何VLAN; 中继链路可以承载所有VLAN的数据;Trunk的配置首先，进入端口后修改端口链路类型,然后，为已经修改为Trunk模式的端口添加允许的VLAN,注意：Trunk的配置是在交换机的接口上配置的，配置的接口为连接两台交换机的线缆的接口，两台交换机都得配置12345&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]interface Ethernet0/0/1 #进入接口视图[Huawei-Ethernet0/0/1]port link-type trunk #接口中修改链路类型魏trunk[Huawei-Ethernet0/0/1]port trunk allow-pass vlan all #允许这个接口可以通过所有的vlan 链路聚合功能也叫以太通道, 如果交换机之间只有一条线路，这条链路可能成为网络的瓶颈;可以在交换机之间再增加额外的链路，使多条链路成为一个逻辑链路; 多条线路负载均衡，提高带宽 容错，当一条线路失效时，不会造成全网中断十一、链路聚合的配置初始化接口123456789&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]clear configuration interface Ethernet 0/0/1 #清除e 0/0/1的自定义配置,让接口回复到初始状态[Huawei]display interface brief #查看接口 e 0/0/1 的状态，接口必须是up（开启状态）#如果e 0/0/1 的接口状态为down(关闭状态，则需要手动开启)[Huawei]interface Ethernet0/0/1 #进入接口视图[Huawei-Ethernet0/0/1]undo shutdown #不关闭接口，即开启接口[Huawei-Ethernet0/0/1]quit #返回到系统视图下[Huawei]display interface brief #再次确认接口状态 创建链路聚合接口(即虚拟接口)12345&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]interface Eth-Trunk 1 #进入的同时会自己先创建链路聚合接口[Huawei-Eth-Trunk1]quit #返回系统视图[Huawei]display interface brief #可以看到新创建的链路聚合接口 将通过vlan的接口加入到链路聚合接口中123456789101112131415#首先，先将ethernet 0/0/1 接口加入到链路聚合接口中[Huawei]interface Ethernet0/0/1 #进入接口视图[Huawei-Ethernet0/0/1]eth-trunk 1 #将e 0/0/1接口加入eth-trunk 1中[Huawei-Ethernet0/0/1]quit[Huawei]display interface brief #确认是否加入#其次，再将ethernet 0/0/2 接口也加入到链路聚合接口中[Huawei]interface Ethernet0/0/2 #进入接口视图[Huawei-Ethernet0/0/1]eth-trunk 1 #将e 0/0/2接口加入eth-trunk 1中[Huawei-Ethernet0/0/1]quit[Huawei]display interface brief #确认e 0/0/2接口也加入到 eth-trunk 1中#还可以通过另一种方式将接口加入到链路聚合接口中&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]interface Eth-Trunk 1 #进入链路聚合接口[Huawei-Eth-Trunk1]trunkport Ethernet 0/0/1 0/0/2 检查1display this 十二、拓扑结构练习 第一步：设计好网络拓扑结构 第二步：配置IP地址和子网掩码,在每台电脑上配置相应的IP地址和子网掩码 第三步：在交换机上配置vlan并将接口加入到相应的vlan中（LSW1 和 LSW2 都要做） 12345678910111213&lt;Huawei&gt;system-view[Huawei]vlan batch 2 to 3 #创建vlan 2 和vlan 3[Huawei]display vlan #验证结果[Huawei]port-group 1 #接口组的组号可以自己定义，1或2或3或4等等[Huawei-port-group-1]group-member ethernet0/0/3 to ethernet0/0/4 #将接口加入到接口组中[Huawei-port-group-1]port link-type access #修改接口视图的类型为access[Huawei-port-group-1]port default vlan 2 #将接口组中所有的接口加入到vlan 2中[Huawei]display vlan #验证我们的操作[Huawei]port-group 2[Huawei-port-group-2]group-member ethernet0/0/5 to ethernet0/0/6[Huawei-port-group-2]port link-type access[Huawei-port-group-2]port default vlan 3[Huawei]display vlan #验证我们的操作 如果交换机之间只有一条线，则需要配置中继链路，执行第四步操作；如果交换机要提高传输速率，和安全性，则需要配置聚合链路，执行第五步操作； 第四步：配置中继链路，让所有的vlan 都可以通过交换机之间的一条线路进行通信（LSW1 和 LSW2都要做） 123456789#在交换机相互连接的接口上配置，我这里都是 Ethernet 0/0/7&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]interface Ethernet0/0/7 #进入接口视图[Huawei-Ethernet0/0/7]port link-type trunk #接口中修改链路类型魏trunk[Huawei-Ethernet0/0/7]port trunk allow-pass vlan all #允许这个接口可以通过所有的vlan&lt;Huawei&gt;save #存盘#配置完成，用ping命令测试 第五步：配置聚合链路，将两条线路捆绑起来，提高带宽和安全性（LSW1 和 LSW2 都要做）123456789101112131415#交换机之间增加了一条网线，两端接口均为 Ethernet 0/0/8&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图[Huawei]clear configuration interface Ethernet 0/0/7 #如果接口上之前做了配置，先清空接口信息[Huawei]interface Ethernet0/0/7[Huawei-Ethernet0/0/7]display this #发现shutdown，接口关闭，需要开启[Huawei-Ethernet0/0/7]undo shutdown #开启接口[Huawei]interface Eth-Trunk 1 #进入的同时会自己先创建链路聚合接口[Huawei-Eth-Trunk1]trunkport Ethernet 0/0/7 0/0/8 #将两个接口一起加入Eth-Trunk1中[Huawei-Eth-Trunk1]port link-type trunk[Huawei-Eth-Trunk1]port trunk allow-pass vlan all[Huawei-Eth-Trunk1]display this #可以查看到允许所以的vlan通过[Huawei]display current-configuration #验证自己的配置结果&lt;Huawei&gt;save #存盘#配置完成，用ping命令测试，删除一条线，再次用ping命令测试 十三、路由原理及配置什么是路由将数据包从一个网络发送到另一个网络，需要依靠路由器来完成；路由器只关心网络的状态，决定最佳路径路由器可以根据路由表选择最佳路径 每个路由器都维护着一张路由表，这是路由器转发数据包的关键； 每条路由表记录指明了：到达某个子网或主机应从路由器的哪个物理接口发送，通过此接口可到达该路径的下一个路由器的地址(或直接相连网络中的目标主机地址)如何获得路由表 直连路由:路由设备配置IP地址后自动生成； 直连路由的配置： 第一步：设计好网络拓扑结构； 第二步：在PC2和PC1中配置IP地址，子网掩码和网关；12PC2: IP地址：192.168.1.1/24 网关：192.168.1.254PC1: IP地址：192.168.2.1/24 网关：192.168.2.254 第三步：在路由器AR2上给相应的接口配置IP地址；12345678910111213&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图下[Huawei]display interface brief #查看设备接口信息，百兆还是千兆接口[Huawei]interface GigabitEthernet 0/0/0 #进入g 0/0/0的接口视图下[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.254 255.255.255.0 #为接口 g0/0/0配置IP地址和子网掩码[Huawei-GigabitEthernet0/0/0]display this #查看配置结果[Huawei-GigabitEthernet0/0/0]quit #回到系统视图下[Huawei]interface GigabitEthernet 0/0/1 # #进入g 0/0/1的接口视图下[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.254 255.255.255.0 ##为接口 g0/0/0配置IP地址和子网掩码[Huawei-GigabitEthernet0/0/1]display this #查看配置结果[Huawei-GigabitEthernet0/0/1]quit #退回到系统视图[Huawei]display ip routing-table #查看路由表信息，数据过多，可以用下面命令来筛选[Huawei]display ip routing-table | include /24 #删选查看，只查看 /24结尾的路由信息 第四步：使用 ping 命令 进行测试 静态路由:由管理员在路由器上手工指定；: 动态路由:根据网络拓扑或流量变化，由路由器通过路由协议自动设置；适合ISP服务商、广域网、园区网等大型网络十四、静态路由与默认路由静态路由主要特点由管理员手工配置，为单向条目；通信双方的边缘路由器都需要指定，否则会导致数据包有去无回；使用 ip route-static 命令123451》指定到达 IP 目的网络；2》基本格式：[Huawei]ip route-static 目标网络ID 子网掩码 下一跳#目标网络ID 一般为网段，可以代表这个网段下的所有主机，IP地址只能代表一台主机,局限性比较大[Huawei]dis ip routing-table | include /24 #确认自己配置的是否正确 默认路由 默认路由是一种特殊的静态路由； 默认路由的目标网络为 0.0.0.0 0.0.0.0，可匹配任何目标地址； 只有当从路由表中找不到任何明确匹配的路由条目才会使用默认路由，一般在企业网关出口使用1#目标网络为0.0.0.0，子网掩码简写为0，192.168.2.2 为下一跳 默认路由不能随便配置。容易照成路由环路，只能用于内部网路和外部网路。 配置静态路由 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 PC3 中配置IP地址，子网掩码和网关；123PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.3.1/24 网关：192.168.3.254PC3: IP地址：192.168.4.1/24 网关：192.168.4.254 第三步：在路由器AR1上给相应的接口配置IP地址1234567#在接口g 0/0/0 上给192.168.1.0/24网段配置网关，IP地址：192.168.1.254/24&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图下[Huawei]display interface brief #查看设备接口信息，百兆还是千兆接口[Huawei]interface GigabitEthernet 0/0/0 #进入g 0/0/0的接口视图下[Huawei-GigabitEthernet0/0/0]ip address 192.168.1.254 255.255.255.0[Huawei-GigabitEthernet0/0/0]display this 12345678#在接口g 0/0/1 上配置IP地址：192.168.2.1/24&lt;Huawei&gt;sys&lt;Huawei&gt;system-view[Huawei]interface GigabitEthernet 0/0/1[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.1 24 #掩码255.255.255.0 可以用24 来表示[Huawei-GigabitEthernet0/0/1]display this[Huawei-GigabitEthernet0/0/1]quit[Huawei]dis ip routing-table | include /24 #确认自己配置的是否正确 第四步：在路由器 AR2 上给相应的接口配置IP地址12345#在接口g 0/0/1 上配置IP地址：192.168.2.2/24&lt;Huawei&gt;system-view[Huawei]interface GigabitEthernet 0/0/1[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.2 24 #掩码255.255.255.0可以用 24 来表示[Huawei-GigabitEthernet0/0/1]display this 1234567#在接口g 0/0/0 上给192.168.3.0/24 网段配置网关，IP地址：192.168.3.254/24&lt;Huawei&gt;&lt;Huawei&gt;system-view #进入系统视图下[Huawei]display interface brief #查看设备接口信息，百兆还是千兆接口[Huawei]interface GigabitEthernet 0/0/0 #进入g 0/0/0的接口视图下[Huawei-GigabitEthernet0/0/0]ip address 192.168.3.254 255.255.255.0[Huawei-GigabitEthernet0/0/0]display this 1234567#在接口g 0/0/2 上给192.168.4.0/24网段配置网关，IP地址：192.168.4.254/24&lt;Huawei&gt;system-view[Huawei]interface GigabitEthernet 0/0/2[Huawei-GigabitEthernet0/0/2]ip address 192.168.4.254 24 #掩码255.255.255.0可以用 24 来表示[Huawei-GigabitEthernet0/0/2]display this[Huawei-GigabitEthernet0/0/2]quit[Huawei]dis ip routing-table | include /24 #确认自己配置的是否正确 第五步：配置静态路由，让全网互通12345#AR1上配置静态路由，AR2上也要配置，否则不通#静态路由的配置是让在不同路由器上的设备互相连通的，如果设备是由同一台路由器连接的，是直接通过直连路由是连通的[Huawei]ip route-static 192.168.3.0 24 192.168.2.2 #目标地址为3.0网段，代表这个网段下的所有主机[Huawei]ip route-static 192.168.4.0 24 192.168.2.2[Huawei]dis ip routing-table | include /24 123#AR2上配置静态路由，AR1上也要配置，否则不通[Huawei]ip route-static 192.168.1.0 24 192.168.2.1[Huawei]dis ip routing-table | include /24 #发现这台路由器上的192.168.3.0/24 网段和 192.168.4.0/24 网段都设置了静态路由 注释：如果发现IP地址配置错误，使用如下方法删除并重新设置 123456[Huawei]interface g0/0/0[Huawei-GigabitEthernet0/0/0]display this #复制粘贴信息[Huawei-GigabitEthernet0/0/0]undo ip address 192.168.3.200 255.255.255.0 #删除IP地址[Huawei-GigabitEthernet0/0/0]display this[Huawei-GigabitEthernet0/0/0]ip address 192.168.3.254 24 #设置新的IP地址 第六步：使用 ping 命令 进行测试 第七步：保存配置1&lt;Huawei&gt;save #永久保存配置信息，只能在用户视图下进行 十五、三层交换机什么是三层交换实现数据互通必须使用交换机，交换机只能连接相同的网段的网路互通，交换机是链路层工具（二层）。路由器(具备路由转发功能，三层)是网络层工具，使用三层交换技术实现VLAN间通信；三层交换 = 二层交换 + 三层转发。使用三层交换机必须使用VLAN虚接口概述三层交换机连接不同网段的，类似二层交换机连接不同的网段。使用三层需要规划好VLAN，二层交换机的不同网段，类别于三层交换机的不用的VLAN。在三层交换机上配置的VLAN接口为虚拟接口；使用 vlanif (VLAN接口) 实现VLAN间路由：VLAN接口的引入使得应用更加灵活。VLAN 接口相当于二层交换机的路由接口配置。12345&lt;Huawei&gt;system-view[Huawei]interface Vlanif 1 #进入vlan的虚接口，可以是2，3，4...[Huawei-Vlanif1]ip address 192.168.1.254 24 #给虚接口设置IP地址，相当于VLAN1的网关[Huawei-Vlanif1]display this #查看配置的结果[Huawei]display ip interface brief 三层交换配置思路 确认哪些VLAN需要配置网关； 如果三层交换机上没有该VLAN则创建它； 为每个VLAN创建相关的虚拟接口； 给每个VLAN虚拟接口配置IP地址； 如果需要，配置三层交换机的动态或静态路由 三层交换VLAN间通信路由器默认只有三个接口，最多只能连接三个不同的网段。想要多网段互通，需要使用多个路由器来实现多网段的路由配置。这样十分浪费资源，解决办法是使用，三层交换机。路由器默认只有三个接口 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 PC3 中配置IP地址，子网掩码和网关； 123PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.2.1/24 网关：192.168.2.254PC3: IP地址：192.168.3.1/24 网关：192.168.3.254 第三步：在三层交换机LSW1上创建VLAN；12&lt;Huawei&gt;system-view[Huawei]vlan batch 2 to 3 #根据设备所在的vlan,在三次交换机上创建相应的vlan 第四步：将接口加入到对应VLAN中； 123456[Huawei]interface GigabitEthernet 0/0/2[Huawei-GigabitEthernet0/0/2]port link-type access[Huawei-GigabitEthernet0/0/2]port default vlan 2[Huawei]interface GigabitEthernet 0/0/3[Huawei-GigabitEthernet0/0/3]port link-type access[Huawei-GigabitEthernet0/0/3]port default vlan 3 第五步：在三层交换机上给VLAN配置网关；`12345678910111213141516#给 vlan 1配置网关：192.168.1.254/24&lt;Huawei&gt;system-view[Huawei]interface Vlanif 1[Huawei-Vlanif1]ip address 192.168.1.254 24[Huawei-Vlanif1]display this #查看配置的结果#给 vlan 2配置网关：192.168.2.254/24[Huawei]interface Vlanif 2[Huawei-Vlanif2]ip address 192.168.2.254 24[Huawei-Vlanif2]display this #查看配置的结果#给 vlan 3配置网关：192.168.3.254/24[Huawei]interface Vlanif 3[Huawei-Vlanif3]ip address 192.168.3.254 24[Huawei-Vlanif3]display this #查看配置的结果[Huawei-Vlanif3]quit[Huawei]display ip routing-table | include /24 #查看配置的所有VLAN 第六步：使用 ping 命令 进行测试 十六、综合组网案例(更合理的使用三层交换机)：交换机、三层交换、路由构建网络 第一步：设计好网络拓扑结构；为了缓解三层交换机的压力，通常连接外部网路需要连接一个路由器。路由器的功能要比三成交换机强大。 第二步：在PC1、PC2 和 PC3 及PC4 中配置IP地址，子网掩码和网关；1234PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.2.1/24 网关：192.168.2.254PC3: IP地址：192.168.3.1/24 网关：192.168.3.254PC4: IP地址：192.168.5.1/24 网关：192.168.5.254 第三步：在二层交换机 (S3700) LSW1上创建VLAN；12&lt;LSW1&gt;system-view[LSW1]vlan batch 2 to 3 #二层交换机上创建vlan 第四步：将接口加入到交换机 (S3700) LSW1相应的vlan中； 123456789[LSW1]interface Ethernet 0/0/2[LSW1-Ethernet0/0/2]port link-type access[LSW1-Ethernet0/0/2]port default vlan 2[LSW1-Ethernet0/0/2]display vlan #查看结果[LSW1]interface Ethernet 0/0/3[LSW1-Ethernet0/0/3]port link-type access[LSW1-Ethernet0/0/3]port default vlan 3[LSW1-Ethernet0/0/3]display vlan #查看结果 第五步：在二层交换机LSW1 (S3700) 和三层交换机LSW2(S5700) 上配置trunk（中继链路） 12345678910111213#在二层交换机LSW1 (S3700)的Ethernet 0/0/4接口配置trunk[LSW1]interface Ethernet 0/0/4[LSW1-Ethernet0/0/4]port link-type trunk[LSW1-Ethernet0/0/4]port trunk allow-pass vlan all[LSW1-Ethernet0/0/4]quit[LSW1]display current-configuration#在三层交换机LSW2(S5700)的Ethernet 0/0/4接口配置trunk[LSW2]interface GigabitEthernet 0/0/1[LSW2-GigabitEthernet0/0/1]port link-type trunk[LSW2-GigabitEthernet0/0/1]port trunk allow-pass vlan all[LSW2-GigabitEthernet0/0/1]quit[LSW2]display current-configuration 第六步：在三层交换机LSW2(S5700)上创建vlan，并将接口GE 0/0/2加入到vlan 4中 123456&lt;LSW2&gt;system-view[LSW2]vlan batch 2 to 4 #三层交换机上创建vlan[LSW2]interface GigabitEthernet 0/0/2[LSW2-GigabitEthernet0/0/2]port link-type access[LSW2-GigabitEthernet0/0/2]port default vlan 4[LSW2-GigabitEthernet0/0/2]display vlan #查看结果 第七步：在三层交换机 LSW2(S5700) 的虚接口上配置IP 1234567891011121314151617#在vlan 1上配置IP地址[LSW2]interface Vlanif 1[LSW2-Vlanif1]ip address 192.168.1.254 24[LSW2-Vlanif1]quit#在vlan 2上配置IP地址[LSW2]interface Vlanif 2[LSW2-Vlanif2]ip address 192.168.2.254 24[LSW2-Vlanif2]quit#在vlan 3上配置IP地址[LSW2]interface Vlanif 3[LSW2-Vlanif3]ip address 192.168.3.254 24[LSW2-Vlanif3]quit#在vlan 4上配置IP地址[LSW2]interface Vlanif 4[LSW2-Vlanif4]ip address 192.168.4.1 24[LSW2-Vlanif4]quit[LSW2]display ip routing-table | include /24 #查看虚接口配置信息 第八步：在路由器AR1(AR2220) 上给接口配置IP地址 1234567&lt;AR1&gt;system-view[AR1]interface GigabitEthernet 0/0/0[AR1-GigabitEthernet0/0/0]ip address 192.168.4.2 24[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 192.168.5.254 24 #在路由器上给5.0网段配置网关[AR1]display ip routing-table | include /24 #查看接口IP地址配置信息 第九步：在三层交换机LSW2(S5700)上配置静态路由 123&lt;LSW2&gt;system-view[LSW2]ip route-static 192.168.5.0 24 192.168.4.2 #目标网段，子网掩码，下一跳地址[LSW2]display ip routing-table | include /24 第十步：在路由器AR1(AR2220) 上配置静态路由 12345&lt;AR1&gt;system-view[AR1]ip route-static 192.168.1.0 24 192.168.4.1 #目标网段，子网掩码，下一跳地址[AR1]ip route-static 192.168.2.0 24 192.168.4.1[AR1]ip route-static 192.168.3.0 24 192.168.4.1[AR1]display ip routing-table | include /24 第十一步：测试，保持全网互通 十七、动态路由动态路由概述动态路由是基于某种路由协议来实现的；使用动态路由可以减少了管理任务；但是占用了网络带宽.上图为直连路由，配置动态路由的时候，所以路由都需要开启动态路由，同时需要宣告连接的网段。实现的网段共享。全网互通。全网可达。动态更新路由信息 动态路由协议 OSPF动态路由协议 OSPF，全称为Open Shortest Path Firsh ( 开放式最短路径优先 )；适合大中型网络使用； OSPF区域为了适应大型的网络，OSPF在网络内部划分多个区域；每个OSPF路由器只维护所在区域的完整链路状态信息 区域ID区域ID可以表示成一个十进制的数字；也可以表示一个IP 骨干区域Area 0负责区域间路由信息的传播，必须要拥有的一个区域 十八、OSPF配置OSPF基本配置 启动OSPF路由进程并进入首个区域12[Huawei]ospf 1 #开启一个进程，进程号为 1，小型网络开启一个进程就可以[Huawei-ospf-1]area 0 #进入骨干区域，相当于控制中枢，必须得有 宣告所在的网段1[Huawei-ospf-1-area-0.0.0.0]network 192.168.0.0 0.0.0.255 #宣告网段，192.168.0.0的子网掩码为255.255.255.0，反掩码则为0.0.0.255 十九、OSPF动态路由配置案例 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 中配置IP地址，子网掩码和网关；12PC1: IP地址：10.0.0.1/8 网关：10.0.0.2PC2: IP地址：40.0.0.2/8 网关：40.0.0.1 第三步：在路由器AR1(AR2220) 上的接口上配置IP地址123456789#在接口 g0/0/0 上配置IP地址[AR1]interface GigabitEthernet 0/0/0[AR1-GigabitEthernet0/0/0]ip address 10.0.0.2 8#在接口 g0/0/1 上配置IP地址[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 20.0.0.1 8[AR1-GigabitEthernet0/0/1]quit#通过路由表查看配置结果[AR1]display ip routing-table | include /8 第三步：在路由器AR2(AR2220) 上的接口上配置IP地址 123456789#在接口 g0/0/0 上配置IP地址[AR2]interface GigabitEthernet 0/0/0[AR2-GigabitEthernet0/0/0]ip address 20.0.0.2 8#在接口 g0/0/1 上配置IP地址[AR2]interface GigabitEthernet 0/0/1[AR2-GigabitEthernet0/0/1]ip address 30.0.0.1 8[AR2-GigabitEthernet0/0/1]quit#通过路由表查看配置结果[AR2]display ip routing-table | include /8 第四步：在路由器AR3(AR2220) 上的接口上配置IP地址 123456789#在接口 g0/0/0 上配置IP地址[AR3]interface GigabitEthernet 0/0/0[AR3-GigabitEthernet0/0/0]ip address 30.0.0.2 8#在接口 g0/0/1 上配置IP地址[AR3-GigabitEthernet0/0/0]interface GigabitEthernet 0/0/1[AR3-GigabitEthernet0/0/1]ip address 40.0.0.1 8[AR3-GigabitEthernet0/0/1]quit#通过路由表查看配置结果[AR1]display ip routing-table | include /8 第五步：在路由器AR1(AR2220) 上配置动态路由OSPF 12345[AR1]ospf 1 #启动一个进程，进程号为 1[AR1-ospf-1]area 0 #进入骨干区域[AR1-ospf-1-area-0.0.0.0]network 10.0.0.0 0.255.255.255 #宣告网段，10.0.0.0的子网掩码为255.0.0.0，`反掩码则为0.255.255.255`[AR1-ospf-1-area-0.0.0.0]network 20.0.0.0 0.255.255.255[AR1-ospf-1-area-0.0.0.0]display ip routing-table | include /8 第六步：在路由器AR2(AR2220) 上配置动态路由OSPF 12345[AR2]ospf 1 #启动一个进程，进程号为 1[AR2-ospf-1]area 0 #进入骨干区域[AR2-ospf-1-area-0.0.0.0]network 20.0.0.0 0.255.255.255 #宣告网段，20.0.0.0的子网掩码为255.0.0.0，反掩码则为0.255.255.255[AR2-ospf-1-area-0.0.0.0]network 30.0.0.0 0.255.255.255[AR2-ospf-1-area-0.0.0.0]display ip routing-table | include /8 第七步：在路由器AR3(AR2220) 上配置动态路由OSPF 12345[AR3]ospf 1 #启动一个进程，进程号为 1[AR3-ospf-1]area 0 #进入骨干区域[AR3-ospf-1-area-0.0.0.0]network 30.0.0.0 0.255.255.255 #宣告网段，30.0.0.0的子网掩码为255.0.0.0，反掩码则为0.255.255.255[AR3-ospf-1-area-0.0.0.0]network 40.0.0.0 0.255.255.255[AR3-ospf-1-area-0.0.0.0]display ip routing-table | include /8 第八步：测试，保持全网互通 二十、案例使用动态路由完成综合组网 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 PC3 中配置IP地址，子网掩码和网关；123PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.2.1/24 网关：192.168.2.254PC3: IP地址：192.168.3.1/24 网关：192.168.3.254 第三步：在二层交换机 (S3700) LSW1上创建VLAN；12&lt;LSW1&gt;system-view[LSW1]vlan batch 2 to 3 #二层交换机上创建vlan 第四步：将接口加入到交换机 (S3700) LSW1相应的vlan中；12345678[LSW1]interface Ethernet 0/0/2[LSW1-Ethernet0/0/2]port link-type access[LSW1-Ethernet0/0/2]port default vlan 2[LSW1-Ethernet0/0/2]display vlan #查看结果[LSW1]interface Ethernet 0/0/3[LSW1-Ethernet0/0/3]port link-type access[LSW1-Ethernet0/0/3]port default vlan 3[LSW1-Ethernet0/0/3]display vlan #查看结果 第五步：在二层交换机LSW1 (S3700) 和三层交换机LSW2(S5700) 上配置trunk123456789101112#在二层交换机LSW1 (S3700)的Ethernet 0/0/4接口配置trunk[LSW1]interface Ethernet 0/0/4[LSW1-Ethernet0/0/4]port link-type trunk[LSW1-Ethernet0/0/4]port trunk allow-pass vlan all[LSW1-Ethernet0/0/4]quit[LSW1]display current-configuration#在三层交换机LSW2(S5700)的Ethernet 0/0/4接口配置trunk[LSW2]interface GigabitEthernet 0/0/1[LSW2-GigabitEthernet0/0/1]port link-type trunk[LSW2-GigabitEthernet0/0/1]port trunk allow-pass vlan all[LSW2-GigabitEthernet0/0/1]quit[LSW2]display current-configuration 第六步：在三层交换机LSW2(S5700)上创建vlan，并将接口GE 0/0/2加入到vlan 4中123456&lt;LSW2&gt;system-view[LSW2]vlan batch 2 to 4 #三层交换机上创建vlan[LSW2]interface GigabitEthernet 0/0/2[LSW2-GigabitEthernet0/0/2]port link-type access[LSW2-GigabitEthernet0/0/2]port default vlan 4[LSW2-GigabitEthernet0/0/2]display vlan #查看结果 第七步：在三层交换机 LSW2(S5700) 的虚接口上配置IP12345678910111213141516#在vlan 1上配置IP地址[LSW2]interface Vlanif 1[LSW2-Vlanif1]ip address 192.168.1.254 24[LSW2-Vlanif1]quit#在vlan 2上配置IP地址[LSW2]interface Vlanif 2[LSW2-Vlanif2]ip address 192.168.2.254 24[LSW2-Vlanif2]quit#在vlan 3上配置IP地址[LSW2]interface Vlanif 3[LSW2-Vlanif3]ip address 192.168.3.254 24[LSW2-Vlanif3]quit#在vlan 4上配置IP地址[LSW2]interface Vlanif 4[LSW2-Vlanif4]ip address 192.168.4.1 24[LSW2-Vlanif4]quit 第八步：在路由器AR1(AR2220) 上给接口配置IP地址123456&lt;AR1&gt;system-view[AR1]interface GigabitEthernet 0/0/0[AR1-GigabitEthernet0/0/0]ip address 192.168.4.2 24[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 192.168.5.254 24 #在路由器上给5.0网段配置网关[AR1]display ip routing-table | include /24 #查看接口IP地址配置信息 第八步：在三层交换机LSW2(S5700)上配置动态路由1234567#宣告网段，配置反掩码[LSW2]ospf 1[LSW2-ospf-1]area 0[LSW2-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255[LSW2-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255[LSW2-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255[LSW2-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255 第九步：在三层交换机LSW2(S5700)上配置连通外网的默认路由1[LSW2]ip route-static 0.0.0.0 0 192.168.4.2 #默认路由匹配所有的外围地址 第十步：在路由器AR1(AR2220) 上配置动态路由123[AR1]ospf 1[AR1-ospf-1]area 0[AR1-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255 第十一步：在路由器AR1(AR2220) 上配置默认路由1[AR2]ip route-static 0.0.0.0 0 192.168.5.1 #下一跳为运营商提供的IP地址，由运营商代替访问互联网 第十一步：测试注意：在实际的环境中，架构完成以后，要访问外网需要在三层交换机LSW2和 路由器 AR1上都要配置去外面的静态路由. 二十一、传输层概述传输层的作用 网络层提供点到点的连接； 传输层提供端到端的连接；端口号区分传输层最主要的功能就是能够让应用程序之间实现通信。计算机内部,通常同一时间运行着多个程序。为此,必须分清是哪些程序与哪些程序在进行通信。识别这些应用程序的是端口号。传输层的协议TCP（Transmission Control Protocol） 传输控制协议；可靠的、面向连接的； 传输效率低TCP是一种面向有连接的传输层协议，它保证两端通行主机之间的通信可达，正确处理传输过程中丢失的，传输顺序乱等异常情况。TCP能够有效利用带宽，缓解网络拥堵。建立与断开需要7次发包收包。tcp如何保证传输的可靠性： 将应用数据分割为tcp认为合适发送的数据包。 超时传送，当tcp发送一个段后，它会启动一个定时器，等待目的端确认受到这个报文段，如果没有收到确认，将重发这个报文段。 当tcp收到tcp链发送的的数据时，会发送一个确认，(对于收到的请求做一个确认)，这个请求不会立即发送，会推迟几秒 若tcp收到包，校验出包有错，丢弃报文段，不给出响应，tcp对端会重发。 对于失序数据进行重排序，然后教给应用层(tcp报文段作为ip数据报进行传输，而ip数据报的到达会失序，)因此tcp也可能失序。 对于重复数据，直接丢弃。 tcp可以进行流量控制，防止较快主机导致较慢主机的缓存区溢出 UDP（User Datagram Protocol） 用户数据报协议；不可靠、无连接的； 传输效率高TCP的封装格式三次握手： 第一次握手：Host A 向Host B发送一个SYN，等待Host B确认；我们建立连接吧 第二次握手：Host B收到数据包后，知道Host A 请求建立连接，给Host A回复SYN和ACK，确认连接请求；我也想和你建立连接 第三次握手：Host A收到确认后，发送ACK给Host B；嗯，好的。TCP的四次断开四次断开：即终止TCP连接，就是断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。 第一次断开：Host A发送一个FIN，用来关闭Host A到Host B的数据传送； 第二次断开：Host B收到FIN后，发送一个ACK给Host A; 第三次断开：Host B发送一个FIN，用来关闭Host B到Host A的数据传送； 第四次断开：Host A收到FIN后，发送一个ACK给Host B； TCP的应用 UDP的封装格式 UDP的应用 二十二、ACL简介与基本配置ACL的作用 访问控制列表（Access Control List, ACL）是应用在路由器接口的指令列表(即规则)； 读取第三层、第四层报文头信息； 根据预先定义好的规则对报文进行过滤；ACL的主要类型 分类 编号范围 参数 基本ACL 2000-2999 源IP地址 高级ACL 3000-3999 源IP地址、目标IP地址、端口、协议 ACL规则:每个ACL可以包含多个规则，路由器根据规则对数据流量进行过滤，匹配即停止.根据规则号（rule 后面的数字）匹配，前面的规则匹配了，就不再匹配后面的规则；前面的规则不匹配，则继续匹配下面的规则. 123456789101112255.255.255.0 #十进制表示11111111.11111111.11111111.00000000 #二进制表示00000000.00000000.00000000.11111111 #反掩码，即0和1互换0.0.0.255 #反掩码的十进制表示0 #二进制中 0 表示匹配1 #而进制中 1 表示不匹配例如：192.168.1.0 192.168.2.1掩码为：255.255.255.0反掩码为：0.0.0.255 #匹配IP地址的前三位#也可以不按照IP地址的分类来，可以自定义匹配规则：#例如：172.17.0.0 属于B类IP地址，子网掩码为：255.255.0.0， 反掩码可设置为：0.0.0.255 代表匹配前三位 172.17.0 即：IP地址前三位为172.17.0的服务器发送的数据将被拒绝发送 基本ACL概述 基于源IP地址过滤数据包； 列表号是 2000 ~ 2999； 二十三、基本ACL配置(1)需求描述： 禁止PC1访问服务器 Server1; 允许其他所有的访问流量 第一步：设计好网络拓扑结构；第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关； 123PC1: IP地址： 192.168.1.1/24 网关：192.168.1.254PC2: IP地址： 192.168.2.1/24 网关：192.168.2.254Server1: IP地址： 192.168.100.1/24 网关：192.168.100.254 第三步：在路由器AR1(AR2220) 上配置直连路由； 12345678910111213141516#给路由器接口上配置上配置相应的IP地址&lt;AR1&gt;&lt;AR1&gt;system-view #进入系统视图下[AR1]interface GigabitEthernet 0/0/0 #进入g 0/0/0的接口视图下[AR1-GigabitEthernet0/0/0]ip address 192.168.1.254 255.255.255.0 #为接口 g 0/0/0配置IP地址和子网掩码[AR1-GigabitEthernet0/0/0]display this #查看配置结果[AR1-GigabitEthernet0/0/0]quit #回到系统视图下[AR1]interface GigabitEthernet 0/0/1 # #进入g 0/0/1的接口视图下[AR1-GigabitEthernet0/0/1]ip address 192.168.2.254 255.255.255.0 ##为接口 g0/0/0配置IP地址和子网掩码[AR1-GigabitEthernet0/0/1]display this #查看配置结果[AR1-GigabitEthernet0/0/1]quit #退回到系统视图[AR1]interface GigabitEthernet 0/0/2 # #进入g 0/0/2的接口视图下[AR1-GigabitEthernet0/0/2]ip address 192.168.100.254 255.255.255.0 ##为接口 g0/0/0配置IP地址和子网掩码[AR1-GigabitEthernet0/0/2]display this #查看配置结果[AR1-GigabitEthernet0/0/1]quit #退回到系统视图[AR1]display ip routing-table | include /24 #删选查看，只查看 /24结尾的路由信息 第四步：设置ACL访问限制； 12345[Huawei]acl 2000 #基本acl，列表号是 2000~2999[Huawei-acl-basic-2000]rule 5 deny source 192.168.1.1 0#规则号为5，并以5为间隔，是为了方便去插入规则，反掩码只有一个 0,是0.0.0.0的缩写，代表匹配整个IP地址，就是只拒绝一个设备发送数据[AR1]interface g0/0/2[AR1-GigabitEthernet0/0/2]traffic-filter outbound acl 2000 `#规则写好后要加入到接口处让其生效` 第五步：查看设置的ACL策略； 12[AR1]display acl 2000 #查看单个ACL策略[AR1]display acl all #查看设备上配置的所有ACL策略 第六步：测试； 12PC1 不能 ping 通 Server1;PC2 可以 ping 通 Server1; 二十四、案例/基本ACL配置(2)需求描述：禁止主机PC2与PC1互通，而允许其他的所有流量. 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关；123PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.2.1/24 网关：192.168.2.254PC3: IP地址：192.168.2.2/24 网关：192.168.2.254 第三步：在路由器AR1(AR2220) 上配置直连路由；1234567[AR1]interface g0/0/0[AR1-GigabitEthernet0/0/0]ip address 192.168.1.254 24[AR1-GigabitEthernet0/0/0]quit[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 192.168.2.254 255.255.255.0[AR1-GigabitEthernet0/0/1]quit[AR1]display ip routing-table | include /24 第四步：测试12PC1 可以 ping 通 PC2;PC1 可以 ping 通 PC3; 第五步：路由器上配置ACL策略； 123456[Huawei]acl 2000 #基本acl，列表号是 2000~2999[Huawei-acl-basic-2000]rule 5 deny source 192.168.2.1 0#规则号为5，并以5为间隔，是为了方便去插入规则，反掩码只有一个 0,是0.0.0.0的缩写，代表匹配整个IP地址，就是只拒绝一个设备发送数据#[Huawei-acl-basic-2000]undo rule 5 #如果发现规则写错了可以这样删除[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]traffic-filter inbound acl 2000 `#规则写好后要加入到接口处让其生效,因为是禁止其他设备访问，所以是数据的进入，这里用 inbound` 第六步：查看设置的ACL策略； 12[AR1]display acl 2000 #查看单个ACL策略[AR1]display acl all #查看设备上配置的所有ACL策略 第七步：测试； 12PC2 可以 ping 通 PC1;PC3 不能 ping 通 PC1; 二十五、案例3/基本ACL配置(3) 第一步：设计好网络拓扑结构；第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关；123PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.2.1/24 网关：192.168.2.254PC3: IP地址：192.168.2.2/24 网关：192.168.2.254 第三步：在路由器AR1(AR2220) 上配置直连路由；1234567[AR1]interface g0/0/0[AR1-GigabitEthernet0/0/0]ip address 192.168.1.254 24[AR1-GigabitEthernet0/0/0]quit[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 192.168.2.254 255.255.255.0[AR1-GigabitEthernet0/0/1]quit[AR1]display ip routing-table | include /24 第四步：测试12PC1 可以 ping 通 PC2;PC1 可以 ping 通 PC3; 第五步：路由器上配置ACL策略；123456789101112#第一步：配置规则，允许主机PC2与PC1互通[AR1]acl 2000 #要删除2000下的所有规则，undo acl 2000[AR1-acl-basic-2000]display this #查看2000下的所有规则[AR1-acl-basic-2000]rule permit source 192.168.2.1 0 #配置规则允许192.168.2.1和192.168.1.1互通[AR1-acl-basic-2000]display this #查看2000下的所有规则#第二步：配置规则，禁止其他所有设备访问PC1[AR1-acl-basic-2000]rule deny source any `#any指的就是其他所有的IP地址`[AR1-acl-basic-2000]quit#第三步：将规则加入到相应的接口中[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]traffic-filter inbound acl 2000 `#规则写好后要加入到接口处让其生效,因为是禁止其他设备访问，所以是数据的进入，这里用 inbound`[AR1-GigabitEthernet0/0/1]display this #查看2000下的所有规则 第六步：测试；12PC2 可以 ping 通 PC1;PC3 不能 ping 通 PC1; 二十六、ACL高级配置高级ACL概述:基于源IP地址、目标IP地址、源端口、目标端口、协议 过滤数据包；列表号是 3000 ~ 3999； 案例1：高级ACL配置(1)需求描述：允许Client1 访问Server1的Web服务；允许Clinet1 访问网络 192.168.2.0/24; 禁止Client1 访问其他网络 第一步：设计好网络拓扑结构；第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关；123Client1: IP地址：192.168.1.1/24 网关：192.168.1.254PC1: IP地址：192.168.2.1/24 网关：192.168.2.254Server1: IP地址：192.168.3.1/24 网关：192.168.3.254 第三步：在路由器AR1，AR2，AR3上配置直连路由；123456789#在路由器AR1上的接口上配置IP地址&lt;Huawei&gt;system-view[Huawei]interface GigabitEthernet 0/0/2[Huawei-GigabitEthernet0/0/2]ip address 192.168.1.254 24[Huawei-GigabitEthernet0/0/2]quit[Huawei]interface GigabitEthernet 0/0/0[Huawei-GigabitEthernet0/0/0]ip address 192.168.4.1 24[Huawei-GigabitEthernet0/0/0]quit[Huawei]display ip routing-table | include /24 123456789101112#在路由器AR2上的接口配置IP地址&lt;Huawei&gt;system-view[Huawei]interface GigabitEthernet 0/0/1[Huawei-GigabitEthernet0/0/1]ip address 192.168.4.2 24[Huawei-GigabitEthernet0/0/1]quit[Huawei]interface GigabitEthernet 0/0/0[Huawei-GigabitEthernet0/0/0]ip address 192.168.5.1 24[Huawei-GigabitEthernet0/0/0]quit[Huawei]interface GigabitEthernet 0/0/2[Huawei-GigabitEthernet0/0/2]ip address 192.168.2.254 24[Huawei-GigabitEthernet0/0/2]quit[Huawei]display ip routing-table | include /24 123456789#在路由器AR3上的接口配置IP地址&lt;Huawei&gt;system-view[Huawei]interface GigabitEthernet 0/0/1[Huawei-GigabitEthernet0/0/1]ip address 192.168.5.2 24[Huawei-GigabitEthernet0/0/1]quit[Huawei]interface GigabitEthernet 0/0/2[Huawei-GigabitEthernet0/0/2]ip address 192.168.3.254 24[Huawei-GigabitEthernet0/0/2]quit[Huawei]display ip routing-table | include /24 第四步：配置动态路由OSPF，在路由器AR1，AR2，AR3上宣告网段；123456789#路由器AR1 宣告跟它相连的网段&lt;Huawei&gt;system-view[Huawei]ospf 1[Huawei-ospf-1]area 0[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255 #后跟反掩码[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255 # #后跟反掩码[Huawei-ospf-1-area-0.0.0.0]quit[Huawei-ospf-1]quit[Huawei]display ip routing-table | include /24 123456789#路由器AR2 宣告跟它相连的网段&lt;Huawei&gt;system-view[Huawei]ospf 1[Huawei-ospf-1]area 0[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255 #后跟反掩码[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255[Huawei-ospf-1-area-0.0.0.0]network 192.168.5.0 0.0.0.255[Huawei-ospf-1-area-0.0.0.0]quit[Huawei]display ip routing-table | include /24 123456789#路由器AR3 宣告跟它相连的网段&lt;Huawei&gt;system-view[Huawei]ospf 1[Huawei-ospf-1]area 0[Huawei-ospf-1-area-0.0.0.0]network 192.168.5.0 0.0.0.255 # #后跟反掩码[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255[Huawei-ospf-1-area-0.0.0.0]quit[Huawei-ospf-1]quit[Huawei]display ip routing-table | include /24 第五步：测试全网互通；第六步：路由器AR1上配置ACL策略；12345678910111213141516#允许Client1(192.168.1.1) 访问Server1(192.168.3.1)的Web服务&lt;AR1&gt;system-view[AR1]acl 3000[AR1-acl-adv-3000]rule 5 permit tcp source 192.168.1.1 0 destination 192.168.3.1 0 destination-port eq 80#允许Clinet1(192.168.1.1) 访问网络 192.168.2.0/24[AR1-acl-adv-3000]rule 10 permit ip source 192.168.1.1 0 destination 192.168.2.0 0.0.0.255[AR1-acl-adv-3000]display this#禁止Client1(192.168.1.1) 访问其他网络[AR1-acl-adv-3000]rule 15 deny ip source any[AR1-acl-adv-3000]quit#将规则加入到相应的接口中 g 0/0/2[AR1]interface GigabitEthernet 0/0/2[AR1-GigabitEthernet0/0/2]traffic-filter inbound acl 3000#查看 ACL规则[AR1]display acl 3000 #查看3000的acl策略[AR1]display acl all #查看所有的acl策略 1234#测试Client1(192.168.1.1) 可以访问Server1(192.168.3.1)的web服务;Client1(192.168.1.1) 可以ping 通网络 192.168.2.0/24；Client1(192.168.1.1) 不能ping 通网络 192.168.3.0/24; 案例2：高级ACL配置(2)需求描述： 通过配置高级acl禁止Client1 访问 Server1 的 www 服务；禁止Client2 访问Server1的 ftp 服务器；所有主机的其他服务不受限制 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关；123PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.2.1/24 网关：192.168.2.254PC3: IP地址：192.168.2.2/24 网关：192.168.2.254 第三步：在路由器AR1(AR2220) 上配置直连路由；123456789#接口g 0/0/0上配置IP地址：192.168.1.254/24[AR1]interface g0/0/0[AR1-GigabitEthernet0/0/0]ip address 192.168.1.254 24[AR1-GigabitEthernet0/0/0]quit#接口g 0/0/1上配置IP地址：192.168.2.254/24[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 192.168.2.254 255.255.255.0[AR1-GigabitEthernet0/0/1]quit[AR1]display ip routing-table | include /24 第四步：路由器上配置ACL策略；1234567891011121314#配置高级acl禁止Client1(192.168.2.1) 访问 Server1(192.168.1.1) 的www(80)服务[AR1]acl 3000[AR1-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0destination-port eq 80[AR1-acl-adv-3000]display this#将规则加入到相应的接口中[AR1-acl-adv-3000]quit[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]traffic-filter inbound acl 3000#配置高级acl禁止Client2(192.168.2.2) 访问 Server1(192.168.1.1) 的ftp(21)服务[AR1-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1 0destination-port eq 21[AR1-acl-adv-3000]display this[AR1-acl-adv-3000] 第五步：路由器上查看ACL策略；123#查看 ACL#[AR1]display acl 3000 #查看3000的acl策略[AR1]display acl all #查看所有的acl策略 第六步：测试12Client1(192.168.2.1) 不可以访问 Server1(192.168.1.1) 的 www(80) 服务;Client2(192.168.2.2) 不可以访问 Server1(192.168.1.1) 的 ftp(21) 服务； 二十七、NAT概述NAT的作用Network Address Translation，网络地址转换；NAT是通过将内部网络的私有IP地址转换成全球唯一的公网IP地址，使内部网络可以连接到外部网络；私有IP地址分类123A类 10.0.0.0 ~ 10.255.255.255B类 172.16.0.0 ~ 172.31.255.255C类 192.168.0.0 ~ 192.168.255.255 NAT的特性 NAT的优: 节省公有合法IP地址；处理地址重叠；安全性 NAT的缺点:延迟增大；配置和维护的复杂性；NAT实现方式静态转换;Easy IP;NAT 的工作过程 静态 Easy IP 二十八、静态NAT静态NAT概述静态转换是指将内部网络的私有地址转换为公有地址时，IP地址的对应关系是确定的；静态转换是一对一的转换；静态转换是双向的； 静态NAT配置命令将内部地址10.1.1.11、10.1.1.12静态转换为公网地址 200.1.1.11、200.1.1.12，以便访问外网主机或被外网主机访问 123456#g0/0/2为和外部网络相连的接口(出门口)；#200.1.1.11 200.1.1.12 为公网IP地址；#10.1.1.11 10.1.1.12 为私网IP地址；interface g0/0/2nat static global 200.1.1.11 inside 10.1.1.11nat static global 200.1.1.12 inside 10.1.1.12 案例1 静态NAT配置需求分析：在AR2上配置静态NAT 使192.168.2.1 转换为100.0.0.2，192.168.2.2 转换为100.0.0.3，实现外部网络访问。 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关； 123PC1: IP地址：192.168.2.1/24 网关：192.168.2.254PC2: IP地址：192.168.2.2/24 网关：192.168.2.254Server1: IP地址：100.0.0.10/8 #不用配网关 第三步：在路由器AR2(AR2220) 上的接口配置IP地址； 12345678910#在接口 g0/0/1上配置IP：192.168.2.254/24&lt;AR2&gt;system-view[AR2]interface GigabitEthernet 0/0/1[AR2-GigabitEthernet0/0/1]ip address 192.168.2.254 24[AR2-GigabitEthernet0/0/1]quit#在接口 g0/0/2 上配置IP: 100.0.0.0.1/8[AR2]interface GigabitEthernet 0/0/2[AR2-GigabitEthernet0/0/2]ip address 100.0.0.1 8[AR2-GigabitEthernet0/0/2]quit[AR2]display ip routing-table #查看配置信息 第四步：在路由器AR2(AR2220) 上配置静态NAT； 1234567#nat是在进入外网的接口上配置的，本次拓扑需要在接口 g 0/0/2 上配置[AR2]interface GigabitEthernet 0/0/2#将私网IP地址 192.168.2.1 转换为 公网IP地址 100.0.0.2[AR2-GigabitEthernet0/0/2]nat static global 100.0.0.2 inside 192.168.2.1#将私网IP地址 192.168.2.2 转换为 公网IP地址 100.0.0.3[AR2-GigabitEthernet0/0/2]nat static global 100.0.0.3 inside 192.168.2.2[AR2-GigabitEthernet0/0/2]display this #查看以上配置是否正确 注意：私网地址与公网地址绑定以后，外网服务器直接可以访问绑定的公网地址来访问私网服务器第五步：查看设备上配置NAT 12[AR2]display nat static #查看配置的静态NAT[AR2]display nat static interface GigabitEthernet 0/0/2 #查看接口上的多组NAT 第六步：测试 123PC1(192.168.2.1) 可以访问 Server1(100.0.0.10);PC1(192.168.2.2) 可以访问 Server1(100.0.0.10);Server1(100.0.0.10) 可以通过访问 100.0.0.2 来访问PC1(192.168.2.1); 第七步 路由器AR2上添加默认路由 12345#以上完成了访问单台外网服务器的拓扑，在真实的环境下外网的服务器有很多台，为了可以访问所有的网络，需要配置默认路由，下一跳地址为运营商提供的IP地址。 例如：100.0.0.0.10&lt;AR2&gt;system-view[AR2]ip route-static 0.0.0.0 0 100.0.0.10[AR2]display ip routing-table 二十九、EASY IPEasy IP 允许将多个内部地址映射到网关出接口；Easy IP 是多对一的转换；Easy IP 是单向的 案例1 Easy IP配置需求分析：在路由器AR2上配置Easy IP，使企业内网192.168.2.0/24都可以通过接口 g0/0/2 的IP, 实现外部网络的访问 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 和 Server1 中配置IP地址，子网掩码和网关； 123PC1: IP地址：192.168.2.1/24 网关：192.168.2.254PC2: IP地址：192.168.2.2/24 网关：192.168.2.254Server1: IP地址：100.0.0.10/8 #不用配网关 第三步：在路由器AR1(AR2220) 上的接口配置IP地址； 12345678910#在接口 g0/0/1上配置IP：192.168.2.254/24&lt;AR2&gt;system-view[AR2]interface GigabitEthernet 0/0/1[AR2-GigabitEthernet0/0/1]ip address 192.168.2.254 24[AR2-GigabitEthernet0/0/1]quit#在接口 g0/0/2 上配置IP: 100.0.0.0.1/8[AR2]interface GigabitEthernet 0/0/2[AR2-GigabitEthernet0/0/2]ip address 100.0.0.1 8[AR2-GigabitEthernet0/0/2]quit[AR2]display ip routing-table #查看配置信息 第四步：在路由器AR2(AR2220) 上配置Easy IP； 1234567891011#设置允许192.168.2.0网段的规则[AR2]acl 2000[AR2-acl-basic-2000]rule 5 permit source 192.168.2.0 0.0.0.255[AR2-acl-basic-2000]quit#在接口g 0/0/2上设置Easy IP[AR2]interface GigabitEthernet 0/0/2[AR2-GigabitEthernet0/0/2]nat outbound 2000[AR2-GigabitEthernet0/0/2]quit[AR2-GigabitEthernet0/0/2]display this #查看接口配置是否正确#查看所有的acl规则[AR2]display acl all 第五步：查看设备上配置Easy IP 1[AR2]display nat outbound #查看配置的Easy IP 第六步：测试 12PC1(192.168.2.1) 可以访问 Server1(100.0.0.10);PC1(192.168.2.2) 可以访问 Server1(100.0.0.10); 注意：如果同时配置了静态 NAT 和 Easy IP, 通信时优先使用的是 静态 NAT第七步: 路由器AR2上添加默认路由 1234#以上完成了访问单台外网服务器的拓扑，在真实的环境下外网的服务器有很多台，为了可以访问所有的网络，需要配置默认路由，下一跳地址为运营商提供的IP地址。 例如：100.0.0.0.10&lt;AR2&gt;system-view[AR2]ip route-static 0.0.0.0 0 100.0.0.10[AR2]display ip routing-tab 三十、VRRP概述与环境单网关场景分析当网关路由器出现故障时，本网段内以该设备为网关的主机都不能与 Internet 进行通信。 多网关存在的问题通过部署多网关的方式实现网关的备份,存在的问题: 1、网关间IP地址冲突； 2、主机会频繁切换网络出口什么是VRRPVRRP是虚拟路由冗余协议,VRRP能够在不改变组网的情况下，从多台网关设备里产生一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现网关的备份VRRP应用VRRP组成员角色 主(Master) 路由器； 备份(Backup) 路由器； 虚拟(Virtual) 路由器VRRP原理企业级的架构中，需要保证架构的稳定性，即关键设备中有一台出现问题了，不会导致整个网络的瘫痪；一个网络访问另外的网络需要通过路由器来完成，VRRP的作用就是：由两台配置了不同IP地址(网关)的路由器，组成一个虚拟的路由器，对外提供网关服务的是这个虚拟路由器。这样不管是真实路由器哪个出现问题，都不会影响整个网络的运行，提高了网络结构的稳定性。三十一、VRRP配置VRRP配置步骤 配置VRRP的成员； 配置VRRP的优先级 (默认100)； 查看VRRP信息123456789101112131415#三层交换机SW1上配置, 主路由器(Master)&lt;Huawei&gt;system-view #进入系统视图[Huawei]sysname SW1 #修改设备名字[SW1][SW1]undo info-center enable #取消信息提示#给vlan1配置网关[SW1]interface Vlanif 1[SW1-Vlanif1]ip address 192.168.1.252 255.255.255.0#将三层交换机SW1配置为VRRP的成员，设置虚拟IP地址[SW1-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254#配置VRRP的优先级，不写默认为100[SW1-Vlanif1]vrrp vrid 1 priority 105[SW1-Vlanif1]#查看VRRP配置信息[SW1-Vlanif1]display vrrp brief 12345678910111213#三层交换机SW2上配置,,备用路由器(backup)&lt;Huawei&gt;system-view #进入系统视图[Huawei]sysname SW2 #修改设备名字[SW2][SW2]undo info-center enable #取消信息提示#给vlan1配置网关[SW2]interface Vlanif 1[SW2-Vlanif1]ip address 192.168.1.253 255.255.255.0#将三层交换机SW1配置为VRRP的成员，设置虚拟IP地址[SW2-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254#不用设置优先级，默认为100#查看VRRP配置信息[SW2-Vlanif1]display vrrp brief 案例:三层交换配置VRRP在三层交换机配置 VRRP 后使其产生一个虚拟 IP 地址 192.168.1.254为内部主机的网关 第一步：设计好网络拓扑结构； 第二步：在PC1、PC2 中配置IP地址，子网掩码和网关； 12PC1: IP地址：192.168.1.1/24 网关：192.168.1.254PC2: IP地址：192.168.4.1/24 网关：192.168.2.254 第三步：在三层交换机LSW1和LSW2上配置IP地址； 1234567891011121314151617#在三层交换机LSW1上配置IP地址&lt;LSW1&gt;system-view[LSW1]vlan batch vlan 2 #创建vlan#将接口 g0/0/1加入到vlan 2中[LSW1]interface GigabitEthernet 0/0/1[LSW1-GigabitEthernet0/0/1]port link-type access[LSW1-GigabitEthernet0/0/1]port default vlan 2[LSW1-GigabitEthernet0/0/1]quit#给vlan 2配置IP地址，三层交换机不能直接给接口配IP地址[LSW1]interface Vlanif 2[LSW1-Vlanif2]ip address 192.168.2.2 24[LSW1-Vlanif2]quit#给vlan 1配置IP地址[LSW1]interface Vlanif 1[LSW1-Vlanif1]ip address 192.168.1.252 255.255.255.0#查看配置信息[LSW1]display ip routing-table | include /24 12345678910111213141516#在三层交换机LSW2上配置IP地址&lt;LSW2&gt;system-view[LSW2]vlan batch 3#将接口 g0/0/1加入到vlan 3中[LSW1]interface GigabitEthernet 0/0/1[LSW1-GigabitEthernet0/0/1]port link-type access[LSW1-GigabitEthernet0/0/1]port default vlan 3[LSW1-GigabitEthernet0/0/1]quit#给vlan 1配置IP地址[LSW2]interface vlan 1[LSW2-Vlanif1]ip address 192.168.1.253 24[LSW2-Vlanif1]quit#给vlan 3配置IP地址，三层交换机不能直接给接口配IP地址[LSW2]interface vlan 3[LSW2-Vlanif3]ip address 192.168.3.2 24[LSW2]display ip routing-table | include /24 #查看配置信息 第四步：给路由器配置直连路由； 12345678910111213#在接口g 0/0/0上配置IP地址192.168.2.1/24[AR1]interface GigabitEthernet 0/0/0[AR1-GigabitEthernet0/0/0]ip address 192.168.2.1 24[AR1-GigabitEthernet0/0/0]quit#在接口g 0/0/1上配置IP地址192.168.3.1/24[AR1]interface GigabitEthernet 0/0/1[AR1-GigabitEthernet0/0/1]ip address 192.168.3.1 24[AR1-GigabitEthernet0/0/1]quit#在接口g 0/0/2上配置IP地址192.168.4.254/24[AR1]interface GigabitEthernet 0/0/2[AR1-GigabitEthernet0/0/2]ip address 192.168.4.254 24[AR1-GigabitEthernet0/0/2]quit[AR1]display ip routing-table | include /24 #查看配置信息 第五步：三层交换机和路由器上配置动态路由OSPF； 12345678910#三层交换机LSW1上配置动态路由&lt;LSW1&gt;system-view[LSW1]OSPF 1 #启动进程，进程号为1[LSW1-ospf-1]area 0 #进入骨干区域#宣告跟它相连的网段,注意反掩码的书写[LSW1-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255[LSW1-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255[LSW1-ospf-1-area-0.0.0.0]quit#过滤查看路由表[LSW1]display ip routing-table | include /24 123456789#三层交换机LSW2上配置动态路由&lt;LSW2&gt;system-view[LSW2]ospf 1 # #启动进程，进程号为1[LSW2-ospf-1]area 0 # #进入骨干区域#宣告跟它相连的网段,注意反掩码的书写[LSW2-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255[LSW2-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255#过滤查看路由表[LSW2]display ip routing-table | include /24 123456789&lt;AR1&gt;system-view[AR1]ospf 1 #启动进程，进程号为1[AR1-ospf-1]area 0 #进入骨干区域#宣告跟它相连的网段,注意反掩码的书写[AR1-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255[AR1-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255[AR1-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255#过滤查看路由表[AR1]display ip routing-table | include /24 第六步：两台三层交换机上配置VRRP(虚拟路由)； 12345678910111213141516#三层交换机SW1上配置, 主路由器(Master)[SW1]interface vlan 1#将三层交换机SW1配置为VRRP的成员，设置虚拟IP地址[SW1-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254#配置VRRP的优先级，不写则默认为100[SW1-Vlanif1]vrrp vrid 1 priority 105[SW1-Vlanif1]#查看VRRP配置信息[SW1-Vlanif1]display vrrp brief#三层交换机SW2上配置,备用路由器(backup)[SW2]interface vlan 1#将三层交换机SW1配置为VRRP的成员，设置虚拟IP地址[SW2-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254#不用设置优先级，默认为100#查看VRRP配置信息[SW2-Vlanif1]display vrrp brief 第七步：测试；断开任何一条二层交换机与三层交换机之间的连线，网络还是互通的；注意：断开连线测试时，需要等一会儿，切换需要时间 三十二、企业级网络分析与升级目前网络环境公司介绍:一家网络服务的IT公司；公司位于北京，有若干服务器；通过NAT技术将业务服务器与 Internet 互联 目前网络拓扑结构 目前网络技术目前网络环境已用技术： 默认路由：实现到互联网数以万计网络访问的简化配置； 静态路由：路由器与三层交换间配置静态路由； NAT：将业务服务器与Internet 互联 问题分析现有网络环境问题分析： 接入层交换机只与同一个三层交换机互连，存在单点故障而影响网络通信； 互联网连接单一服务商； 网络规模不断增加，静态路由缺乏灵活 项目需求现有网络需求： 为提高主机对本公司网络服务访问的可靠性，需要使用很多的冗余技术； 为了保证局域网络高可用使用了网状拓扑； 为了保证服务器不会因为使用单一网关而出现的单点失败，影响网络通信，需要网关冗余； 为了保证到互联网的高可用，接入需使用冗余互联网连接。 项目技术基于项目的需求，解决方案中需要增加如下技术： OSPF路由协议：实现网络路径的自动学习； VRRP：实现冗余网关； 链路聚合：实现增加链路可靠性 项目拓扑重新规划后的网络拓扑:","link":"/2021/03/25/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84(%E6%90%AD%E5%BB%BA)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E7%BD%91%E7%AE%A1)/"},{"title":"《Spring Boot+Vue全栈开发实战》读书笔记","text":"傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 写在前面 嗯，回家处理一些事，所以离职了，之前的公司用开源技术封装了一套自己的低代码平台，所以之前学的spring Boot之类的东西都忘了很多，蹭回家的闲暇时间复习下。 笔记整体以 Spring Boot+Vue全栈开发实战一书为方向，中间穿插一些其他视频(原书作者的视频)的知识点。 嗯，生活加油，这段时间好好休养，笔记在更新中..整装待发 ^ _ ^，加油生活… 我年青时以为金钱至上,而今年事已迈,发现果真如此 —王尔德 使用XML配置搭建SSM项目 代码详见：https://github.com/LIRUILONGS/SSM-XML.git 新建一个maven工程，构造SSM目录结构 添加依赖，构建配置文件SpringMVC是Spring的子容器，所以SpringMVC子容器可以访问Spring父容器，反之则不行。所以Spring的配置文件扫描除了Controller的bean，SpringMVC扫描controller的东西。 使用 Java配置类搭建SSM项目代码详见：https://github.com/LIRUILONGS/SSM-java.git @Configuration 注解表示这是一个配置类，在我们这里，这个配置的作用类似于 applicationContext.xml @ComponentScan 注解表示配置包扫描，里边的属性和 xml 配置中的属性都是一一对应的，useDefaultFilters 表示使用默认的过滤器，然后又除去 Controller 注解，即在 Spring 容器中扫描除了 Controller 之外的其他所有 Bean 。 使用 Java 代码去代替 web.xml 文件，这里会用到 WebApplicationInitializer ，WebInit 的作用类似于 web.xml，这个类需要实现 WebApplicationInitializer 接口，并实现接口中的方法，当项目启动时，onStartup 方法会被自动执行，我们可以在这个方法中做一些项目初始化操作，例如加载 SpringMVC 容器，添加过滤器，添加 Listener、添加 Servlet 等。具体定义如下： 注意：由于我们在 WebInit 中只是添加了 SpringMVC 的配置，这样项目在启动时只会去加载 SpringMVC 容器，而不会去加载 Spring 容器，如果一定要加载 Spring 容器，需要我们修改 SpringMVC 的配置，在 SpringMVC 配置的包扫描中也去扫描 @Configuration 注解，进而加载 Spring 容器，还有一种方案可以解决这个问题，就是直接在项目中舍弃 Spring 配置，直接将所有配置放到 SpringMVC 的配置中来完成，这个在 SSM 整合时是没有问题的，在实际开发中，较多采用第二种方案，第二种方案，SpringMVC 的配置如下： 静态资源过滤:重写 addResourceHandlers 方法，在这个方法中配置静态资源过滤，这里我将静态资源放在 resources 目录下，所以资源位置是 classpath:/ ，当然，资源也可以放在 webapp 目录下，此时只需要修改配置中的资源位置即可。如果采用 Java 来配置 SSM 环境，一般来说，可以不必使用 webapp 目录，除非要使用 JSP 做页面模板，否则可以忽略 webapp 目录。 视图解析器 1234&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 12345678@Configuration@ComponentScan(basePackages = &quot;org.javaboy&quot;)public class SpringMVCConfig extends WebMvcConfigurationSupport { @Override protected void configureViewResolvers(ViewResolverRegistry registry) { registry.jsp(&quot;/jsp/&quot;, &quot;.jsp&quot;); }} 路径映射:控制器的作用仅仅只是一个跳转，就像上面小节中的控制器，里边没有任何业务逻辑，像这种情况，可以不用定义方法，可以直接通过路径映射来实现页面访问。如果在 XML 中配置路径映射 1&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;hello&quot; status-code=&quot;200&quot;/&gt; 这行配置，表示如果用户访问 /hello 这个路径，则直接将名为 hello 的视图返回给用户，并且响应码为 200，这个配置就可以替代 Controller 中的方法。 12345678@Configuration@ComponentScan(basePackages = &quot;org.javaboy&quot;)public class SpringMVCConfig extends WebMvcConfigurationSupport { @Override protected void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/hello3&quot;).setViewName(&quot;hello&quot;); }} JSON 配置SpringMVC 可以接收JSON 参数，也可以返回 JSON 参数，这一切依赖于 HttpMessageConverter。 HttpMessageConverter 可以将一个 JSON 字符串转为 对象，也可以将一个对象转为 JSON 字符串，实际上它的底层还是依赖于具体的 JSON 库。所有的 JSON 库要在 SpringMVC 中自动返回或者接收 JSON，都必须提供和自己相关的 HttpMessageConverter 。SpringMVC 中，默认提供了 Jackson 和 gson 的 HttpMessageConverter ，分别是：MappingJackson2HttpMessageConverter 和 GsonHttpMessageConverter 。正因为如此，我们在 SpringMVC 中，如果要使用 JSON ，对于 jackson 和 gson 我们只需要添加依赖，加完依赖就可以直接使用了。具体的配置是在 AllEncompassingFormHttpMessageConverter 类中完成的。如果开发者使用了 fastjson，那么默认情况下，SpringMVC 并没有提供 fastjson 的 HttpMessageConverter ，这个需要我们自己提供，如果是在 XML 配置中，fastjson 除了加依赖，还要显式配置 HttpMessageConverter，如下： 123456&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 第1章Spring Boot入门 提供一个快速的Spring项目搭建渠道 开箱即用,很少的Spring 配置就能运行一个Java EE项目。 提供了生产级的服务监控方案。 内嵌服务器,可以快速部署。 提供了一系列非功能性的通用配置。 纯Java配置,没有代码生成,也不需要XML配置。 第2章 Spring Boot基础配置工程创建的三种方式： 在线创建 通过 IDE 来创建（IntelliJ IDEA、STS） 通过改造一个普通的 Maven 工程来实现2.1不使用spring-boot-starter-parentspring-boot-starter-parent主要提供了如下默认配置: Java版本默认使用1.8.编码格式 默认使用UTF-8. 提供Dependency Management进行项目依赖的版本管理。 默认的资源过滤与插件配置2.2 @Spring BootApplication.1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {... @Spring BootApplication 是一个组合注解： @SpringBootConfiguration原来就是一个@Configuration,所以@Spring BootConfiguration的功能就是表明这是一个配置类。开发者可以在这个类中配置Bean。从这个角度来讲,这个类所扮演的角色有点类似于Spring中applicationContext.xml文件的角色。 第二个注解@EnableAutoConfiguration表示开启自动化配置。 Spring Boot中的自动化配置是非侵入式的,在任意时刻,开发者都可以使用自定义配置代替自动化配置中的某一个配置。 第三个注解@ComponentScan完成包扫描,也是Spring中的功能。由于@ComponentScan注解默认扫描的类都位于当前类所在包的下面,因此建议在实际项目开发中把项目启动类放在根包。 2.3定制banner Spring Boot项目在启动时会打印一个banne 定制网站：http://patorjk.com/software/taag12345678@SpringBootApplicationpublic class SpringBootDemoApplication { public static void main(String[] args) { SpringApplicationBuilder builder = new SpringApplicationBuilder(SpringBootDemoApplication.class); builder.bannerMode(Banner.Mode.OFF).run(args); }} 2.4 Web容器配置2.4.1 Tomcat配置123456789101112131415##配置了Web容器的端口号。server.port=8081 ##配置了当项目出错时跳转去的页面。server.error.path=/error ##配置了session失效时间, 30m表示30分钟,如果不写单位,默认单位是秒。由于Tomcat中配置session过期时间以分钟为单位,因此这里单位如果是秒的话,该时间会被转换为一个不超过所配置秒数的最大分钟数,例如这里配置了119,默认单位为秒,则实际session过期时间为1分钟。server.servlet.session.timeout=30m##表示项目名称,不配置时默认为/,如果配置了,就要在访问路径中加上配置的路径。server.servlet.context-path=/ ##表示配置Tomcat请求编码。server.tomcat.uri-encoding=utf-8##表示Tomcat最大线程数。server.tomcat.threads.max=500 ##是一个存放Tomcat运行日志和临时文件的目录,若不配置,则默认使用系统的临时目录。server.tomcat.basedir=/home/sang/tmp ## HTTPS的配置：123456## 密匙文件server.ssl.key-store=sang.p12## 密匙别名server.ssl.key-alias=tomcathttps## 就是在cmd命令执行过程中输入的密码server.ssl.key-store-password=123456 Spring Boot不支持同时在配置中启动HTTP和HTTPS,这个时候可以配置请求重定向,将HTTP请求重定向为HTTPS请求。配置方式如下:123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class TomcatConfig { /* * @return * @Description : TODO 配置一个 TomcatServletWebServerFactory 的Bean， * @author Liruilong * @date 2021/6/3 11:47 **/ @Bean TomcatServletWebServerFactory tomcatServletWebServerFactory() { TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(){ @Override protected void postProcessContext(Context context) { SecurityConstraint constraint = new SecurityConstraint(); constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;); SecurityCollection collection = new SecurityCollection(); collection.addPattern(&quot;/*&quot;); constraint.addCollection(collection); context.addConstraint(constraint); } }; factory.addAdditionalTomcatConnectors(createTomcatConnector()); return factory; } /* * @return * @Description * @author Liruilong * @date 2021/6/3 11:45 **/ private Connector createTomcatConnector() { Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;); connector.setScheme(&quot;http&quot;); connector.setPort(8080); connector.setSecure(false); connector.setRedirectPort(8081); return connector; }} 这里首先配置一个TomcatServletWebServerFactory,然后添加一个Tomcat中的Connector (监听8080端口) ,并将请求转发到8081上去。2.4.2 Jetty配置除了Tomcat外,也可以在Spring Boot中嵌入Jetty,从spring-boot-starter-web中除去默认的Tomcat,然后加入Jetty的依赖即可配置方式如下:12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.4.3 Undertow配置Undertow是一个红帽公司开源的Java服务器,具有非常好的性能,在Spring Boot中也得到了很好的支持,配置方式与Jetty类似。2.5 Properties配置Spring Boot项目中的·application.properties配置文件一共可以出现在如下4个位置:加载的优先级从1到4依次降低 项目根目录下的config文件夹中。 项目根目录下。 classpath 下的config文件夹中。 classpath 下 application.yml配置文件的优先级与上面一致默认情况下, 如果开发者不想使用application.properties作为配置文件名,也可以自己定义。例如,在resources目录下创建一个配置文件app.properties,然后将项目打成jar包,打包成功后,使用如下命令运行: 2.6类型安全配置属性.Spring提供了@Value注解以及EnvironmentAware接口来将Spring Environment中的数据注入到属性上, Spring Boot对此进一步提出了类型安全配置属性(Type-safe ConfigurationProperties) ,这样即使在数据量非常庞大的情况下,也可以更加方便地将配置文件中的数据注入Bean中.yml类型配置文件： 12345678910111213my: users: - name: 江南一点雨 address: China favorites: - 足球 - 徒步 - Coding - name: sang address: GZ favorites: - 阅读 - 吉他 123456789/** * Created by sang on 2018/7/5. */@Component@ConfigurationProperties(prefix = &quot;my&quot;)public class Users { private List&lt;User&gt; users;} 2.7 YAML配置YAML是JSON的超集,简洁而强大,是一种专门用来书写配置文件的语言,可以替代application.properties。在创建一个Spring Boot项目时,引入的spring-boot-starter-web依赖间接地引入了snakeyaml依赖, snakeyaml会实现对YAML配置的解析。YAML的使用非常简单,利用缩进来表示层级关系,并且大小写敏感。在Spring Boot项目中使用YAML只需要在resources目录下创建一个application.yml文件即可,然后向application.yml中添加配置: 1234567891011121314151617181920server: port: 80 servlet: context-path: /chapter02 tomcat: uri-encoding: utf-8my: users: - name: 江南一点雨 address: China favorites: - 足球 - 徒步 - Coding - name: sang address: GZ favorites: - 阅读 - 吉他 2.8 Profile开发者在项目发布之前,配置需要频繁更改,例如数据库配置、redis配置、mongodb配置、jms配置等。频·繁修改带来了巨大的工作量, Spring对此提供了解决方案(@Profile注解) , Spring Boot则更进一步提供了更加简洁的解决方案, Spring Boot中约定的不同环境下配置文件名称规则为application-{profile}.properties, profile占位符表示当前环境的名称,具体配置步骤如下: 不同的环境指定不同的配置文件1spring.profiles.active=dev 第3章Spring Boot整合视图层技术Spring Boot官方推荐使用的模板引擎是Thymeleaf,不过像FreeMarker也支持, JSP技术在这里并不推荐使用。下面分别向读者介绍Spring Boot整合Thymeleaf和FreeMarker两种视图层技术。 3.1整合ThymeleafThymeleaf是新一代Java模板引擎,类似于Velocity, FreeMarker等传统Java模板引擎。与传统Java模板引擎不同的是, Thymeleaf支持HTML原型,既可以让前端工程师在浏览器中直接打开查看样式,也可以让后端工程师结合真实数据查看显示效果。同时, Spring Boot提供了Thymeleaf自动化配置解决方案,因此在Spring Boot中使用Thymeleaf非常方便。Spring Boot整合Thymeleaf主要可通过如下步骤: 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2．配置ThymeleafSpring Boot为Thymeleaf提供了自动化配置类ThymeleafAutoConfiguration,相关的配置属性在ThymeleatProperties类中, ThymeleafProperties部分源码如下:如果开发者想对默认的Thymeleaf配置参数进行自定义配置,那么可以直接在application.properties中进行配置,部分常见配置如下: 1234567891011121314#是否开启缓存，开发时可设置为false，默认为truespring.thymeleaf.cache=true#是否检查模板是否存在，默认为truespring.thymeleaf.check-template=true#是否检查模板位置是否存在，默认为truespring.thymeleaf.check-template-location=true#模板文件编码spring.thymeleaf.encoding=UTF-8#模板文件位置spring.thymeleaf.prefix=classpath:/templates/#Content-Type配置spring.thymeleaf.servlet.content-type=text/html#模板文件后缀spring.thymeleaf.suffix=.html 官网： https://www.thymeleaf.org 3.2整合FreeMarkeFreeMarker是一个非常古老的模板引擎,可以用在Web环境或者非Web环境中。与Thymeleaf不同, FreeMarker需要经过解析才能够在浏览器中展示出来。FreeMarker不仅可以用来配置HTML页面模板,也可以作为电子邮件模板、配置文件模板以及源码模板等。Spring Boot中对FreeMarker整合也提供了很好的支持. 配置FreeMarkerSpring Boot对FreeMarker也提供了自动化配置类FreeMarkerAutoConfiguration,相关的配置属性在FreeMarkerProperties 中, 1234567891011121314151617181920#HttpServletRequest的属性是否可以覆盖controller中model的同名项spring.freemarker.allow-request-override=false#HttpSession的属性是否可以覆盖controller中model的同名项spring.freemarker.allow-session-override=true#是否开启缓存spring.freemarker.cache=fal se#模板文件编码spring.freemarker.charset=UTF-8#是否检查模板位置spring.freemarker.check-template-location=true#Content-Type的值spring.freemarker.content-type=text/html#是否将HttpServletRequest中的属性添加到Model中spring.freemarker.expose-request-attributes=false#是否将HttpSession中的属性添加到Model中spring.freemarker.expose-session-attributes=true#模板文件后缀spring.freemarker.suffix=.ftl#模板文件位置spring.freemarker.template-loader-path=classpath:/templates/ 官网：https://freemarker.apache.org/ 3.3 整合 JSP123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910111213141516171819package com.liruilong.spring_boot_demo.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @Classname WebMvcConfig * @Description TODO * @Date 2021/6/4 10:02 * @Created Li Ruilong */@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void configureViewResolvers(ViewResolverRegistry registry) { registry.jsp(&quot;/WEB-INF/jsp/&quot;, &quot;.jsp&quot;); }} 第4章 Spring Boot整合Web开发.4.1返回JSON数据4.1.1 默认实现JSON是目前主流的前后端数据传输方式, Spring MVC中使用消息转换器HttpMessageConverter对JSON的转换提供了很好的支持,在Spring Boot中更进一步,对相关配置做了更进一步的简化。默认情况下,当开发者新创建一个Spring Boot项目后,添加Web依赖,这个依赖中默认加入了jackson-databind作为JSON处理器,此时不需要添加额外的JSON处理器就能返回一段JSON了. 如果需要频繁地用到@ResponseBody注解,那么可以采用@RestController 组合注解代替@Controller和@ResponseBody 这是Spring Boot自带的处理方式。如果采用这种方式,那么对于字段忽略、日期格式化等常见需求都可以通过注解来解决。这是通过Spring中默认提供的MappingJackson2HttpMessageConverter来实现的.HttpMessageConverter ，看名字就知道，这是一个消息转换工具，有两方面的功能： 将服务端返回的对象序列化成 JSON 字符串 将前端传来的 JSON 字符串反序列化成 Java 对象所有的 JSON 生成都离不开相关的 HttpMessageConverter,SpringMVC 自动配置了 Jackson 和 Gson 的 HttpMessageConverter，Spring Boot 中又对此做了自动化配置： org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfiguration 所以，如果用户使用 jackson 和 gson 的话，没有其他额外配置，则只需要添加依赖即可。 修改转化器添加一个MappingJackson2HttpMessageConverter，由@ConditionalOnMissingBean确定。嗯，我们温习一下条件化注解吧 当然这里我们也可以只定义一个 ObjectMapper 1234567891011121314151617181920212223242526272829303132package com.liruilong.spring_boot_demo.config;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;import java.text.SimpleDateFormat;/** * @Classname WebMvcConfig * @Description TODO * @Date 2021/6/4 10:02 * @Created Li Ruilong */@Configurationpublic class WebMvcConfig { @Bean MappingJackson2HttpMessageConverter mappingJackson2CborHttpMessageConverter(){ return new MappingJackson2HttpMessageConverter(objectMapper()); } @Bean ObjectMapper objectMapper() { ObjectMapper om = new ObjectMapper(); om.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); return om; } } 4.1.2 自定义转换器当然开发者在这里也可以根据实际需求自定义JSON转换器。常见的JSON处理器除了jackson-databind之外,还有Gson和fastison,这里针对常见用法分别举例. GsonGson是Google的一个开源JSON解析框架。使用Gson,需要先除去默认的jackson-databind,然后加入Gson依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt;&lt;/dependency&gt; 由于Spring Boot中默认提供了Gson的自动转换类GsonHttpMessageConvertersConfiguration,因此Gson的依赖添加成功后,可以像使用jackson-databind那样直接使用Gson。但是在Gson进行·转换时,如果想对日期数据进行格式化,那么还需要开发者自定义HttpMessageConverter.自定义HttpMessageConverter可以通过如下方式。也可以直接使用Gson对象。 1234567891011121314151617@Configurationpublic class WebMvcConfig {// @Bean// GsonBuilder gsonBuilder() {// GsonBuilder gsonBuilder = new GsonBuilder();// gsonBuilder.setDateFormat(&quot;yyyy-MM-dd&quot;);// return gsonBuilder;// } @Bean GsonHttpMessageConverter gsonHttpMessageConverter() { GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.setDateFormat(&quot;yyyy-MM-dd&quot;); GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(gsonBuilder.create()); return converter; }} fastisonfastjson是阿里巴巴的一个开源JSON解析框架,是目前JSON解析速度最快的开源框架,该框架也可以集成到Spring Boot中。不同于Gson, fastjson继承完成之后并不能立马使用,需要开发者提供相应的HttpMessageConverter后才能使用,集成fastison的步骤如下。 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; 1spring.http.encoding.force-response=true 对于FastlsonHttpMessageConverter的配置,除了FastJsonHttpMessageConverter 这种方式之外,还有另一种方式。在Spring Boot项目中,当开发者引入spring-boo-starter-web依赖之后,该依赖又依赖了spring-boot-autoconfigure,在这个自动化配置中,有一个webMvcAutoConfiguration类提供了对Spring MVC最基本的配置,如果某一项自动化配置不满足开发需求,开发者可以针对该项自定义配置,只需要实现WebMveConfigurer接口即可(在Spring 5.0之前是通过继承WebMvcConfigurerAdapter类来实现的) ,代码如下: 12345678910111213141516171819202122232425@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setCharset(Charset.forName(&quot;UTF-8&quot;)); fastJsonConfig.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); converter.setFastJsonConfig(fastJsonConfig); converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;)); converters.add(converter); }// @Bean// FastJsonHttpMessageConverter fastJsonHttpMessageConverter() {// FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();// FastJsonConfig fastJsonConfig = new FastJsonConfig();// fastJsonConfig.setCharset(Charset.forName(&quot;UTF-8&quot;));// fastJsonConfig.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);// converter.setFastJsonConfig(fastJsonConfig);// converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));// return converter;// }} 4.2静态资源访问在Spring MVC中,对于静态资源都需要开发者手动配置静态资源过滤。Spring Boot中对此也提供了自动化配置,可以简化静态资源过滤配置。 Spring MVC中的配置：xml 123&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot;/&gt;&lt;mvc:resources mapping=&quot;/html/**&quot; location=&quot;/html/&quot;/&gt; 由于这是一种Ant风格的路径匹配符，/** 表示可以匹配任意层级的路径，因此上面的代码也可以像下面这样简写： 1&lt;mvc:resources mapping=&quot;/**&quot; location=&quot;/&quot;/&gt; java:重写 WebMvcConfigurationSupport 类中的addResourceHandlers方法，在该方法中配置静态资源位置即可 4.2.1默认策略Spring Boot中对于Spring MVC的自动化配置都在webMvcAutoConfiguration类中,因此对于默认的静态资源过滤策略可以从这个类中一窥究竟。在WebMvcAutoConfiguration类中有一个静态内部类webMvcAutoConfigurationAdapter,实现了4.1节提到的WebMvcConfigurer接口。webMvcConfigurer接口中有一个方法addResourceHandlers是用来配置静态资源过滤的。方法在WebMvcAutoConfigurationAdapter类中得到了实现,部分核心代码如下Spring Boot在这里进行了默认的静态资源过滤配置,其中staticPathPattern默认定义在WebMvcProperties 中registration.addResourceLocations(this.resourceProperties.getStaticLocations());获取到的默认静态资源位置定义在ResourceProperties 在一个新创建的Spring Boot项目中,添加了spring-boot-starter-web依赖之后,在resources目录下分别创建4个目录, 4个目录中放入同名的静态资源(如图4-4所示,数字表示不同位置资源的优先级) 4.2.2自定义策略自定义静态资源过滤策略有以下两种方式; 在配置文件中定义可以在application.properties中直接定义过滤规则和静态资源位置, 1234# 静态资源位置spring.web.resources.static-locations=classpath:/static/# 过滤规则spring.mvc.static-path-pattern=/static/** Java编码定义也可以通过Java编码方式来定义,此时只需要实现WebMveConfigurer接口即可,然后实现该接口的addResourceHandlers方法,代码如下: 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;); }} 4.3文件上传.Spring MVC对文件上传做了简化,在Spring Boot中对此做了更进一步的简化,文件上传更为方便。Java中的文件上传一共涉及两个组件,一个是CommonsMultipartResolver,另一个是StandardServletMultipartResolver.其中CommonsMultipartResolver使用commons-fileupload来处理multipart请求,而StandardServletMultipartResolver则是基于Servlet 3.0来处理multipart请求的,因此若使用StandardServletMultipartResolver,则不需要添加额外的jar包。Tomcat 7.0开始就支持Servlet3.0. Spring Boot提供的文件上传自动化配置类MultiparAutoConfiguraton中,默认也是采用StandardServletMultipartResolver 12spring.servlet.multipart.max-file-size=1KB..... 4.3.1单文件上传12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;/yyyy/MM/dd/&quot;); @PostMapping(&quot;/upload&quot;) public String upload(MultipartFile file, HttpServletRequest req) { String realPath = req.getServletContext().getRealPath(&quot;/&quot;); String format = LocalDate.now().format(dateTimeFormatter); String path = realPath + format; File folder = new File(path); if (!folder.exists()) { folder.mkdirs(); } String oldName = file.getOriginalFilename(); String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;)); try { file.transferTo(new File(folder, newName)); String s = req.getScheme() + &quot;://&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + format + newName; return s; } catch (IOException e) { e.printStackTrace(); } return &quot;error&quot;; } 4.3.2多文件上传12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/upload2&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; multiple&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021@PostMapping(&quot;/upload2&quot;) public void upload(MultipartFile[] files, HttpServletRequest req) { String realPath = req.getServletContext().getRealPath(&quot;/&quot;); String format = LocalDate.now().format(dateTimeFormatter); String path = realPath + format; File folder = new File(path); if (!folder.exists()) { folder.mkdirs(); } try { for (MultipartFile file : files) { String oldName = file.getOriginalFilename(); String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(&quot;.&quot;)); file.transferTo(new File(folder, newName)); String s = req.getScheme() + &quot;://&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + format + newName; System.out.println(&quot;s = &quot; + s); } } catch (IOException e) { e.printStackTrace(); } } 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/upload3&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425@PostMapping(&quot;/upload3&quot;) public void upload(MultipartFile file1, MultipartFile file2, HttpServletRequest req) { String realPath = req.getServletContext().getRealPath(&quot;/&quot;); String format = LocalDate.now().format(dateTimeFormatter); String path = realPath + format; File folder = new File(path); if (!folder.exists()) { folder.mkdirs(); } try { String oldName1 = file1.getOriginalFilename(); String newName1 = UUID.randomUUID().toString() + oldName1.substring(oldName1.lastIndexOf(&quot;.&quot;)); file1.transferTo(new File(folder, newName1)); String s1 = req.getScheme() + &quot;://&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + format + newName1; System.out.println(&quot;s1 = &quot; + s1); String oldName2 = file2.getOriginalFilename(); String newName2 = UUID.randomUUID().toString() + oldName2.substring(oldName2.lastIndexOf(&quot;.&quot;)); file2.transferTo(new File(folder, newName2)); String s2 = req.getScheme() + &quot;://&quot; + req.getServerName() + &quot;:&quot; + req.getServerPort() + format + newName2; System.out.println(&quot;s2 = &quot; + s2); } catch (IOException e) { e.printStackTrace(); } } 4.3.3AJAX文件上传12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot; integrity=&quot;sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;input type=&quot;file&quot; id=&quot;file&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;上传&quot; onclick=&quot;uploadFile()&quot;&gt;&lt;script&gt; function uploadFile() { var file = $(&quot;#file&quot;)[0].files[0]; var formData = new FormData(); formData.append(&quot;file&quot;, file); formData.append(&quot;username&quot;, &quot;javaboy&quot;); $.ajax({ type:'post', url:'/upload', processData:false, contentType:false, data:formData, success:function (msg) { $(&quot;#result&quot;).html(msg); } }) }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.4 @ControllerAdvice顾名思义, @ControllerAdvice就是@Controller的增强版。@ControllerAdvice主要用来处理全局数据,一般搭配@ExceptionHandier. @ModelAttribute以及@InitBinder使用。 4.4.1 全局异常处理上传文件大小超出限制。 123456789101112@ControllerAdvice//@Controller//@RestControllerAdvice//@RestControllerpublic class MyGlobalException { @ExceptionHandler(MaxUploadSizeExceededException.class) public ModelAndView customException(MaxUploadSizeExceededException e) { ModelAndView mv = new ModelAndView(&quot;javaboy&quot;); mv.addObject(&quot;error&quot;, e.getMessage()); return mv; }} 4.4.2 添加全局数据@ControllerAdvice是一个全局数据处理组件,因此也可以在@ControllerAdvice中配置全局数据,使用@ModelAtribute注解进行配置,代码如下: 12345678910@ControllerAdvicepublic class MyGlobalData { @ModelAttribute(&quot;info&quot;) public Map&lt;String,String&gt; mydata() { Map&lt;String, String&gt; info = new HashMap&lt;&gt;(); info.put(&quot;username&quot;, &quot;javaboy&quot;); info.put(&quot;address&quot;, &quot;www.javaboy.org&quot;); return info; } } 在全局配置中添加mydata方法,返回一个map.该方法有一个注解@ModelAttribute,其中的value属性表示这条返回数据的key,而方法的返回值是返回数据的value,此时在任意请求的Controller中,通过方法参数中的Model都可以获取info的数据。 4.4.3 请求参数预处理@ControllerAdvice结合@InitBinder还能实现请求参数预处理,即将表单中的数据绑定到实体类上时进行一些额外处理。多个实体类存在相同的字段时,会合并字段值，使用ControllerAdvice来做预处理。 12345678910111213@ControllerAdvicepublic class MyGlobalData { @InitBinder(&quot;b&quot;) public void b(WebDataBinder binder) { binder.setFieldDefaultPrefix(&quot;b.&quot;); } @InitBinder(&quot;a&quot;) public void a(WebDataBinder binder) { binder.setFieldDefaultPrefix(&quot;a.&quot;); }} 123456789@RestControllerpublic class BookController { @PostMapping(&quot;/book&quot;) public void addBook(@ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author) { System.out.println(&quot;book = &quot; + book); System.out.println(&quot;author = &quot; + author); }} 在GlobalConfig类中创建两个方法, 第一个@InitBinder(“b”)表示该方法是处理@ModelAttribute(“)对应的参数的, 第二个@nitBinder(“a”)表示该方法是处理@ModelAttribute(“a”)对应的参数的。 在WebDataBinder对象中,还可以设置允许的字段、禁止的字段、必填字段以及验证器等。 4.5 自定义错误页Spring Boot中的全局异常处理。在处理异常时,开发者可以根据实际情况返回不同的页面,但是这种异常处理方式一般用来处理应用级别的异常,有一些容器级别的错误就处理不了,例如Filter 中抛出异常,使用@ControllerAdvice定义的全局异常处理机制就无法处理。 因此, Spring Boot中对于异常的处理还有另外的方式,这就是本节要介绍的内容。在Spring Boot 中,默认情况下,如果用户在发起请求时发生了404错误, Spring Boot会有一个默认的页面展示给用户.Spring Boot中的错误默认是由BasicErrorController类来处理的,该类中的核心方法主要有两个:·errorHtml方法用来返回错误HTML页面, error用来返回错误JSON,具体返回的是HTML还是JSON,则要看请求头的Accept参数。返回JSON的逻辑很简单,不必过多介绍,返回HTML的逻辑稍微有些复杂,在errorHtml方法中,通过调用resolveErrorView方法来获取一个错误视图的ModelAndView,而resolveErrorView方法的调用最终会来到DefaultErrorViewResolver类中。DefaultErrorViewResolver类是Spring Boot中默认的错误信息视图解析器,部分源码如下: 4.5.1 简单配置.静态页面要自定义错误页面其实很简单,提供4xx和Sxx页面即可。如果开发者不需要向用户展示详细的错误信息,那么可以把错误信息定义成静态页面,直接,在resources/static 录下创建error目录,然后在error目录中创建错误展示页面。错误展示页面的命名规则有两种: 一种是4xx.html、 5xx.html; 另一种是直接使用响应码命名文件,例如404.html.405.html, 500.html.第二种命名方式划分得更细,当出错时,不同的错误会展示不同的错误页面.模板页面Spring Boot在这里一共返回了5条错误相关的信息,分别是timestamp, status, error, message以及path若用户定义了多个错误页面,则响应码html页面的优先级高于4xx.html. Sxx.tml页面的优先级,即若当前是一个404错误,则优先展示404.html而不是4xx.html;动态页面的优级高于静态页面,即若resources/templates和resource/static 同时定义了4xx.html,则优先展示resources/templates/4xx.html.4.5.2 复杂配置上面这种配置还是不够灵活,只能定义HTML页面,无法处理JSON的定制。Spring Boot中支持对Error信息的深度定制,接下来将从三个方面介绍深度定制:自定义Error数据、自定义Error视图以及完全自定义。 1.自定义Error数据自定义Error数据就是对返回的数据进行自定义。Spring Boot返回的Error信息一共有5条,分别是timestamp, status, error, message以及path,在BasicErrorController的errorHtml方法和error方法中,都是通过getErrorAttributes方法获取Error信息的。该方法最终会调用到DefaultErrorAttributes类的getErrorAttributes方法,而DefaultErrorAttributes类是在ErrorMvcAutoConfiguration中默认提供的.ErrorMvcAutoConfiguration类的errorAttributes方法源码如下:源码中可以看出,当系统没有提供ErrorAttributes时才会采用DefaultErrorAttributes.因此自定义错误提示时,只需要自己提供一个ErrorAttributes 可,而DefaultErroAttributes是ErrorAttributes的子类,因此只需要继承DefaultErrorAttributes即可 1234567891011@Componentpublic class MyErrorAtributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) { Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, options); if ((Integer) map.get(&quot;status&quot;) == 404) { map.put(&quot;message&quot;, &quot;页面不存在&quot;); } return map; }} 2,自定义Error视图Error视图是展示给用户的页面,在BasicErrorController 的errorHtml方法中调用resolveErrorView方法获取一个ModelAndView实例。 resolveErrorView方法是由ErrorViewResolver提供的,通过ErrorMvcAutoConfiguration类的源码可以看到Spring Boot默认采用的ErrorViewResolver是DefaultErrorViewResolver. ErrorMvcAutoConfiguration部分源码如下: 1234567891011121314151617@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver { public MyErrorViewResolver(ApplicationContext applicationContext, WebProperties.Resources resources) { super(applicationContext, resources); } @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.putAll(model); if ((Integer) model.get(&quot;status&quot;) == 500) { map.put(&quot;message&quot;, &quot;服务器内部错误&quot;); } ModelAndView view = new ModelAndView(&quot;javaboy/999&quot;,map); return view; }} 3,完全自定义前面提到的两种自定义方式都是对BasicErrorController类中的某个环节进行修补。查看Error自动化配置类ErrorMvcAutoConfiguration,读者可以发现BasicErrorController 身只是一个默认的配置,相关源码如下:从这段源码中可以看到,若开发者没有提供自己的ErrorController,则Spring Boot提供BasicErrorController作为默认的ErrorController,因此,如果开发者需要更加灵活地对Error视图和数据进行处理,那么只需要提供自己的ErrorController即可。提供自己的ErrorController有两种方式:一种是实现ErrorController接口,另一种是直接继承BasicErrorController,由于ErorController接口只提供一个待实现的方法,而BasicErrorController已经实现了很多功能,因此这里选择第二种方式,即通过继承BasicErrorController来实现自己的ErrorController.具体定义如下: 123456789101112131415161718192021222324252627@Controllerpublic class MyErrorController extends BasicErrorController { @Autowired public MyErrorController(ErrorAttributes errorAttributes, ServerProperties serverProperties, List&lt;ErrorViewResolver&gt; errorViewResolvers) { super(errorAttributes, serverProperties.getError(), errorViewResolvers); } @Override public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML)); model.put(&quot;custommsg&quot;, &quot;出错啦！&quot;); ModelAndView modelAndView = new ModelAndView(&quot;myErrorPage&quot;, model, status); return modelAndView; } @Override public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); body.put(&quot;custommsg&quot;, &quot;出错啦！&quot;); HttpStatus status = getStatus(request); return new ResponseEntity&lt;&gt;(body, status); }} 自定义MyErrorController继承自BasicErrorController并添加@Controller注解,将MyErrorController 注册到Spring MVC容器中· 由于BasicErrorController没有无参构造方法,因此在创建BasicErrorController实例时需要传递参数,在MyErrorController的构造方法上添加@Autowired注解注入所需参数。 参考BasicErrorController中的实现,重写errorHtml和error方法,对Error的视图和数据进行充分的自定义。 4.6 CORS支持CORS (Cross-Origin Resource Sharing)是由w3C制定的一种跨域资源共享技术标准,其目的就是为了解决前端的跨域请求。在Java EE开发中,最常见的前端跨域请求解决方案是JSONP,但是JSONP只支持GET请求,这是一个很大的缺陷,而CORS则支持多种HTTP请求方法。以CORS 响应头中有一个Access-Control-Allow-Origin字段,用来记录可以访问该资源的域。当浏览器收到这样的响应头信息之后,提取出Access-Control-Allow-Origin字段中的值,发现该值包含当前页面所在的域,就知道这个跨域是被允许的,因此就不再对前端的跨域请求进行·限制。这就是GET请求的整个跨域流程,在这个过程中,前端请求的代码不需要修改,主.要是后端进行处理。这个流程主要是针对GET, POST以及HEAD请求,并且没有自定义请求头,如果用户发起一个DELETE请求、PUT请求或者自定义了请求头,流程就会稍微复杂一些。 以DELETE请求为例,当前端发起一个DELETE请求时,这个请求的处理会经过两个步骤。第一步:发送一个OPTIONS请求。代码如下:这个请求将向服务端询问是否具备该资源的DELETE权限,服务端会给浏览器一个响应,代码如下:服务端给浏览器的响应, Allow头信息表示服务端支持的请求方法,这个请求相当于一个探测请求,当浏览器分析了请求头字段之后,知道服务端支持本次请求,则进入第二步。第二步:发送DELETE请求。接下来浏览器就会发送一个跨域的DELETE请求。 在传统的Java EE开发中,可以通过过滤器统一配置,而Spring Boot中对此则提供了更加简洁的解决方案。在Spring Boot中配置CORS的步骤如下: 3.配置跨域跨域有两个地方可以配置: 一个是直接在相应的请求方法上加注解: 这种配置方式是一种细粒度的配置.可以控制到每一个方法上。 @CrossOrigin中的value表示支持的域,这里表示来自http://ocalhost:8081域的请求是支持跨域的. maxAge表示探测请求的有效期,在前面的讲解中,读者已经了解到对于DELETE, PUT请求或者有自定义头信息的请求,在执行过程中会先发送探测请求,探测请求不用每次都发送,可以配置一个有效期,有效期过了之后才会发送探测请求。这个属性默认是1800秒,即30分钟。 allowedHeaders表示允许的请求头, *表示所有的请求头都被允许。 12345678910111213141516@RestController@RequestMapping(&quot;/book&quot;)public class BookController { @PostMapping(&quot;/&quot;) @CrossOrigin(value = &quot;http://localhost:8081&quot; ,maxAge = 1800,allowedHeaders = &quot;*&quot;) public String addBook(String name) { return &quot;receive:&quot; + name; } @DeleteMapping(&quot;/{id}&quot;) @CrossOrigin(value = &quot;http://localhost:8081&quot; ,maxAge = 1800,allowedHeaders = &quot;*&quot;) public String deleteBookById(@PathVariable Long id) { return String.valueOf(id); }} 另一种全局配置,代码如下:12345678@Overridepublic void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;*&quot;) .allowedOrigins(&quot;http://localhost:8081&quot;) .maxAge(1800);} 全局配置需要自定义类实现WebMvcConfigurer接口,然后实现接口中的addCorsMappings方法。,在addCorsMappings方法中 addMapping表示对哪种格式的请求路径进行跨域处理; allowedHeaders表示允许的请求头,默认允许所有的请求头信息; allowedMethods表示允许的请求方法,默认是GET. POST和HEAD,*表示支持所有的请求方法; maxAge表示探测请求的有效期; allowedOrigins表示支持的域。 4.7配置类与XML配置.Spring Boot推荐使用Java来完成相关的配置工作。在项目中,不建议将所有的配置放在一个配置类中,可以根据不同的需求提供不同的配置类,例如专门处理Spring Security的配置类、提供Bean的配置类、Spring MVC相关的配置类。这些配置类上都需要添加@Configuration注解。@ComponentScan注解会扫描所有的Spring组件,也包括@Configuration，@ComponentScan注解在项目入口类的@Spring BootApplication注解中已经提供,因此在实际项目中只需要按需提供相关配置类即可。Spring Boot中并不推荐使用XML配置,建议尽量用Java配置代替XML配置,本书中的案例都是以Java配置为主。 如果开发者需要使用XML配置,只需在resources目录下提供配置文件,然后通过@ImportResource加载配置文件即可。例如,有一个Book类如下: 4.8注册拦截器Spring MVC中提供了AOP风格的拦截器,拥有更加精细的拦截处理能力。Spring Boot中拦.截器的注册更加方便,步骤如下: 创建拦截器实现Handlerinterceptor接口123456789101112131415161718192021ublic class MyInterceptor implements HandlerInterceptor { //该方法返回 false，请求将不再继续往下走 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(&quot;preHandle&quot;); return true; } //Controller 执行之后被调用 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(&quot;postHandle&quot;); } //preHandle 方法返回 true，afterCompletion 才会执行。 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(&quot;afterCompletion&quot;); }} 拦截器中的方法将按preHandle-Controller-postHandle-afterCompletion的顺序执行。注意,只有preHandle方法返回true时后面的方法才会执行。当拦截器链内存在多个拦截器时, postHandler在拦截器链内的所有拦截器返回成功时才会调用,而afterCompletion只有preHandle返回true才调用,但若拦截器链内的第一个拦截器的preHandle方法返回false,则后面的方法都不会执行。 配置拦截器。定义配置类进行拦截器的配置,代码如下:自定义类实现webMveConfigurer接口,实现接口中的addInterceptors方法。其中,addPathPatterns 表示拦截路径, excludePathPatterns表示排除的路径。 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/hello&quot;); }} 4.9启动系统任务有一些特殊的任务需要在系统启动时执行,例如配置文件加载、数据库初始化等操作。如果没有使用Spring Boot,这些问题可以在Listener中解决。Spring Boot对此提供了两种解决方案:CommandLineRunner和ApplicationRunner. CommandLineRunner和ApplicationRunner基本一致,差别主要体现在参数上。 4.9.1 CommandLineRunnerSpring Boot项目在启动时会遍历所有CommandLineRunner的实现类并调用其中的run方法,如果整个系统中有多个CommandLineRunner的实现类,那么可以使用@Order注解对这些实现类的调用顺序进行排序。 4.9.2 ApplicationRunnerApplicationRunner的用法和CommandLineRunner基本一致,区别主要体现在run方法的参数上。 1234567891011121314151617@Component@Order(98)public class MyApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取没有键的参数，获取到的值和 commandlinerunner 一致 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(&quot;nonOptionArgs1 = &quot; + nonOptionArgs); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String optionName : optionNames) { System.out.println(optionName + &quot;-1-&gt;&quot; + args.getOptionValues(optionName)); } //获取命令行中的所有参数 String[] sourceArgs = args.getSourceArgs(); System.out.println(&quot;sourceArgs1 = &quot; + Arrays.toString(sourceArgs)); }} 1234567891011121314151617@Component@Order(97)public class MyApplicationRunner2 implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取没有键的参数，获取到的值和 commandlinerunner 一致 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(&quot;nonOptionArgs2 = &quot; + nonOptionArgs); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String optionName : optionNames) { System.out.println(optionName + &quot;-2-&gt;&quot; + args.getOptionValues(optionName)); } //获取命令行中的所有参数 String[] sourceArgs = args.getSourceArgs(); System.out.println(&quot;sourceArgs2 = &quot; + Arrays.toString(sourceArgs)); }} @Order注解依然是用来描述执行顺序的,数字越小越优先执行。不同于CommandLineRunner中run方法的String数组参数,这里run方法的参数是一个ApplicationArguments对象,如果想从ApplicationArguments对象中获取入口类中1main方法1接收的参数,调用ApplicationArguments中的getNonOptionArgs方法即可. ApplicationArguments中的getOptionNames方法用来获取项目启动命令行中参数的key,例如将本项目打成jar包,运行java-jar xxx.jar-name-Michael命令来启动项目,此时getOptionNames方法获取到的就是name,而getOptionValues方法则是获取相应的value. 4.10整合Servlet, Filter和Listener.Spring Boot中对于整合这些基本的Web组件也提供了很好的支持。在一个Spring Boot Web项目中添加如下三个组件: 1234567891011121314151617@WebFilter(&quot;/*&quot;)public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig){ System.out.println(&quot;MyFilter&gt;&gt;&gt;init&quot;); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;MyFilter&gt;&gt;&gt;doFilter&quot;); chain.doFilter(request,response); } @Override public void destroy() { System.out.println(&quot;MyFilter&gt;&gt;&gt;destroy&quot;); }} 1234567891011@WebListenerpublic class MyListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;MyListener&gt;&gt;&gt;requestDestroyed&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;MyListener&gt;&gt;&gt;requestInitialized&quot;); }} 1234567891011@WebServlet(&quot;/my&quot;)public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp){ doPost(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp){ System.out.println(&quot;name&gt;&gt;&gt;&quot;+req.getParameter(&quot;name&quot;)); }} 启动类需要的配置：在项目入口类上添加@ServletComponentScan注解,实现对Servlet， Filter以及Listener的扫描,代码如下: 123456789@SpringBootApplication@ServletComponentScan(&quot;org.javaboy.filter&quot;)public class FilterApplication { public static void main(String[] args) { SpringApplication.run(FilterApplication.class, args); }} 4.11 路径映射.有一些页面在控制器中不需要加载数据,只是完成·简单的跳转,对于这种页面,可以直接配置路径映射,提高访问速度。例如,有两个Thymeleaf做模板的页面login.html和index.tml,直接在MVC配置中重写addViewControllers方法配置映射关系即可: 12345678@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) {// registry.addViewController(&quot;/02&quot;).setViewName(&quot;02&quot;); registry.addViewController(&quot;/02&quot;).setViewName(&quot;02&quot;); }} 4.12 配置AOP4.12.1 AOP简介AOP中的相关知识4.12.2 Spring Boot支持Spring Boot在Spring的基础上对AOP的配置提供了自动化配置解决方案spring-boot-starter-aop,使开发者能够更加便捷地在Spring Boot项目中使用AOP,配置步骤如下。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Component@Aspectpublic class LogAspect { @Pointcut(&quot;execution(* org.javaboy.aop.service.*.*(..))&quot;) public void pc1() { } @Before(&quot;pc1()&quot;) public void before(JoinPoint jp) { String name = jp.getSignature().getName(); System.out.println(name + &quot; 方法开始执行了...&quot;); } @After(&quot;pc1()&quot;) public void after(JoinPoint jp) { String name = jp.getSignature().getName(); System.out.println(name + &quot; 方法执行结束了...&quot;); } @AfterReturning(value = &quot;pc1()&quot;, returning = &quot;s&quot;) public void afterReturning(JoinPoint jp, String s) { String name = jp.getSignature().getName(); System.out.println(name + &quot; 方法的返回值是 &quot; + s); } @AfterThrowing(value = &quot;pc1()&quot;, throwing = &quot;e&quot;) public void afterThrowing(JoinPoint jp, Exception e) { String name = jp.getSignature().getName(); System.out.println(name + &quot; 方法抛出了异常 &quot; + e.getMessage()); } @Around(&quot;pc1()&quot;) public Object around(ProceedingJoinPoint pjp) { try { //类似于反射中的 invoke 方法 Object proceed = pjp.proceed(); return proceed; } catch (Throwable throwable) { throwable.printStackTrace(); } return null; }} 4.13 其他4.13.1 自定义欢迎页Spring Boot项目在启动后,首先会去静态资源路径下查找index.html作为首页文件,若查找不到,则会去查找动态的index文件作为首页文件. 使用静态的index.html页面作为项目首页,那么只需在resources/static目录下创建index.html文件即可。 若想使用动态页面作为项目首页,则需在resources/templates目录下创建index.html (使用Thymeleaf模板)或者index.fl (使用FreeMarker模板) ,然后在Controller中返回逻辑视图名,代码如下: 12345678@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/index&quot;).setViewName(&quot;index&quot;); }} 4.13.2 自定义faviconfavicon.ico是浏览器选项卡左上角的图标,可以放在静态资源路径下或者类路径下,静态资源路径下的favicon.ico优先级高于类路径下的favicon.ico。在线转换网站http:/inaconvert.com/cn/convert-to-ico.php将一张普通图片转为.ico图 4.13.3 除去某个自动配置Spring Boot中提供了大量的自动化配置类,例如上文提到过的ErrorMvcAutoConfiguration、ThymeleafAutoConfiguration, FreeMarkerAutoConfiguration, MultipartAutoConfiguration等,这些自动化配置可以减少相应操作的配置,达到开箱即用的效果。在Spring Boot的入口类上有一个@Spring BootApplication注解。该注解是一个组合注解, 由@Spring BootConfiguration、@EnableAutoConfiguration以及@ComponentScan组成,其中@EnableAutoConfiguration注解开启自动化配置,相关的自动化配置类就会被使用。如果开发者不想使用某个自动化配置,按如下方式除去相关配置即可. 1234567@SpringBootApplication@EnableAutoConfiguration(exclude = {ErrorMvcAutoConfiguration.class})public class OtherApplication { public static void main(String[] args) { SpringApplication.run(OtherApplication.class, args); }} 4.13.4 使用类型转化器12345678910111213@Componentpublic class MyDateConverter implements Converter&lt;String, Date&gt; { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); @Override public Date convert(String source) { try { return sdf.parse(source); } catch (ParseException e) { e.printStackTrace(); } return null; }} 第5章Spring Boot整合持久层技术. Spring Boot中对常见的持久层框架都提供了自动化配置,例如JabcTemplate, JPA等, MyBatis的自动化配置则是MyBatis官方提供的。 5.1 整合JdbcTemplateJdbcTemplate是Spring提供的一套JDBC模板框架,利用AOP技术来解决直接使用JDBC时大量重复代码的问题。JdbcTemplate虽然没有MyBatis那么灵活,但是比直接使用JDBC要方便很多。Spring Boot中对JdbcTemplate的使用提供了自动化配置类JdbcTemplateConfiguration,部分源码如下: 12345678910@Configuration(proxyBeanMethods = false)@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })@ConditionalOnSingleCandidate(DataSource.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)@EnableConfigurationProperties(JdbcProperties.class)@Import({ DatabaseInitializationDependencyConfigurer.class, JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class })public class JdbcTemplateAutoConfiguration {} 1234567891011121314151617@Configuration(proxyBeanMethods = false)@ConditionalOnMissingBean(JdbcOperations.class)class JdbcTemplateConfiguration { @Bean @Primary JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); JdbcProperties.Template template = properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) { jdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds()); } return jdbcTemplate; }} 需要的依赖： 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; spring-bool-starter-jdbc 中提供了spring-jdbc,另外还加入了数据库驱动依赖和数据库连接池依赖 12345# 数据源1spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.one.username=rootspring.datasource.one.password=123spring.datasource.one.url=jdbc:mysql:///chapter05-1 创建BookDao,注入JdbcTemplate.由于已经添加了spring-jdbc相关的依赖, JabcTemplate会被自动注册到Spring容器中,因此这里可以直接注入JdbcTemplate使用。 在JdbcTemplate中,增删改三种类型的操作主要使用update和batchUpdate方法来完成.query和queryForObject方法主要用来完成查询功能。另外,还有execute方法可以用来执行任意的sQL. call方法用来调用存储过程等。 在执行查询操作时,需要有一个RowMapper将查询出来的列和实体类中的属性-一对应起来。如果列名和属性名都是相同的,那么可以直接使用BeanPropertyRowMapper;如果列名和属性名不同,就需要开发者自己实现RowMapper接口,将列和实体类属性-一对应起来。123456789101112131415161718192021222324@Repositorypublic class BookDao { @Autowired JdbcTemplate jdbcTemplate; public int addBook(Book book) { return jdbcTemplate.update(&quot;INSERT INTO book(name,author) VALUES (?,?)&quot;, book.getName(), book.getAuthor()); } public int updateBook(Book book) { return jdbcTemplate.update(&quot;UPDATE book SET name=?,author=? WHERE id=?&quot;, book.getName(), book.getAuthor(), book.getId()); } public int deleteBookById(Integer id) { return jdbcTemplate.update(&quot;DELETE FROM book WHERE id=?&quot;, id); } public Book getBookById(Integer id) { return jdbcTemplate.queryForObject(&quot;select * from book where id=?&quot;, new BeanPropertyRowMapper&lt;&gt;(Book.class), id); } public List&lt;Book&gt; getAllBooks() { return jdbcTemplate.query(&quot;select * from book&quot;, new BeanPropertyRowMapper&lt;&gt;(Book.class)); }} 1234567891011121314public int addUser2(User user) { GeneratedKeyHolder keyHolder = new GeneratedKeyHolder(); int result = jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException { PreparedStatement ps = connection.prepareStatement(&quot;insert into user (username,address) values(?,?)&quot;, Statement.RETURN_GENERATED_KEYS); ps.setString(1, user.getUsername()); ps.setString(2, user.getAddress()); return ps; } }, keyHolder); user.setId(keyHolder.getKey().longValue()); return result; } 12345678910111213141516public List&lt;User&gt; getAllUsers() { List&lt;User&gt; list = jdbcTemplate.query(&quot;select * from user&quot;, new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet resultSet, int i) throws SQLException { String username = resultSet.getString(&quot;username&quot;); String address = resultSet.getString(&quot;address&quot;); long id = resultSet.getLong(&quot;id&quot;); User user = new User(); user.setId(id); user.setUsername(username); user.setAddress(address); return user; } }); return list; } 5.2整合MyBatisMyBatis是一款优秀的持久层框架,原名叫作iBaits, 2010年由ApacheSoftwareFoundation迁移到Google Code并改名为MyBatis, 2013年又迁移到GitHub上。MyBatis支持定制化SQL、存储过程以及高级映射。MyBatis几乎避免了所有的JDBC代码手动设置参数以及获取结果集。在传统的SSM框架整合中,使用MyBatis需要大量的XML配置,而在Spring Boot中, MyBatis官方提供了一套自动化配置方案,可以做到MyBatis开箱即用。具体使用步骤如下。 添加MyBatis依赖、数据库驱动依赖以及数据库连接池123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1234spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql:///chapter05spring.datasource.username=rootspring.datasource.password=123 方法一123456789@SpringBootApplication@MapperScan(basePackages = &quot;org.javaboy.mybatis.mapper&quot;)public class MybatisApplication { public static void main(String[] args) { SpringApplication.run(MybatisApplication.class, args); }} 一种简单的方式是在配置类上添加@MapperScan(&quot;org.sang.mapper&quot;)注解,表示扫描org.sang.mapper包下的所有接口作为Mapper,这样就不需要在每个接口上配置@Mapper注解了。1234567891011121314151617181920public interface UserMapper { @Select(&quot;select * from user where id=#{id}&quot;) User getUserById(Long id); @Results({ @Result(property = &quot;address&quot;,column = &quot;address1&quot;) }) @Select(&quot;select * from user&quot;) List&lt;User&gt; getAllUsers(); @Insert(&quot;insert into user (username,address1) values (#{username},#{address})&quot;) @SelectKey(statement = &quot;select last_insert_id()&quot;,keyProperty = &quot;id&quot;,before = false,resultType = Long.class) Integer addUser(User user); @Delete(&quot;delete from user where id=#{id}&quot;) Integer deleteById(Long id); @Update(&quot;update user set username=#{username} where id=#{id}&quot;) Integer updateById(String username, Long id);} 方法二指明该类是一个Mapper:第一种如前面的代码所示,在BookMapper上添加@Mapper注解,表明该接口是一个MyBatis中的Mapper,这种方式需要在每一个Mapper上都添加注解;12345678@Mapperpublic interface BookMapper { int addBook(Book book); int deleteBookById(Integer id); int updateBookById(Book book); Book getBookById(Integer id); List&lt;Book&gt; getAllBooks();} 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.sang.mapper.BookMapper&quot;&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;org.sang.model.Book&quot;&gt; INSERT INTO book(name,author) VALUES (#{name},#{author}) &lt;/insert&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; DELETE FROM book WHERE id=#{id} &lt;/delete&gt; &lt;update id=&quot;updateBookById&quot; parameterType=&quot;org.sang.model.Book&quot;&gt; UPDATE book set name=#{name},author=#{author} WHERE id=#{id} &lt;/update&gt; &lt;select id=&quot;getBookById&quot; parameterType=&quot;int&quot; resultType=&quot;org.sang.model.Book&quot;&gt; SELECT * FROM book WHERE id=#{id} &lt;/select&gt; &lt;select id=&quot;getAllBooks&quot; resultType=&quot;org.sang.model.Book&quot;&gt; SELECT * FROM book &lt;/select&gt;&lt;/mapper&gt; 针对BookMapper接口中的每一个方法都在BookMapper.xml中列出了实现 #{}用来代替接口中的参数,实体类中的属性可以直接通过#(实体类属性名}获取。配置pom.xml文件在Maven工程中, XML配置文件建议写在resources目录下(同包同级目录),当Mapper.xml文件写在包下, ·Maven在运行时会忽略包下的XML文件,因此需要在pom.xml文件中重新指明资源文件位置,配置如下:1234567891011121314&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; ......&lt;/build&gt; 也可以自定义resources下mapper位置1mybatis.mapper-locations=classpath:mapper/*.xml 5.3整合Spring Data JPAJPA (Java Persistence API)和Spring Data是两个范畴的概念。JPA则是一种ORM规范, JPA和Hibernate的关系就像JDBC与JDBC驱动的关系,即JPA制定了ORM规范,而Hibernate是这些规范的实现(事实上,是先有Hibernate后有JPA, JPA规范的起草者也是Hibernate的作者) ,因此从功能上来说, JPA相当于Hibernate的一个子集。 Spring Data是Spring的一个子项目,致力于简化数据库访问,通过规范的方法名称来分析开发者的意图,进而减少数据库访问层的代码量。Spring Data不仅支持关系型数据库,也支持非关系型数据库。Spring Data JPA可以有效 简化 关系型数据库访问代码。Spring Boot整合Spring Data JPA的步骤如下: 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 123456789101112spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.url=jdbc:mysql:///jpaspring.datasource.username=rootspring.datasource.password=123spring.jpa.show-sql=truespring.jpa.database=mysqlspring.jpa.hibernate.ddl-auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57InnoDBDialect#spring.jpa.properties.database=mysql#spring.jpa.properties.hibernate.hbm2ddl.auto=update#spring.jpa.properties.show-sql= true @Entity注解表示该类是一个实体类,在项目启动时会根据该类自动生成一张表,表的名称即@Entity注解中name的值,如果不配置name,默认表名为类名。所有的实体类都要有主键, @ld注解表示该属性是一个主键, @GeneratedValue注解表示主键自动生成, strategy则表示主键的生成策略。默认情况下,生成的表中字段的名称就是实体类中属性的名称,通过@Column注解可以定制生成的字段的属性, name表示该属性对应的数据表中字段的名称, nullable表示该字段非空。 @Transient注解表示在生成数据库中的表时,该属性被忽略,即不生成对应的字段。12345678910111213@Entity(name = &quot;t_book&quot;)public class Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = &quot;book_name&quot;,nullable = false) private String name; private String author; private Float price; @Transient private String description; //省略getter/setter} 自定义BookDao继承自JpaRepository. JpaRepository中提供了一些基本的数据操作方法,有基本的增删改查、分页查询、排序查询等。 第2行定义的方法表示查询以某个字符开始的所有书。· 第3行定义的方法表示查询单价大于某个值的所有书。 在Spring Data JPA中,只要方法的定义符合既定规范, Spring Data就能分析出开发者的意图,从而避免开发者定义SQL所谓的既定规范,就是一定的方法命名规则。12345678910public interface BookDao extends JpaRepository&lt;Book,Integer&gt;{ List&lt;Book&gt; getBooksByAuthorStartingWith(String author); List&lt;Book&gt; getBooksByPriceGreaterThan(Float price); @Query(value = &quot;select * from t_book where id=(select max(id) from t_book)&quot;,nativeQuery = true) Book getMaxIdBook(); @Query(&quot;select b from t_book b where b.id&gt;:id and b.author=:author&quot;) List&lt;Book&gt; getBookByIdAndAuthor(@Param(&quot;author&quot;) String author, @Param(&quot;id&quot;) Integer id); @Query(&quot;select b from t_book b where b.id&lt;?2 and b.name like %?1%&quot;) List&lt;Book&gt; getBooksByIdAndName(String name, Integer id);} 12345678910public interface BookDao extends JpaRepository&lt;Book,Long&gt; { List&lt;Book&gt; getBookByAuthorIs(String author); @Query(nativeQuery = true,value = &quot;select * from t_book where id=(select max(id) from t_book)&quot;) Book maxIdBook(); @Query(&quot;update t_book set b_name=:name where id=:id&quot;) @Modifying void updateBookById(String name, Long id);} 支持的命名规则如表所示:部分方法直接由JpaRepository1234567891011121314151617181920212223242526@Servicepublic class BookService { @Autowired BookDao bookDao; public void addBook(Book book) { bookDao.save(book); } public Page&lt;Book&gt; getBookByPage(Pageable pageable) { return bookDao.findAll(pageable); } public List&lt;Book&gt; getBooksByAuthorStartingWith(String author){ return bookDao.getBooksByAuthorStartingWith(author); } public List&lt;Book&gt; getBooksByPriceGreaterThan(Float price){ return bookDao.getBooksByPriceGreaterThan(price); } public Book getMaxIdBook(){ return bookDao.getMaxIdBook(); } public List&lt;Book&gt; getBookByIdAndAuthor(String author, Integer id){ return bookDao.getBookByIdAndAuthor(author, id); } public List&lt;Book&gt; getBooksByIdAndName(String name, Integer id){ return bookDao.getBooksByIdAndName(name, id); }} 1234567891011@GetMapping(&quot;/findAll&quot;) public void findAll() { PageRequest pageable = PageRequest.of(2, 3); Page&lt;Book&gt; page = bookService.getBookByPage(pageable); System.out.println(&quot;总页数:&quot;+page.getTotalPages()); System.out.println(&quot;总记录数:&quot;+page.getTotalElements()); System.out.println(&quot;查询结果:&quot;+page.getContent()); System.out.println(&quot;当前页数:&quot;+(page.getNumber()+1)); System.out.println(&quot;当前页记录数:&quot;+page.getNumberOfElements()); System.out.println(&quot;每页记录数:&quot;+page.getSize()); } 5.4多数据源.所谓多数据源,就是一个Java EE项目中采用了不同数据库实例中的多个库,或者同一个数据库实例中多个不同的库。一般来说,采用MyCat等分布式数据库中间件是比较好的解决方案,这样可以把数据库读写分离、分库分表、备份等操作交给中间件去做, Java代码只需要专注于业务即可。不过,这并不意味着无法使用Java代码解决类似的问题,在Spring Framework中就可以配置多数据源, Spring Boot继承其衣钵,只不过配置方式有所变化。5.4.1 JdbcTemplate多数据源JdbcTemplate多数据源的配置是比较简单的,因为一个JdbcTemplate对应一个DataSource,开发者只需要手动提供多个DataSource,再手动配置JdbcTemplate即可。具体步骤如下。12345678910# 数据源1spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.one.username=rootspring.datasource.one.password=123spring.datasource.one.url=jdbc:mysql:///chapter05-1# 数据源2spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.username=rootspring.datasource.two.password=123spring.datasource.two.url=jdbc:mysql:///chapter05-2 DataSourceConfig中提供了两个数据源: dsOne和dsTwo,默认方法名即实例名。 @ConfigurationProperties注解表示使用不同前缀的配置文件来创建不同的DataSource实例。12345678910111213@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(&quot;spring.datasource.one&quot;) DataSource dsOne() { return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(&quot;spring.datasource.two&quot;) DataSource dsTwo() { return DruidDataSourceBuilder.create().build(); }} 1234567891011@Configurationpublic class JdbcTemplateConfig { @Bean JdbcTemplate jdbcTemplateOne(@Qualifier(&quot;dsOne&quot;) DataSource dataSource) { return new JdbcTemplate(dataSource); } @Bean JdbcTemplate jdbcTemplateTwo(@Qualifier(&quot;dsTwo&quot;) DataSource dataSource) { return new JdbcTemplate(dataSource); }} JdbcTemplateConfig中提供两个JdbcTemplate实例。每个JdbcTemplate实例都需要提供-DataSource,由于Spring容器中有两个DataSource实例,因此需要通过方法名查找。@Qualifier注解表示查找不同名称的DataSource实例注入进来1234567 @Resource(name = &quot;jdbcTemplateOne&quot;)// @Autowired JdbcTemplate jdbcTemplate; @Autowired @Qualifier(&quot;jdbcTemplateTwo&quot;) JdbcTemplate jdbcTemplateTwo; @GetMapping(&quot;/test1&quot;) 5.4.2 MyBatis多数据源12345678910# 数据源1spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.one.username=rootspring.datasource.one.password=123spring.datasource.one.url=jdbc:mysql:///chapter05-1# 数据源2spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.username=rootspring.datasource.two.password=123spring.datasource.two.url=jdbc:mysql:///chapter05-2 12345678910111213@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(&quot;spring.datasource.one&quot;) DataSource dsOne() { return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(&quot;spring.datasource.two&quot;) DataSource dsTwo() { return DruidDataSourceBuilder.create().build(); }} 123456789101112131415161718192021222324252627@Configuration@MapperScan(basePackages = &quot;org.javaboy.mybatismulti.mapper1&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory1&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate1&quot;)public class MyBatisConfigOne { @Autowired @Qualifier(&quot;dsOne&quot;) DataSource ds; @Bean SqlSessionFactory sqlSessionFactory1() { SqlSessionFactory sqlSessionFactory = null; try { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(ds); sqlSessionFactory = bean.getObject(); } catch (Exception e) { e.printStackTrace(); } return sqlSessionFactory; } @Bean SqlSessionTemplate sqlSessionTemplate1() { return new SqlSessionTemplate(sqlSessionFactory1()); }} 12345678910111213141516171819202122232425@Configuration@MapperScan(basePackages = &quot;org.javaboy.mybatismulti.mapper2&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory2&quot;,sqlSessionTemplateRef = &quot;sqlSessionTemplate2&quot;)public class MyBatisConfigTwo { @Autowired @Qualifier(&quot;dsTwo&quot;) DataSource ds; @Bean SqlSessionFactory sqlSessionFactory2() { SqlSessionFactory sqlSessionFactory = null; try { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(ds); sqlSessionFactory = bean.getObject(); } catch (Exception e) { e.printStackTrace(); } return sqlSessionFactory; } @Bean SqlSessionTemplate sqlSessionTemplate2() { return new SqlSessionTemplate(sqlSessionFactory2()); }} 5.4.3 JPA多数据源1234567891011121314spring.datasource.one.password=123spring.datasource.one.username=rootspring.datasource.one.url=jdbc:mysql:///chapter05-1spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.password=123spring.datasource.two.username=rootspring.datasource.two.url=jdbc:mysql:///chapter05-2spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSourcespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57InnoDBDialectspring.jpa.properties.database=mysqlspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.show-sql= true 这里的配置与配置单独的JPA有区别,因为在后文的配置中要从JpaProperties中的getProperties方法中获取所有JPA相关的配置, 因此这里的属性前缀都是spring.jpa.properties 1234567891011121314@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(&quot;spring.datasource.one&quot;) @Primary DataSource dsOne() { return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(&quot;spring.datasource.two&quot;) DataSource dsTwo() { return DruidDataSourceBuilder.create().build(); }} 123456789101112131415161718192021222324252627@Configuration@EnableTransactionManagement@EnableJpaRepositories(basePackages = &quot;org.sang.dao1&quot;, entityManagerFactoryRef = &quot;entityManagerFactoryBeanOne&quot;, transactionManagerRef = &quot;platformTransactionManagerOne&quot;)public class JpaConfigOne { @Resource(name = &quot;dsOne&quot;) DataSource dsOne; @Autowired JpaProperties jpaProperties; @Bean @Primary LocalContainerEntityManagerFactoryBean entityManagerFactoryBeanOne( EntityManagerFactoryBuilder builder) { return builder.dataSource(dsOne) .properties(jpaProperties.getProperties()) .packages(&quot;org.sang.model&quot;) .persistenceUnit(&quot;pu1&quot;) .build(); } @Bean PlatformTransactionManager platformTransactionManagerOne( EntityManagerFactoryBuilder builder) { LocalContainerEntityManagerFactoryBean factoryOne = entityManagerFactoryBeanOne(builder); return new JpaTransactionManager(factoryOne.getObject()); }} 使用@EnableJpaRepositories注解来进行JPA的配置,该注解中主要配置三个属性:basePackages, entityManagerFactoryRef以及transactionManagerRef.其中, basePackages用来指定Repository所在的位置, entityManagerFactoryRef用来指定实体类管理工厂Bean的名称,transactionManagerRef则用来指定事务管理器的引用名称,这里的引用名称就是JpaConfigOne类中注册的Bean的名称(默认的Bean名称为方法名) 创建LocalContainerEntityManagerFactoryBean,该Bean将用来提供EntityManager实例,在该类的创建过程中,首先配置数据源,然后设置JPA相关配置(JpaProperties由系统自动加载),再设置实体类所在的位置,最后配置持久化单元名,若项目中只有一个EntityManagerFactory, 则persistenceUnit可以省略掉,若有多个,则必须明确指定持久化单元名。 由于项目中会提供两个LocalContainerEntityManagerFactoryBean实例,第12行的注解@Primary表示当存在多个LocalContainerEntityManagerFactoryBean实例时,该实例将被优先使用。 PlatformTransactionManager表示创建一个事务管理器。 JpaTransactionManager提供对单个EntityManagerFactory的事务支持,专门用于解决JPA中的事务管理。123456789101112131415161718192021222324252627@Configuration@EnableTransactionManagement@EnableJpaRepositories(basePackages = &quot;org.sang.dao2&quot;,entityManagerFactoryRef = &quot;entityManagerFactoryBeanTwo&quot;,transactionManagerRef = &quot;platformTransactionManagerTwo&quot;)public class JpaConfigTwo { @Resource(name = &quot;dsTwo&quot;) DataSource dsTwo; @Autowired JpaProperties jpaProperties; @Bean LocalContainerEntityManagerFactoryBean entityManagerFactoryBeanTwo( EntityManagerFactoryBuilder builder) { return builder.dataSource(dsTwo) .properties(jpaProperties.getProperties()) .packages(&quot;org.sang.model&quot;) .persistenceUnit(&quot;pu2&quot;) .build(); } @Bean PlatformTransactionManager platformTransactionManagerTwo( EntityManagerFactoryBuilder builder) { LocalContainerEntityManagerFactoryBean factoryTwo = entityManagerFactoryBeanTwo(builder); return new JpaTransactionManager(factoryTwo.getObject()); }} 第6章Spring Boot整合NosQLNoSQL是指非关系型数据库,非关系型数据库和关系型数据库两者存在许多显著的不同点,,其中最重要的是NoSQL不使用SQL作为查询语言。其数据存储可以不需要固定的表格模式,一般.都有水平可扩展性的特征。NoSQL主要有如下几种不同的分类: Key/Value键值存储。这种数据存储通常都是无数据结构的,一般被当作字符串或者二进制数据,但是数据加载速度快,典型的使用场景是处理高并发或者用于日志系统等,这一类的数据库有Redis. Tokyo Cabinet等. 列存储数据库。列存储数据库功能相对局限,但是查找速度快,容易进行分布式扩展,一般用于分布式文件系统中,这一类的数据库有HBase, Cassandra等。 文档型数据库 。和`Key/Value`键值存储类似,文档型数据库也没有严格的`数据格式`,这既是缺点也是优势,因为不需要预先创建表结构,数据格式更加灵活,一般可用在`Web`应用中,这一类数据库有`MongoDB`, `CouchDB`等。 图形数据库 。图形数据库专注于`构建关系图谱`,例如`社交网络`,`推荐系统`等,这一类的数据库有`Neo4J`、`DEX`等。 6.1整合RedisRedis是一个使用C编写的基于内存的NoSQL数据库,它是目前最流行的键值对存储数据库。Redis由一个Key, Value映射的字典构成,与其他NoSQL不同, Redis中Value的类型不局限于字符串,还支持列表、集合、有序集合、散列等。 6.1.1 Redis简介Redis不仅可以当作缓存使用,也可以配置数据持久化后当作NoSQL数据库使用, 目前支持两种持久化方式:快照持久化和AOF持久化。另一方面, Redis也可以搭建集群或者主从复制结构,在高并发环境下具有高可用性。 6.1.2 Redis安装123456789101112131415161718Loaded plugins: fastestmirror, product-id, search-disabled-repos, subscription-managerThis system is not registered with an entitlement server. You can use subscription-manager to register.Repository epel is listed more than once in the configurationRepository epel-debuginfo is listed more than once in the configurationRepository epel-source is listed more than once in the configurationLoading mirror speeds from cached hostfile * base: mirrors.cloud.aliyuncs.com * extras: mirrors.cloud.aliyuncs.com * updates: mirrors.cloud.aliyuncs.comPackage redis-3.2.12-2.el7.x86_64 already installed and latest versionNothing to do[root@liruilong ~]# [root@liruilong ~]# redis-server -vRedis server v=3.2.12 sha=00000000:0 malloc=jemalloc-3.6.0 bits=64 build=7897e7d0e13773f[root@liruilong ~]# redis-cli -vredis-cli 3.2.12 Redis 远程连接:https://www.cnblogs.com/liruilong/p/14531885.html6.1.3 Redis整合Spring BootRedis的Java客户端有很多,例如Jedis、JRedis、 Spring Data Redis等, Spring Boot借助于Spring. Data Redis为Redis提供了开箱即用自动化配置,开发者只需要添加相关依赖并配置Redis连接信息即可,具体整合步骤如下。添加如下依赖:1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt; 默认情况下, spring-boot-starter-data-redis使用的Redis工具是Lettuce,考虑到有的开发者习惯使用Jedis,因此可以从spring-boot-starter-data-redis中排除Lettuce并引入Jedis,修改为如下依赖:配置Redis接下来在application.properties 中配置Redis连接信息123456789101112131415161718192021#基本连接信息配置#表示使用的Redis库的编号, Redis中提供了16个database,编号为0-15spring.redis.database=0spring.redis.host=192.168.66.130spring.redis.port=6379spring.redis.password=123@456#连接池信息配置.spring.redis.lettuce.pool.max-active=spring.redis.lettuce.pool.max-idle=spring.redis.lettuce.pool.max-wait=spring.redis.lettuce.pool.min-idle=spring.redis.lettuce.shutdown-timeout=#连接池最大连接数spring.redis.jedis.pool.max-active=8#连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8#连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1ms#连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0 在·Spring Boot·的自动配置类中提供了·RedisAutoConfiguration·进行Redis的配置,部分源码由这一段源码可以看到, application.properties中配置的信息将被注入RedisProperties中,如果开发者自己没有提供RedisTemplate或者StringRedis Template实例,则Spring Boot默认会提供这两个实例, RedisTemplate和StringRedisTemplate实例则提供了Redis的基本操作方法。12345678910111213141516171819202122@RestControllerpublic class BookController { @Autowired RedisTemplate redisTemplate; @Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(&quot;/test1&quot;) public void test1() { ValueOperations&lt;String, String&gt; ops1 = stringRedisTemplate.opsForValue(); ops1.set(&quot;name&quot;, &quot;三国演义&quot;); String name = ops1.get(&quot;name&quot;); System.out.println(name); ValueOperations ops2 = redisTemplate.opsForValue(); Book b1 = new Book(); b1.setId(1); b1.setName(&quot;红楼梦&quot;); b1.setAuthor(&quot;曹雪芹&quot;); ops2.set(&quot;b1&quot;, b1); Book book = (Book) ops2.get(&quot;b1&quot;); System.out.println(book); }} StringRedisTemplate是RedisTemplate的子类, StringRedisTemplate中的key和value都是字符串，采用的序列化方案是StringRedisSerializer,而RedisTemplate则可以用来操作对象,RedisTemplate采用的序列化方案是JdkSerializationRedisSerializer.无论是StringRedis Template还是RedisTemplate,操作Redis的方法都是一致的。 StringRedisTemplate和RedisTemplate都是通过opsForValue, opsForZSet或者opsForSet等方法首先获取一个操作对象,再使用该操作对象完成数据的读写。 第10行向Redis中存储一条记录,第11行将之读取出来,第18行向Redis中存储一个对象,第19行将之读取出来。6.1.4 Redis集群整合Spring Boot.1,搭建Redis集群·(1)集群原理·在Redis集群中,所有的Redis节点彼此互联,节点内部使用二进制协议优化传输速度和带宽。当一个节点挂掉后,集群中超过半数的节点检测失效时才认为该节点已失效。不同于Tomcat集群需要使用反向代理服务器, Redis集群中的任意节点都可以直接和Java客户端连接。 Redis集群上的数据分配则是采用哈希槽(HASH SLOT) , Redis集群中内置了16384个哈希槽,当有数据需要存储时, Redis会首先使用CRC16算法对key进行计算,将计算获得的结果对16384取余,这样每一个key都会对应一个取值在0-16383之间的哈希槽, Redis则根据这个余数将该条数据存储到对应的Redis节点上,开发者可根据每个Redis实例的性能来调整每个Redis实例上哈希槽的分布范伟 6.2 整合MongoDB.6.2.1 MongoDB简介·MongoDB·是一种面向文档的数据库管理系统,它是一个介于关系型数据库和非关系型数据库，之间的产品, ·MongoDB·功能丰富,它支持一种类似JSON的BSON数据格式,既可以存储简单的数据格式,也可以存储复杂的数据类型。·MongoDB·最大的特点是它支持的查询语言非常强大,并且还支持对数据建立索引。总体来说, ·MongoDB·是一款应用相当广泛的NosQL数据库。 6.2.2 MongoDB安装關於Mongodb的學習《MongoDB大数据处理权威指南》读书笔记:https://blog.csdn.net/sanhewuyang/article/details/107597408 6.2.3 MongoDB整合Spring Boot.借助于Spring Data MongoDB, Spring Boot为MongoDB也提供了开箱即用的自动化配置方案,具体配置步骤如下 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 12345678spring.data.mongodb.authentication-database=adminspring.data.mongodb.database=testspring.data.mongodb.host=192.168.248.144spring.data.mongodb.port=27017spring.data.mongodb.username=rootspring.data.mongodb.password=123#spring.data.mongodb.uri=mongodb://root:123@192.168.248.144:27017/admin#spring.data.mongodb.uri=mongodb://192.168.248.144:27017/test 12345public interface BookDao extends MongoRepository&lt;Book,Integer&gt; { List&lt;Book&gt; findByAuthorContains(String author); Book findByNameEquals(String name);} 使用MongoTemplate除了继承MongoRepository外,Spring Data MongoDB还提供了MongoTemplate用来方便地操作MongoDB。在Spring Boot中,若添加了MongoDB相关的依赖,而开发者并没有提供MongoTemplate ,则默认会有一个MongoTemplate注册到Spring容器中,相关配置源码在MongoDataAutoConfiguration类中。因此,用户可以直接使用MongoTemplate,在Controller中直接注入MongoTemplate就可以使用了,添加如下代码到第5步的Controller中: 1234567891011121314151617181920212223242526272829@RestControllerpublic class BookController { @Autowired BookDao bookDao; @Autowired MongoTemplate mongoTemplate; @GetMapping(&quot;/test2&quot;) public void test2() { List&lt;Book&gt; books = new ArrayList&lt;&gt;(); .... mongoTemplate.insertAll(books); List&lt;Book&gt; list = mongoTemplate.findAll(Book.class); System.out.println(list); Book book = mongoTemplate.findById(3, Book.class); System.out.println(book); } @GetMapping(&quot;/test1&quot;) public void test1() { List&lt;Book&gt; books = new ArrayList&lt;&gt;(); .... bookDao.insert(books); List&lt;Book&gt; books1 = bookDao.findByAuthorContains(&quot;鲁迅&quot;); System.out.println(books1); Book book = bookDao.findByNameEquals(&quot;朝花夕拾&quot;); System.out.println(book); }} 6.3 Session共享正常情况下, HttpSession是通过Servlet容器创建并进行管理的,创建成功之后都是保存在内存中。如果开发者需要对项目进行横向扩展搭建集群,那么可以利用一些硬件或者软件工具来做负载均衡,此时,来自同一用户的HTTP请求就有可能被分发到不同的实例上去,如何保证各个实例之间Session的同步就成为一个必须解决的问题。 Spring Boot提供了自动化的Session共享配置,它结合Redis可以非常方便地解决这个问题。使用Redis解决Session共享问题的原理非常简单,就是把原本存储在不同服务器上的Session拿出来放在一个独立的服务器上.当一个请求到达Nginx服务器后,首先进行请求分发,假设请求被real serverl处理了, real server在处理请求时,无论是存储Session还是读取Session,都去操作Session服务器而不是操作自身内存中的Session,其他real server在处理请求时也是如此,这样就可以实现Session共享了 6.3.1 Session共享配置1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 除了Redis依赖之外,这里还要提供spring-session-data-redis依赖, Spring Session可以做到透·明化地替换掉应用的Session容器。项目创建成功后,在application.properties中进行Redis基本连接信息配置,代码如下: 12345678spring.redis.database=0spring.redis.host=192.168.66.130spring.redis.port=6379spring.redis.password=123@456spring.redis.jedis.pool.max-active=8spring.redis.jedis.pool.max-idle=8spring.redis.jedis.pool.max-wait=-1msspring.redis.jedis.pool.min-idle=0 添加··@EnableRedisHttpSession 12345678/** * session托管到redis */@Configuration@EnableRedisHttpSession(maxInactiveIntervalInSeconds= 3600*24, redisFlushMode = RedisFlushMode.ON_SAVE, redisNamespace = &quot;aurora-web&quot;)public class RedisSessionConfig { } maxInactiveIntervalInSeconds: 设置 Session 失效时间，使用 Redis Session 之后，原 Spring Boot 的server.session.timeout 属性不再生效。 经过上面的配置后，Session调用就会自动去Redis存取。另外，想要达到Session共享的目的，只需要在其他的系统上做同样的配置即可。@EnableRedisHttpSession源码123456789101112131415161718@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import({RedisHttpSessionConfiguration.class})@Configurationpublic @interface EnableRedisHttpSession { //Session默认过期时间，单位秒，默认1800秒 int maxInactiveIntervalInSeconds() default 1800; //配置key的namespace，默认的是spring:session，如果不同的应用共用一个redis，应该为应用配置不同的namespace，这样才能区分这个Session是来自哪个应用的 String redisNamespace() default &quot;spring:session&quot;; //配置刷新Redis中Session方式，默认是ON_SAVE模式，只有当Response提交后才会将Session提交到Redis,也可以配置成IMMEDIATE模式，即所有对Session的更改会立即更新到Redis RedisFlushMode redisFlushMode() default RedisFlushMode.ON_SAVE; //清理过期Session的定时任务 String cleanupCron() default &quot;0 * * * * *&quot;;} 测试一下123456789101112131415@RestControllerpublic class HelloController { @Value(&quot;${server.port}&quot;) String port; @PostMapping(&quot;/save&quot;) public String saveName(String name, HttpSession session) { session.setAttribute(&quot;name&quot;, name); return port; } @GetMapping(&quot;/get&quot;) public String getName(HttpSession session) { return port + &quot;:&quot; + session.getAttribute(&quot;name&quot;).toString(); }} 6.3.2 Nginx负载均衡关于Nginx，可以访问Nginx 学习笔记(《深入理解Nginx:模块开发与架构解析》读书笔记):https://blog.csdn.net/sanhewuyang/article/details/114488191nginx.conf·配置文件修改：12345678910upstream backend { server backend1.example.com; server backend2.example.com; server backend3.example.com;}server { location / { proxy_pass http: //backend; }} 第7章构建RESTful服务7.1 REST简介REST (Representational State Transfer)是一种Web软件架构风格,它是一种风格,而不是标准,匹配或兼容这种架构风格的网络服务称为REST服务。REST服务简洁并且有层次, REST通常基于HTTP,URI和XML以及HTML这些现有的广泛流行的协议和标准。 在REST中,资源是由URI来指定的,对资源的增删改查操作可以通过HTTP协议提供的GET, POST, PUT, DELETE等方法实现。使用REST可以更高效地利用缓存来提高响应速度,同时REST中的通信会话状态由客户端来维护,这可以让不同的服务器处理一系列请求中的不同请求,进而提高服务器的扩展性。在前后端分离项目中,一个设计良好的Web软件架构必然要满足REST风格。在Spring MVC框架中,开发者可以通过@RestController注解开发一个RESTful服务,不过,Spring Boot对此提供了自动化配置方案,开发者只需要添加相关依赖就能快速构建一个RESTful服务。 7.2 JPA实现REST在Spring Boot 中,使用Spring Data JPA和Spring Data Rest可以快速开发出一个RESTful应用。接下来向读者介绍Spring Boot中非常方便的RESTful应用开发。 7.2.1 基本实现这里的依赖除了数据库相关的依赖外,还有Spring Data JPA的依赖以及Spring Data Rest的依赖。项目创建完成后,在application.properties 中配置基本的数据库连接信息: 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 这里的依赖除了数据库相关的依赖外,还有Spring Data JPA的依赖以及Spring Data Rest的依赖。项目创建完成后,在application.properties中配置基本的数据库连接信息: 1234567891011121314151617181920212223spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.username=rootspring.datasource.password=123spring.datasource.url=jdbc:mysql:///jparestfulspring.jpa.hibernate.ddl-auto=updatespring.jpa.database=mysqlspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialectspring.jpa.show-sql=true##每页默认记录数，缺省值为20#spring.data.rest.default-page-size=2##分页查询页码参数名，缺省值为page#spring.data.rest.page-param-name=page##分页查询记录数参数名，缺省值为size#spring.data.rest.limit-param-name=size##分页查询排序参数名，缺省值为sort#spring.data.rest.sort-param-name=sort##base-path表示给所有请求路径都加上前缀#spring.data.rest.base-path=/api##添加成功时是否返回添加内容#spring.data.rest.return-body-on-create=true##更新成功时是否返回更新内容#spring.data.rest.return-body-on-update=true 创建实体类，创建BookRepository类继承JpaRepository, JpaRepository中默认提供了一些基本的操作方法,代码如下: 1234567891011121314151617181920212223242526272829303132333435363738public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; { List&lt;T&gt; findAll(); List&lt;T&gt; findAll(Sort var1); List&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); &lt;S extends T&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); void flush(); &lt;S extends T&gt; S saveAndFlush(S var1); &lt;S extends T&gt; List&lt;S&gt; saveAllAndFlush(Iterable&lt;S&gt; var1); /** @deprecated */ @Deprecated default void deleteInBatch(Iterable&lt;T&gt; entities) { this.deleteAllInBatch(entities); } void deleteAllInBatch(Iterable&lt;T&gt; var1); void deleteAllByIdInBatch(Iterable&lt;ID&gt; var1); void deleteAllInBatch(); /** @deprecated */ @Deprecated T getOne(ID var1); T getById(ID var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1); &lt;S extends T&gt; List&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);} 7.2.2 自定义请求路径默认情况下,请求路径都是实体类名小写加s,如果开发者想对请求路径进行重定义,通过@RepositoryRestResource注解即可实现,下面的案例只需在BookRepository上添加@RepositoryRestResource注解即可: 12345@CrossOrigin@RepositoryRestResource(path = &quot;bs&quot;,collectionResourceRel = &quot;bs&quot;,itemResourceRel = &quot;b&quot;)public interface BookRepository extends JpaRepository&lt;Book, Integer&gt; {.....} @RepositoryRestResource·注解的·path·属性表示将所有请求路径中的books都修改为bs,如http://ocalhost: 8080/bs: collectionResourceRel属性表示将返回的JSON集合中book集合的key修改为bs; itemResourceRel表示将返回的JSON集合中的单个book的key修改为b, 7.2.3 自定义查询方法.默认的查询方法支持分页查询、排序查询以及按照id查询,如果开发者想要按照某个属性查询,只需在BookRepository中定义相关方法并暴露出去即可,代码如下: 1234567891011@RepositoryRestResource(path = &quot;bs&quot;,collectionResourceRel = &quot;bs&quot;,itemResourceRel = &quot;b&quot;)public interface BookRepository extends JpaRepository&lt;Book, Integer&gt; { @Override @RestResource(exported = false) void deleteById(Integer integer); @RestResource(path = &quot;author&quot;,rel = &quot;author&quot;) List&lt;Book&gt; findByAuthorContains(@Param(&quot;author&quot;) String author); @RestResource(path = &quot;name&quot;,rel = &quot;name&quot;) Book findByNameEquals(@Param(&quot;name&quot;) String name);} ·自定义查询只需要在BookRepository中定义相关查询方法即可,方法定义好之后可以不添加@RestResource注解,默认路径就是方法名。以第4行定义的方法为例,若不添加@RestResource注解, 则默 认 该方法的调用路径为http://ocalhost:8080/bs/search/indByAuthorContains?author=鲁迅。如果想对查询路径进行自定义,只需要添加@RestResource注解即可, path属性即表示最新的路径。还是以第4行的方法为例,添加@RestResource(path = &quot;author&quot;,rel = &quot;author&quot;)注解后的查询路径为”http://ocalhost:8080/bs/search/author?author=鲁迅&quot;. 用户可以直接访问http/ocalhost:8080/bs/search路径查看该实体类暴露出来了哪些查询方法,默认情况下,在查询方法展示时使用的路径是方法名,通过@RestResource注解中的rel属性可以对这里的路径进行重定义,如图7-6所示。7.2.4 隐藏方法默认情况下,凡是继承了Repository接口(或者Repository的子类)的类都会被暴露出来,即开发者可执行基本的增删改查方法。以上文的BookRepository为例,如果开发者提供了BookRepository继承自Repository,就能执行对Book的基本操作,如果开发者继承了Repository但是又不想暴露相关操作,做如下配置即可:1234567//@RepositoryRestResource(exported = false)public interface BookRepository extends JpaRepository&lt;Book, Integer&gt; { @Override @RestResource(exported = false) void deleteById(Integer integer);....} 将·@RepositoryRestResource注解中的exported属性置为false之后,则增删改查接口都会失效, BookRepository类中定义的相关方法也会失效。若只是单纯地不想暴露某个方法,则在方法上进行配置即可,例如开发者想屏蔽DELETE接口.7.2.5 配置CORS在4.6节已经向读者介绍了CORS两种不同的配置方式,一种是直接在方法上添加@CrosSorigin注解,另一种是全局配置。全局配置在这里依然适用,但是默认的RESTful工程不需要开发者自己提供Controller,因此添加在Controller的方法上的注解可以直接写在BookRepository上,代码如下:接口跨域：@CrossOrigin注解添加到某一个方法上即可。1234567//@CrossOrigin@RepositoryRestResource(path = &quot;bs&quot;,collectionResourceRel = &quot;bs&quot;,itemResourceRel = &quot;b&quot;)public interface BookRepository extends JpaRepository&lt;Book, Integer&gt; { @CrossOrigin List&lt;Book&gt; findByAuthorContains(@Param(&quot;author&quot;) String author); ....} 7.2.6其他配置application.properties配置1234567891011121314##每页默认记录数，缺省值为20#spring.data.rest.default-page-size=2##分页查询页码参数名，缺省值为page#spring.data.rest.page-param-name=page##分页查询记录数参数名，缺省值为size#spring.data.rest.limit-param-name=size##分页查询排序参数名，缺省值为sort#spring.data.rest.sort-param-name=sort##base-path表示给所有请求路径都加上前缀#spring.data.rest.base-path=/api##添加成功时是否返回添加内容#spring.data.rest.return-body-on-create=true##更新成功时是否返回更新内容#spring.data.rest.return-body-on-update=true 当然,这些XML配置也可以在Java代码中配置,且代码中配置的优先级高于application.properties配置的优先级,代码如下 1234567891011121314@Configurationpublic class RestConfig extends RepositoryRestConfigurerAdapter { @Override public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) { config.setDefaultPageSize(2) .setPageParamName(&quot;page&quot;) .setLimitParamName(&quot;size&quot;) .setSortParamName(&quot;sort&quot;) .setBasePath(&quot;/api&quot;) .setReturnBodyOnCreate(true) .setReturnBodyOnUpdate(true); }} 7.2.7 JPA使用rest自定义链接12345678@Configurationpublic class MyResourceProcessor implements ResourceProcessor { @Override public ResourceSupport process(ResourceSupport resourceSupport) { resourceSupport.add(new Link(&quot;http://www.baidu.com&quot;, &quot;百度一下&quot;)); return resourceSupport; }} 7.3 MongoDB实现RESTMongoDB整合Spring Boot,而使用Spring Boot快速构建RESTful·服务除了结合Spring Data JPA之外,也可以结合Spring Data MongoDB实现。使用Spring DataMongoDB构建RESTful服务也是三个步骤,分别如下。 12345678 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;&lt;/dependency&gt; 这里Spring Data Rest的依赖和7.2节中的一致,只是将Spring Data JPA的依赖变为Spring DataMongoDB的依赖。项目创建成功后,在application.properties中配置MongoDB的基本连接信息, 123456spring.data.mongodb.authentication-database=testspring.data.mongodb.database=testspring.data.mongodb.username=sangspring.data.mongodb.password=123spring.data.mongodb.host=192.168.248.144spring.data.mongodb.port=27017 12public interface BookRepository extends MongoRepository&lt;Book,Integer&gt; {} 第8章开发者工具与单元测试8.1 devtools简介Spring Boot中提供了一组开发工具spring-boot-devtools,可以提高开发者的工作效率,开发者可以将该模块包含在任何项目中, spring-boot-devtools最方便的地方莫过于热部署了。 8.2 devtools实战8.2.1 基本用法12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这里多了一个optional选项,是为了防止将devtools依赖传递到其他模块中。当开发者将应用打包运行后, devtools会被自动禁用。 当开发者将spring-boot-devtools引入项目后,只要classpath路径下的文件发生了变化,项目就会自动重启,这极大地提高了项目的开发速度。 8.2.2 基本原理Spring Boot中使用的自动重启技术涉及两个类加载器,一个是baseclassloader,用来加载不会变化的类,例如项目引用的第三方的jar;另一个是restartclassloader,用来加载开发者自己写的会·变化的类。当项目需要重启时, restartclassloader将被一个新创建的类加载器代替,而baseclassloader则继续使用原来的,这种启动方式要比冷启动快很多,因为baseclassloader已经存在并且已经加载好 8.3单元测试8.3.1 基本用法当开发者使用Intelli IDEA或者在线创建一个Spring Boot项目时,创建成功后,默认都添加了spring-bool-starter-est依赖,并且创建好了测试类。 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTestpublic class AppTest { MockMvc mockMvc; @Autowired WebApplicationContext wac; @Autowired HelloService helloService; @Before public void before() { mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); } @Test public void test2() throws Exception { mockMvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;, &quot;name=aaa&quot;)).andDo(MockMvcResultHandlers.print()); } @Test public void test1() { System.out.println(helloService.sayHello(&quot;里斯&quot;)); }} @RunWith注解,该注解将JUnit执行类修改为SpringRunner,而SpringRunner是Spring Framework中测试类SpringJUnit4ClassRunner的别名。 @Spring BootTest注解除了提供Spring TestContext中的常规测试功能之外,还提供了其他特性:提供默认的ContextLoader, 自动搜索@Spring BootConfiguration、自定义环境属性、为不同的webEnvironment模式提供支持,这里的webEnvironment模式主要有4种.這裏不説了。 8.3.2 Service测试123456@Servicepublic class HelloService { public String sayHello(String name) { return &quot;Hello &quot; + name + &quot; !&quot;; }} 1234567@AutowiredHelloService helloService;@Testpublic void contextLoads() { String hello = helloService.sayHello(&quot;Michael&quot;); Assert.assertThat(hello, Matchers.is(&quot;Hello Michael !&quot;));} 8.3.3 Controller测试.1234567891011121314151617@Test public void test2() throws Exception { ObjectMapper om = new ObjectMapper(); Book book = new Book(); book.setAuthor(&quot;罗贯中&quot;); book.setName(&quot;三国演义&quot;); book.setId(1); String s = om.writeValueAsString(book); MvcResult mvcResult = mockMvc .perform(MockMvcRequestBuilders .post(&quot;/book&quot;) .contentType(MediaType.APPLICATION_JSON) .content(s)) .andExpect(MockMvcResultMatchers.status().isOk()) .andReturn(); System.out.println(mvcResult.getResponse().getContentAsString()); } 12345678910@RestControllerpublic class HelloController { @Autowired HelloService helloService; @GetMapping(&quot;/hello&quot;) public String hello(String name) { return helloService.sayHello(name); }} 12345678910111213141516171819202122MockMvc mockMvc;@AutowiredWebApplicationContext wac;@AutowiredHelloService helloService;@Beforepublic void before() { mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();}@Testpublic void test1() throws Exception { MvcResult mvcResult = mockMvc.perform( MockMvcRequestBuilders .get(&quot;/hello&quot;) .contentType(MediaType.APPLICATION_FORM_URLENCODED) .param(&quot;name&quot;, &quot;Michael&quot;)) //返回什么数据 .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); System.out.println(mvcResult.getResponse().getContentAsString());} 除了MockMvc这种测试方式之外, Spring Boot还专门提供了TestRestTemplate用来实现集成测试,若开发者使用了@Spring BootTest注解,则TestRestTemplate将自动可用,直接在测试类中注入即可。注意,如果要使用TestRestTemplate进行测试,需要将@Spring BootTest注解中webEnvironment属性的默认值由WebEnvironment.MOCK修改为webEnvironment.DEFINED PORT或者WebEnvironment.RANDOM PORT,因为这两种都是使用一个真实的Servlet环境而不是模拟的Serlet环境。其代码如下: 1@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) 1234567@AutowiredTestRestTemplate restTemplate; @Test public void test3() { ResponseEntity&lt;String&gt; hello = restTemplate.getForEntity(&quot;/hello?name={0}&quot;, String.class, &quot;Michael&quot;); System.out.println(hello.getBody()); } test2方法演示了POST请求如何传递JSON数据,首先在32行将一个book对象转为一段JSON,然后在36行设置请求的contentType为APPLICATION-JSON,最后在37行设置content为上传的JSON即可。 8.3.4 JSON测试开发者可以使用@JsonTest测试JSON序列化和反序列化是否工作正常,该注解将自动配置Jackson ObjectMapper.@JsonComponent以及Jackson Modules.如果开发者使用Gson代替Jackson,该注解将配置Gson,具体用法如下: 123456789101112131415161718192021222324252627282930@RunWith(SpringRunner.class)@JsonTestpublic class JSONTest { @Autowired JacksonTester&lt;Book&gt; jacksonTester; @Test public void testSerialize() throws IOException { Book book = new Book(); book.setId(1); book.setName(&quot;三国演义&quot;); book.setAuthor(&quot;罗贯中&quot;); Assertions.assertThat(jacksonTester.write(book)) .isEqualToJson(&quot;book.json&quot;); Assertions.assertThat(jacksonTester.write(book)) .hasJsonPathStringValue(&quot;@.name&quot;); Assertions.assertThat(jacksonTester.write(book)) .extractingJsonPathStringValue(&quot;@.name&quot;) .isEqualTo(&quot;三国演义&quot;); } @Test public void testDeserialize() throws Exception { String content = &quot;{\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;三国演义\\&quot;,\\&quot;author\\&quot;:\\&quot;罗贯中\\&quot;}&quot;;// Book book = new Book();// book.setId(1);// book.setName(&quot;三国演义&quot;);// book.setAuthor(&quot;罗贯中&quot;); Assertions.assertThat(jacksonTester.parseObject(content).getName()) .isEqualTo(&quot;三国演义&quot;); }} 第9章Spring Boot缓存Spring 3.1中开始对缓存提供支持,核心思路是对方法的缓存,当开发者调用一个方法时,将方法的参数和返回值作为key/value缓存起来,当再次调用该方法时,如果缓存中有数据,就直接,从缓存中获取,否则再去执行该方法。但是, Spring中并未提供缓存的实现,而是提供了一套缓存API,开发者可以自由选择缓存的实现, 目前Spring Boot支持的缓存有如下几种:Cache (JSR-107)、EhCache 2.x、 Hazelcast、Infinispan、Couchbase 、Redis、Caffeine、Simple 9.1 Ehcache 2.x缓存.Ehcache缓存在Java开发领域已是久负盛名,在Spring Boot中,只需要一个配置文件就可以将Ehcache集成到项目中。Ehcache 2.x的使用步骤如下。 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;/dependency&gt; 2.添加缓存配置文件如果Ehcache的依赖存在,并且在classpath下有一个名为ehcache2.xml的Ehcache配置文件,那么EhCacheCacheManager将会自动作为缓存的实现。因此,在resources目录下创建ehcache.xml文件作为Ehcache缓存的配置文件,代码如下: 123456789101112131415161718192021&lt;ehcache&gt; &lt;diskStore path=&quot;java.io.tmpdir/cache&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; /&gt; &lt;cache name=&quot;book_cache&quot; maxElementsInMemory=&quot;10000&quot; eternal=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;true&quot; diskPersistent=&quot;true&quot; diskExpiryThreadIntervalSeconds=&quot;10&quot;/&gt;&lt;/ehcache&gt; 这是一个常规的Ehcache配置文件,提供了两个缓存策略,一个是默认的,另一个名为book-cache.其中, name表示缓存名称; maxElementsInMemory表示缓存最大个数: eternal表示缓存对象是否永久有效,一旦设置了永久有效, timeout将不起作用; timeToldleSeconds表示缓存对象在失效前的允许闲置时间(单位:秒) ,当eternal-false对象不是永久有效时,该属性才生效; timeToLiveSeconds表示缓存对象在失效前允许存活的时间(单位:秒),当eternal-false对象不是永久有效时,该属性才生效; overflowToDisk表示当内存中的对象数量达到maxElementsInMemory时, Ehcache是否将对象写到磁盘中; diskExpiryThreadIntervalSeconds表示磁盘失效线程运行时间间隔。 另外,如果开发者想自定义Ehcache配置文件的名称和位置,可以在application.properties中添加如下配置: 1spring.cache.ehcache.config=classpath:ehcache2.xml 12345678@SpringBootApplication@EnableCachingpublic class CacheApplication { public static void main(String[] args) { SpringApplication.run(CacheApplication.class, args); }} 12345678910111213141516171819202122232425@Service@CacheConfig(cacheNames = &quot;book_cache&quot;)public class BookDao { @Autowired MyKeyGenerator myKeyGenerator; @Cacheable(keyGenerator = &quot;myKeyGenerator&quot;) public Book getBookById(Integer id) { System.out.println(&quot;getBookById&quot;); Book book = new Book(); book.setId(id); book.setName(&quot;三国演义&quot;); book.setAuthor(&quot;罗贯中&quot;); return book; } @CachePut(key = &quot;#book.id&quot;) public Book updateBookById(Book book) { System.out.println(&quot;updateBookById&quot;); book.setName(&quot;三国演义2&quot;); return book; } @CacheEvict(key = &quot;#id&quot;) public void deleteBookById(Integer id) { System.out.println(&quot;deleteBookById&quot;); }} 9.2 Redis单机缓存9.3 Redis集群缓存9.3.1 搭建Redis集群.9.3.2 配置缓存9.3.3 使用缓存第10章 Spring Boot安全管理…","link":"/2021/06/18/%E3%80%8ASpring%20Boot+Vue%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"Python 复习笔记","text":"python陆续的学了好几次，大学时便开始学，都是学点皮面之后没有坚持来，基本语法，正则，Socket，爬虫都接触过。做java比较多，平常基本不用，所以一直没有一篇系统的笔记来供自己温习，这里整理一篇较基础的，供自己温习。原来资源是小伙伴分享的学习笔记，这里自己稍作整理汇总。生活加油 写在前面 python陆续的学了好几次，大学时便开始学，都是学点皮面之后没有坚持来，基本语法，正则，Socket，爬虫都接触过。做java比较多，平常基本不用，所以一直没有一篇系统的笔记来供自己温习，这里整理一篇较基础的，供自己温习。原来资源是小伙伴分享的学习笔记，这里自己稍作整理汇总。生活加油 Python 复习笔记(一)Python 复习笔记(二) Python 基础入门 Google开源机器学习框架：TensorFlow 开源社区主推学习框架：Scikit-learn 百度开源深度学习框架：Paddle Python发展历史：Python版本 Python 2.X Python 3.X Python 3.5 Python 3.6 Python 3.7 Python解释器的作用Python解释器作用：运行文件 Python解释器种类 CPython，C语言开发的解释器[官方]，应用广泛的解释器。 IPython，基于CPython的一种交互式解释器。 其他解释器 PyPy，基于Python语言开发的解释器。 Jython，运行在Java平台的解释器，直接把Python代码编译成Java字节码执行。 IronPython，运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。linxu上编码12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@liruilong ~]# python3-bash: python3: command not found[root@liruilong ~]# yum -y install python3Loaded plugins: fastestmirror, product-id, search-disabled-repos, subscription-managerThis system is not registered with an entitlement server. You can use subscription-manager to register.Repository epel is listed more than once in the configurationRepository epel-debuginfo is listed more than once in the configurationRepository epel-source is listed more than once in the configurationDetermining fastest mirrorsDownloading packages:(1/5): libtirpc-0.2.4-0.16.el7.x86_64.rpm | 89 kB 00:00:00 (2/5): python3-3.6.8-18.el7.x86_64.rpm | 70 kB 00:00:00 (3/5): python3-setuptools-39.2.0-10.el7.noarch.rpm | 629 kB 00:00:00 (4/5): python3-pip-9.0.3-8.el7.noarch.rpm | 1.6 MB 00:00:00 (5/5): python3-libs-3.6.8-18.el7.x86_64.rpm | 6.9 MB 00:00:00 -----------------------------------------------------------------------------------------------------------------------------------------------------Total 16 MB/s | 9.3 MB 00:00:00 Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : libtirpc-0.2.4-0.16.el7.x86_64 1/5 Installing : python3-setuptools-39.2.0-10.el7.noarch 2/5 Installing : python3-pip-9.0.3-8.el7.noarch 3/5 Installing : python3-3.6.8-18.el7.x86_64 4/5 Installing : python3-libs-3.6.8-18.el7.x86_64 5/5 Verifying : libtirpc-0.2.4-0.16.el7.x86_64 1/5 Verifying : python3-setuptools-39.2.0-10.el7.noarch 2/5 Verifying : python3-libs-3.6.8-18.el7.x86_64 3/5 Verifying : python3-3.6.8-18.el7.x86_64 4/5 Verifying : python3-pip-9.0.3-8.el7.noarch 5/5 Installed: python3.x86_64 0:3.6.8-18.el7 Dependency Installed: libtirpc.x86_64 0:0.2.4-0.16.el7 python3-libs.x86_64 0:3.6.8-18.el7 python3-pip.noarch 0:9.0.3-8.el7 python3-setuptools.noarch 0:39.2.0-10.el7 Complete![root@liruilong ~]# python3Python 3.6.8 (default, Nov 16 2020, 16:55:22) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; PyCharm的作用PyCharm是一种Python ==IDE==（集成开发环境），带有一整套可以帮助用户在使用Python语言开发时==提高其效率的工具==，内部集成的功能如下： PythonCharm分为专业版（professional）和社区版（community） PyCharm基本使用 新建项目:打开PyCharm – [Create New Project] – 选择项目根目录和解释器版本 – [Create]，即可完成新建一个项目。 新建文件并书写代码:项目根目录或根目录内部任意位置 — 右键 – [New] – [Python File] – 输入文件名 – [OK] 如果是将来要上传到服务器的文件，那么文件名切记不能用中文。 双击打开文件，并书写一个最简单的Python代码： 1print(&quot;hello world&quot;) 运行文件:文件打开状态 – 空白位置 — 右键 – Run – 即可调出Pycharm的控制台输出程序结果。注释的分类及语法注释分为两类：==单行注释== 和 ==多行注释==。快捷键： ==ctrl + /== ,解释器不执行任何的注释内容。 单行注释:只能注释一行内容，语法如下：1234# 注释内容# 输出hello worldprint('hello world')print('hello Python') # 输出(简单的说明可以放到一行代码的后面，一般习惯代码后面添加两个空格再书写注释文字) 多行注释:可以注释多行内容，一般用在注释一段代码的情况， 语法如下：12345678910111213141516171819202122232425262728&quot;&quot;&quot; 第一行注释 第二行注释 第三行注释&quot;&quot;&quot;&quot;&quot;&quot; 下面三行都是输出的作用，输出内容分别是： hello Python hello itcast hello itheima&quot;&quot;&quot;print('hello Python')print('hello itcast')print('hello itheima')''' 注释1 注释2 注释3'''''' 下面三行都是输出的作用，输出内容分别是： hello Python hello itcast hello itheima'''print('hello Python')print('hello itcast')print('hello itheima') 变量 举例体验：我们去图书馆读书，怎么样快速找到自己想要的书籍呢？是不是管理员提前将书放到固定位置，并把这个位置进行了编号，我们只需要在图书馆中按照这个编号查找指定的位置就能找到想要的书籍。这个编号其实就是把书籍存放的书架位置起了一个名字，方便后期查找和使用。程序中，数据都是临时存储在内存中，为了更快速的查找或使用这个数据，通常我们把这个数据在内存中存储之后定义一个名称，这个名称就是变量。 变量就是一个存储数据的的时候当前数据所在的内存地址的名字而已。 定义变量1变量名 = 值 变量名自定义，要满足==标识符==命名规则。 标识符标识符命名规则是Python中定义各种名字的时候的统一规范，具体如下： 由数字、字母、下划线组成 不能数字开头 不能使用内置关键字 严格区分大小写 12345False None True and as assert break class continue def del elif else except finally forfrom global if import in is lambda nonlocalnot or pass raise return try while with yield 命名习惯 见名知义。 大驼峰：即每个单词首字母都大写，例如：MyName。 小驼峰：第二个（含）以后的单词首字母大写，例如：myName。 下划线：例如：my_name。 使用变量12345my_name = 'TOM'print(my_name)schoolName = '程序员'print(schoolName) 认识bug所谓bug，就是程序中的错误。如果程序有错误，需要程序员排查问题，纠正错误。 Debug工具Debug工具是PyCharm IDE中集成的用来调试程序的工具，在这里程序员可以查看程序的执行细节和流程或者调解bug。Debug工具使用步骤： 打断点 Debug调试 打断点 断点位置:目标要调试的代码块的第一行代码即可，即一个断点即可。 打断点的方法:单击目标代码的行号右侧空白位置。Debug调试打成功断点后，在文件内部任意位置 — 右键 – Debug’文件名’ — 即可调出Debug工具面板 – 单击Step Over/F8，即可按步执行代码。Debug输出面板分类 Debugger:显示变量和变量的细节 Console:输出内容认识数据类型 在 Python 里为了应对不同的业务需求，也把数据分为不同的类型。 检测数据类型的方法：type() 1234567891011121314151617181920212223a = 1print(type(a)) # &lt;class 'int'&gt; -- 整型b = 1.1print(type(b)) # &lt;class 'float'&gt; -- 浮点型c = Trueprint(type(c)) # &lt;class 'bool'&gt; -- 布尔型d = '12345'print(type(d)) # &lt;class 'str'&gt; -- 字符串e = [10, 20, 30]print(type(e)) # &lt;class 'list'&gt; -- 列表f = (10, 20, 30)print(type(f)) # &lt;class 'tuple'&gt; -- 元组h = {10, 20, 30}print(type(h)) # &lt;class 'set'&gt; -- 集合g = {'name': 'TOM', 'age': 20}print(type(g)) # &lt;class 'dict'&gt; -- 字典 输出作用：程序输出内容给用户 1234print('hello Python') age = 18print(age) ## 需求：输出“今年我的年龄是18岁” 格式化输出所谓的格式化输出即按照一定的格式输出内容。 格式化符号 格式符号 转换 ==%s== 字符串 ==%d== 有符号的十进制整数 ==%f== 浮点数 %c 字符 %u 无符号十进制整数 %o 八进制整数 %x 十六进制整数（小写ox） %X 十六进制整数（大写OX） %e 科学计数法（小写’e’） %E 科学计数法（大写’E’） %g %f和%e的简写 %G %f和%E的简写 技巧 %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出 %.2f，表示小数点后显示的小数位数。 格式化字符串除了%s，还可以写为f'{表达式}' 12345678910111213141516age = 18 name = 'TOM'weight = 75.5student_id = 1 ## 我的名字是TOMprint('我的名字是%s' % name) ## 我的学号是0001print('我的学号是%4d' % student_id) ## 我的体重是75.50公斤print('我的体重是%.2f公斤' % weight) ## 我的名字是TOM，今年18岁了print('我的名字是%s，今年%d岁了' % (name, age)) ## 我的名字是TOM，明年19岁了print('我的名字是%s，明年%d岁了' % (name, age + 1)) ## 我的名字是TOM，明年19岁了print(f'我的名字是{name}, 明年{age + 1}岁了') f-格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读。 转义字符 \\n：换行。 \\t：制表符，一个tab键（4个空格）的距离。结束符1print('输出的内容', end=&quot;\\n&quot;) 在Python中，print()， 默认自带end=&quot;\\n&quot;这个换行结束符，所以导致每两个print直接会换行展示，用户可以按需求更改结束符。 输入在Python中，程序接收用户输入的数据的功能即是输入。 输入的语法 1input(&quot;提示信息&quot;) 输入的特点 当程序执行到input，等待用户输入，输入完成之后才继续向下执行。 在Python中，input接收用户输入后，一般存储到变量，方便使用。 在Python中，input会把接收到的任意用户输入的数据都当做字符串处理。1234password = input('请输入您的密码：')print(f'您输入的密码是{password}') ## &lt;class 'str'&gt;print(type(password)) 转换数据类型的作用 问：input()接收用户输入的数据都是字符串类型，如果用户输入1，想得到整型该如何操作？答：转换数据类型即可，即将字符串类型转换成整型。 转换数据类型的函数 函数 说明 ==int(x [,base ])== 将x转换为一个整数 ==float(x )== 将x转换为一个浮点数 complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部 ==str(x )== 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 ==eval(str )== 用来计算在字符串中的有效Python表达式,并返回一个对象 ==tuple(s )== 将序列 s 转换为一个元组 ==list(s )== 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个Unicode字符 ord(x ) 将一个字符转换为它的ASCII整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 bin(x ) 将一个整数转换为一个二进制字符串 快速体验需求：input接收用户输入，用户输入“1”，将这个数据1转换成整型。 12345678 ## 1. 接收用户输入num = input('请输入您的幸运数字：') ## 2. 打印结果print(f&quot;您的幸运数字是{num}&quot;) ## 3. 检测接收到的用户输入的数据类型 -- str类型print(type(num)) ## 4. 转换数据类型为整型 -- int类型print(type(int(num))) 实例 12345678910111213141516171819202122 ## 1. `float() -- 转换成浮点型`num1 = 1print(float(num1))print(type(float(num1))) ## 2. str() -- 转换成字符串类型num2 = 10print(type(str(num2))) ## 3. tuple() -- 将一个序列转换成元组list1 = [10, 20, 30]print(tuple(list1))print(type(tuple(list1))) ## 4. list() -- 将一个序列转换成列表t1 = (100, 200, 300)print(list(t1))print(type(list(t1))) ## 5. eval() -- 将字符串中的数据转换成Python表达式原本类型str1 = '10'str2 = '[1, 2, 3]'str3 = '(1000, 2000, 3000)'print(type(eval(str1)))print(type(eval(str2)))print(type(eval(str3))) 运算符的分类 算数运算符 赋值运算符 复合赋值运算符 比较运算符 逻辑运算符算数运算符 运算符 描述 实例 + 加 1 + 1 输出结果为 2 - 减 1-1 输出结果为 0 * 乘 2 * 2 输出结果为 4 / 除 10 / 2 输出结果为 5 // 整除 9 // 4 输出结果为2 % 取余 9 % 4 输出结果为 1 ** 指数 2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2 () 小括号 小括号用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9 注意：- 混合运算优先级顺序：()高于 ** 高于 * / // % 高于 + - 赋值运算符 运算符 描述 实例 = 赋值 将=右侧的结果赋值给等号左侧的变量 单个变量赋值12num = 1print(num) 多个变量赋值1234num1, float1, str1 = 10, 0.5, 'hello world'print(num1)print(float1)print(str1) 多变量赋相同值123a = b = 10print(a)print(b) 复合赋值运算符 运算符 描述 实例 += 加法赋值运算符 c += a 等价于 c = c + a -= 减法赋值运算符 c -= a 等价于 c = c- a *= 乘法赋值运算符 c *= a 等价于 c = c * a /= 除法赋值运算符 c /= a 等价于 c = c / a //= 整除赋值运算符 c //= a 等价于 c = c // a %= 取余赋值运算符 c %= a 等价于 c = c % a **= 幂赋值运算符 c ** = a 等价于 c = c ** a 1234567891011121314a = 100a += 1 ## 输出101 a = a + 1,最终a = 100 + 1print(a)b = 2b *= 3 ## 输出6 b = b * 3,最终b = 2 * 3print(b)c = 10c += 1 + 2 ## 输出13, 先算运算符右侧1 + 2 = 3， c += 3 , 推导出c = 10 + 3print(c) 比较运算符比较运算符也叫关系运算符， 通常用来判断。 运算符 描述 实例 == 判断相等。如果两个操作数的结果相等，则条件结果为真(True)，否则条件结果为假(False) 如a=3,b=3，则（a == b) 为 True != 不等于 。如果两个操作数的结果不相等，则条件为真(True)，否则条件结果为假(False) 如a=3,b=3，则（a == b) 为 True如a=1,b=3，则(a != b) 为 True &gt; 运算符左侧操作数结果是否大于右侧操作数结果，如果大于，则条件为真，否则为假 如a=7,b=3，则(a &gt; b) 为 True &lt; 运算符左侧操作数结果是否小于右侧操作数结果，如果小于，则条件为真，否则为假 如a=7,b=3，则(a &lt; b) 为 False &gt;= 运算符左侧操作数结果是否大于等于右侧操作数结果，如果大于，则条件为真，否则为假 如a=7,b=3，则(a &lt; b) 为 False如a=3,b=3，则(a &gt;= b) 为 True &lt;= 运算符左侧操作数结果是否小于等于右侧操作数结果，如果小于，则条件为真，否则为假 如a=3,b=3，则(a &lt;= b) 为 True 12345678a = 7b = 5print(a == b) # Falseprint(a != b) # Trueprint(a &lt; b) # Falseprint(a &gt; b) # Trueprint(a &lt;= b) # Falseprint(a &gt;= b) # True 逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与”：如果 x 为 False，x and y 返回 False，否则它返回 y 的值。 True and False， 返回 False。 or x or y 布尔”或”：如果 x 是 True，它返回 True，否则它返回 y 的值。 False or True， 返回 True。 not not x 布尔”非”：如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not True 返回 False, not False 返回 True 1234567a = 1b = 2c = 3print((a &lt; b) and (b &lt; c)) # Trueprint((a &gt; b) and (b &lt; c)) # Falseprint((a &gt; b) or (b &lt; c)) # Trueprint(not (a &gt; b)) # True 拓展数字之间的逻辑运算 1234567891011121314a = 0b = 1c = 2 ## and运算符，二进制位只要有一个值为0，则结果为0，否则结果为最后一个非0数字print(a and b) # 0print(b and a) # 0print(a and c) # 0print(c and a) # 0print(b and c) # 2print(c and b) # 1 ## or运算符，只有所有值为0结果才为0，否则结果为第一个非0数字print(a or b) # 1print(a or c) # 2print(b or c) # 1 条件语句if 语法语法 1234if 条件: 条件成立执行的代码1 条件成立执行的代码2 ...... 12345if True: print('条件成立执行的代码1') print('条件成立执行的代码2') ## 下方的代码没有缩进到if语句块，所以和if条件无关print('我是无论条件是否成立都要执行的代码') 实例：上网需求分析：如果用户年龄大于等于18岁，即成年，输出”已经成年，可以上网”。 12345age = 20if age &gt;= 18: print('已经成年，可以上网')print('系统关闭') 新增需求：用户可以输出自己的年龄，然后系统进行判断是否成年，成年则输出”您的年龄是’用户输入的年龄’，已经成年，可以上网”。 123456 ## input接受用户输入的数据是字符串类型，条件是age和整型18做判断，所以这里要int转换数据类型age = int(input('请输入您的年龄：'))if age &gt;= 18: print(f'您的年龄是{age},已经成年，可以上网')print('系统关闭') if…else…作用：条件成立执行if下方的代码; 条件不成立执行else下方的代码。 思考：网吧上网的实例，如果成年，允许上网，如果不成年呢？是不是应该回复用户不能上网？ 语法 12345678if 条件: 条件成立执行的代码1 条件成立执行的代码2 ......else: 条件不成立执行的代码1 条件不成立执行的代码2 ...... 实用版：网吧上网 12345678age = int(input('请输入您的年龄：'))if age &gt;= 18: print(f'您的年龄是{age},已经成年，可以上网')else: print(f'您的年龄是{age},未成年，请自行回家写作业')print('系统关闭') 注意：如果条件成立执行了某些代码，那么其他的情况的代码将不会执行。 多重判断 思考：中国合法工作年龄为18-60岁，即如果年龄小于18的情况为童工，不合法；如果年龄在18-60岁之间为合法工龄；大于60岁为法定退休年龄。 1234567891011if 条件1: 条件1成立执行的代码1 条件1成立执行的代码2 ......elif 条件2： 条件2成立执行的代码1 条件2成立执行的代码2 ............else: 以上条件都不成立执行执行的代码 多重判断也可以和else配合使用。一般else放到整个if语句的最后，表示以上条件都不成立的时候执行的代码。 实例：工龄判断 1234567age = int(input('请输入您的年龄：'))if age &lt; 18: print(f'您的年龄是{age},童工一枚')elif (age &gt;= 18) and (age &lt;= 60): print(f'您的年龄是{age},合法工龄')elif age &gt; 60: print(f'您的年龄是{age},可以退休') 拓展：age &gt;= 18 and age &lt;= 60可以化简为18 &lt;= age &lt;= 60。 if嵌套 思考：坐公交：如果有钱可以上车，没钱不能上车；上车后如果有空座，则可以坐下；如果没空座，就要站着。怎么书写程序？ 语法 123456if 条件1： 条件1成立执行的代码 条件1成立执行的代码 if 条件2： 条件2成立执行的代码 条件2成立执行的代码 注意：条件2的if也是处于条件1成立执行的代码的缩进关系内部。 实例：坐公交判断是否能上车 123456789101112&quot;&quot;&quot;1. 如果有钱，则可以上车 2. 上车后，如果有空座，可以坐下 上车后，如果没有空座，则站着等空座位如果没钱，不能上车&quot;&quot;&quot; ## 假设用 money = 1 表示有钱, money = 0表示没有钱money = 1if money == 1: print('土豪，不差钱，顺利上车')else: print('没钱，不能上车，追着公交车跑') 判断是否能坐下 1234567891011121314151617&quot;&quot;&quot;1. 如果有钱，则可以上车 2. 上车后，如果有空座，可以坐下 上车后，如果没有空座，则站着等空座位如果没钱，不能上车&quot;&quot;&quot; ## 假设用 money = 1 表示有钱, money = 0表示没有钱; seat = 1 表示有空座，seat = 0 表示没有空座money = 1seat = 0if money == 1: print('土豪，不差钱，顺利上车') if seat == 1: print('有空座，可以坐下') else: print('没有空座，站等')else: print('没钱，不能上车，追着公交车跑') 应用：猜拳游戏需求分析： 参与游戏的角色 玩家：手动出拳 电脑：随机出拳 判断输赢 玩家获胜 平局 ： 玩家出拳 和 电脑出拳相同 电脑获胜 随机做法： 导出random模块 random.randint(开始,结束)1234567891011121314151617181920212223242526&quot;&quot;&quot;提示：0-石头，1-剪刀，2-布1. 出拳玩家输入出拳电脑随机出拳2. 判断输赢玩家获胜平局电脑获胜&quot;&quot;&quot; ## 导入random模块import random ## 计算电脑出拳的随机数字computer = random.randint(0, 2)print(computer)player = int(input('请出拳：0-石头，1-剪刀，2-布：')) ## 玩家胜利 p0:c1 或 p1:c2 或 p2:c0if (player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0): print('玩家获胜') ## 平局：玩家 == 电脑elif player == computer: print('平局')else: print('电脑获胜') 三目运算符 三目运算符也叫三元运算符。语法如下： 1值1 if 条件 else 值2 快速体验： 12345a = 1b = 2c = a if a &gt; b else bprint(c) 循环简介循环的作用 思考：假如我有个女朋友，有一天我们闹矛盾生气了，女朋友说：道歉，说100遍“媳妇儿，我错了”。这个时候程序员会怎么做？ 答：100遍print('媳妇儿，我错了')思考：复制粘贴100次吗？ 答：重复执行100次一样的代码，程序中循环即可 循环的作用：让代码更高效的重复执行。 循环的分类在Python中，循环分为while和for两种，最终实现效果相同。 while的语法 1234while 条件: 条件成立重复执行的代码1 条件成立重复执行的代码2 ...... 需求：复现重复执行100次print('媳妇儿，我错了')（输出更简洁一些，我们这里设置5次）。 分析：初始值是0次，终点是5次，重复做的事情输出“媳妇儿， 我错了”。 123456 ## 循环的计数器i = 0while i &lt; 5: print('媳妇儿，我错了') i += 1print('任务结束') while的应用应用一：计算1-100累加和分析：1-100的累加和，即1 + 2 + 3 + 4 +….，即前两个数字的相加结果 + 下一个数字( 前一个数字 + 1)。 1234567i = 1result = 0while i &lt;= 100: result += i i += 1 ## 输出5050print(result) 注意：为了验证程序的准确性，可以先改小数值，验证结果正确后，再改成1-100做累加。 应用二：计算1-100偶数累加和分析：1-100的偶数和，即 2 + 4 + 6 + 8….，得到偶数的方法如下： 偶数即是和2取余结果为0的数字，可以加入条件语句判断是否为偶数，为偶数则累加 初始值为0 / 2 , 计数器每次累加2方法一：条件判断和2取余数则累加123456789 ## 方法一：条件判断和2取余数为0则累加计算i = 1result = 0while i &lt;= 100: if i % 2 == 0: result += i i += 1 ## 输出2550print(result) 方法二：计数器控制12345678 ## 方法二：计数器控制增量为2i = 0result = 0while i &lt;= 100: result += i i += 2 ## 输出2550print(result) break和continuebreak和continue是循环中满足一定条件退出循环的两种不同方式。理解举例：一共吃5个苹果，吃完第一个，吃第二个…，这里”吃苹果”的动作是不是重复执行？ 情况一：如果吃的过程中，吃完第三个吃饱了，则不需要再吃第4个和第五个苹果，即是吃苹果的动作停止，这里就是break控制循环流程，即==终止此循环==。 情况二：如果吃的过程中，吃到第三个吃出一个大虫子…,是不是这个苹果就不吃了，开始吃第四个苹果，这里就是continue控制循环流程，即==退出当前一次循环继而执行下一次循环代码==。 情况一：break1234567i = 1while i &lt;= 5: if i == 4: print(f'吃饱了不吃了') break print(f'吃了第{i}个苹果') i += 1 情况二：continue123456789i = 1while i &lt;= 5: if i == 3: print(f'大虫子，第{i}个不吃了') # 在continue之前一定要修改计数器，否则会陷入死循环 i += 1 continue print(f'吃了第{i}个苹果') i += 1 while循环嵌套应用场景故事梗概：有天女朋友又生气了，惩罚：说3遍“媳妇儿， 我错了”，这个程序是不是循环即可？但如果女朋友说：还要刷今天晚饭的碗，这个程序怎么书写？ 123while 条件: print('媳妇儿， 我错了')print('刷晚饭的碗') 但如果女朋友还是生气，把这套惩罚要连续3天都执行，有如何书写程序？ 1234while 条件: while 条件: print('媳妇儿， 我错了') print('刷晚饭的碗') 语法 123456while 条件1: 条件1成立执行的代码 ...... while 条件2: 条件2成立执行的代码 ...... 总结：所谓while循环嵌套，就是一个while里面嵌套一个while的写法，每个while和之前的基础语法是相同的。 快速体验：复现场景代码 123456789j = 0while j &lt; 3: i = 0 while i &lt; 3: print('媳妇儿，我错了') i += 1 print('刷晚饭的碗') print('一套惩罚结束----------------') j += 1 理解执行流程当内部循环执行完成之后，再执行下一次外部循环的条件判断。 while循环嵌套应用应用一：打印星号(正方形)需求 12345************************* 代码 123456789101112 ## 重复打印5行星星j = 0while j &lt;= 4: # 一行星星的打印 i = 0 while i &lt;= 4: # 一行内的星星不能换行，取消print默认结束符\\n print('*', end='') i += 1 # 每行结束要换行，这里借助一个空的print，利用print默认结束符换行 print() j += 1 应用二：打印星号(三角形)需求 12345*************** 代码分析：==一行输出星星的个数和行号是相等的==，每行：重复打印行号数字个星号，将打印行星号的命令重复执行5次实现打印5行。 123456789101112 ## 重复打印5行星星 ## j表示行号j = 0while j &lt;= 4: # 一行星星的打印 i = 0 # i表示每行里面星星的个数，这个数字要和行号相等所以i要和j联动 while i &lt;= j: print('*', end='') i += 1 print() j += 1 九九乘法表代码 12345678910 ## 重复打印9行表达式j = 1while j &lt;= 9: # 打印一行里面的表达式 a * b = a*b i = 1 while i &lt;= j: print(f'{i}*{j}={j*i}', end='\\t') i += 1 print() j += 1 for循环语法 1234for 临时变量 in 序列: 重复执行的代码1 重复执行的代码2 ...... 快速体验 123str1 = 'itheima'for i in str1: print(i) break 123456str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') break print(i) continue 123456str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') continue print(i) else循环可以和else配合使用，else下方缩进的代码指的是==当循环正常结束之后要执行的代码==。 while…else需求：女朋友生气了，要惩罚：连续说5遍“媳妇儿，我错了”，如果道歉正常完毕女朋友就原谅我了，这个程序怎么写？ 12345i = 1while i &lt;= 5: print('媳妇儿，我错了') i += 1print('媳妇儿原谅我了...') 思考： 这个print是不是没有循环也能执行？ 语法 1234while 条件: 条件成立重复执行的代码else: `循环正常结束之后要执行的代码` 示例 123456i = 1while i &lt;= 5: print('媳妇儿，我错了') i += 1else: print('媳妇原谅我了，真开心，哈哈哈哈') 退出循环的方式 需求：女朋友生气，要求道歉5遍：媳妇儿，我错了。道歉到第三遍的时候，媳妇埋怨这一遍说的不真诚，是不是就是要退出循环了？这个退出有两种可能性： 更生气，不打算原谅，也不需要道歉了，程序如何书写？ 只一遍不真诚，可以忍受，继续下一遍道歉，程序如何书写？ 1. break 123456789i = 1while i &lt;= 5: if i == 3: print('这遍说的不真诚') break print('媳妇儿，我错了') i += 1else: print('媳妇原谅我了，真开心，哈哈哈哈') 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。 continue12345678910i = 1while i &lt;= 5: if i == 3: print('这遍说的不真诚') i += 1 continue print('媳妇儿，我错了') i += 1else: print('媳妇原谅我了，真开心，哈哈哈哈') 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。 for…else语法 12345for 临时变量 in 序列: 重复执行的代码 ...else: 循环正常结束之后要执行的代码 所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行。 示例 12345str1 = 'itheima'for i in str1: print(i)else: print('循环正常结束之后执行的代码') 退出循环的方式 break终止循环12345678str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') break print(i)else: print('循环正常结束之后执行的代码') 没有执行else缩进的代码。 continue控制循环12345678str1 = 'itheima'for i in str1: if i == 'e': print('遇到e不打印') continue print(i)else: print('循环正常结束之后执行的代码') 因为continue是退出当前一次循环，继续下一次循环，所以该循环在continue控制下是可以正常结束的，当循环结束后，则执行了else缩进的代码。 数据序列认识字符串字符串是 Python 中最常用的数据类型。我们一般使用引号来创建字符串。创建字符串很简单，只要为变量分配一个值即可。 1234a = 'hello world'b = &quot;abcdefg&quot;print(type(a))print(type(b)) 注意：控制台显示结果为&lt;class 'str'&gt;， 即数据类型为str(字符串)。 字符串特征 一对引号字符串12name1 = 'Tom'name2 = &quot;Rose&quot; 三引号字符串1234567name3 = ''' Tom '''name4 = &quot;&quot;&quot; Rose &quot;&quot;&quot;a = ''' i am Tom, nice to meet you! '''b = &quot;&quot;&quot; i am Rose, nice to meet you! &quot;&quot;&quot; 注意：三引号形式的字符串支持换行。思考：如果创建一个字符串 I'm Tom? 12c = &quot;I'm Tom&quot;d = 'I\\'m Tom' 字符串输出12345print('hello world')name = 'Tom'print('我的名字是%s' % name)print(f'我的名字是{name}') 字符串输入在Python中，使用input()接收用户输入。 代码1234567name = input('请输入您的名字：')print(f'您输入的名字是{name}')print(type(name))password = input('请输入您的密码：')print(f'您输入的密码是{password}')print(type(password)) 下标 “下标”又叫“索引”，就是编号。比如火车座位号，座位号的作用：按照编号快速找到对应的座位。同理，下标的作用即是通过下标快速找到对应的数据。 快速体验需求：字符串name = &quot;abcdef&quot;，取到不同下标对应的数据。 代码1234name = &quot;abcdef&quot;print(name[1])print(name[0])print(name[2]) 输出结果 注意：下标从==0==开始。 切片切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。 语法 1序列[开始位置下标:结束位置下标:步长] 注意 1. 不包含结束位置下标对应的数据， 正负整数均可； 2. 步长是选取间隔，正负整数均可，默认步长为1。 体验 12345678910name = &quot;abcdefg&quot;print(name[2:5:1]) # cdeprint(name[2:5]) # cdeprint(name[:5]) # abcdeprint(name[1:]) # bcdefgprint(name[:]) # abcdefgprint(name[::2]) # acegprint(name[:-1]) # abcdef, 负1表示倒数第一个数据print(name[-4:-1]) # defprint(name[::-1]) # gfedcba 常用操作方法 字符串的常用操作方法有查找、修改和判断三大类。 查找所谓字符串查找方法即是查找子串在字符串中的位置或出现的次数。 find()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则返回-1。 语法:1字符串序列.find(子串, 开始位置下标, 结束位置下标) 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。 12345mystr = &quot;hello world and itcast and itheima and Python&quot;print(mystr.find('and')) # 12print(mystr.find('and', 15, 30)) # 23print(mystr.find('ands')) # -1 index()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则则报异常。语法:1字符串序列.index(子串, 开始位置下标, 结束位置下标) 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。 12345mystr = &quot;hello world and itcast and itheima and Python&quot;print(mystr.index('and')) # 12print(mystr.index('and', 15, 30)) # 23print(mystr.index('ands')) # 报错 rfind()： 和find()功能相同，但查找方向为==右侧==开始。 rindex()：和index()功能相同，但查找方向为==右侧==开始。 count()：返回某个子串在字符串中出现的次数, 语法:1字符串序列.count(子串, 开始位置下标, 结束位置下标) 注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。 12345mystr = &quot;hello world and itcast and itheima and Python&quot;print(mystr.count('and')) # 3print(mystr.count('ands')) # 0print(mystr.count('and', 0, 20)) # 1 修改所谓修改字符串，指的就是通过函数的形式修改字符串中的数据。 replace()：替换, 语法:1字符串序列.replace(旧子串, 新子串, 替换次数) 注意：替换次数如果查出子串出现次数，则替换次数为该子串出现次数。 1234567mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：hello world he itcast he itheima he Pythonprint(mystr.replace('and', 'he')) ## 结果：hello world he itcast he itheima he Pythonprint(mystr.replace('and', 'he', 10)) ## 结果：hello world and itcast and itheima and Pythonprint(mystr) 注意：数据按照是否能直接修改分为==可变类型==和==不可变类型==两种。字符串类型的数据修改的时候不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型。 split()：按照指定字符分割字符串。 语法:1字符串序列.split(分割字符, num) 注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。 123456789mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：['hello world ', ' itcast ', ' itheima ', ' Python']print(mystr.split('and')) ## 结果：['hello world ', ' itcast ', ' itheima and Python']print(mystr.split('and', 2)) ## 结果：['hello', 'world', 'and', 'itcast', 'and', 'itheima', 'and', 'Python']print(mystr.split(' ')) ## 结果：['hello', 'world', 'and itcast and itheima and Python']print(mystr.split(' ', 2)) 注意：如果分割字符是原有字符串中的子串，分割后则丢失该子串。 join()：用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。 语法:1字符或子串.join(多字符串组成的序列) 123456list1 = ['chuan', 'zhi', 'bo', 'ke']t1 = ('aa', 'b', 'cc', 'ddd') ## 结果：chuan_zhi_bo_keprint('_'.join(list1)) ## 结果：aa...b...cc...dddprint('...'.join(t1)) capitalize()：将字符串第一个字符转换成大写。123mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：Hello world and itcast and itheima and pythonprint(mystr.capitalize()) 注意：capitalize()函数转换后，只字符串第一个字符大写，其他的字符全都小写。 title()：将字符串每个单词首字母转换成大写。123mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：Hello World And Itcast And Itheima And Pythonprint(mystr.title()) lower()：将字符串中大写转小写。123mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：hello world and itcast and itheima and pythonprint(mystr.lower()) upper()：将字符串中小写转大写。123mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：HELLO WORLD AND ITCAST AND ITHEIMA AND PYTHONprint(mystr.upper()) lstrip()：删除字符串左侧空白字符。 rstrip()：删除字符串右侧空白字符。 strip()：删除字符串两侧空白字符。 123456 &gt;&gt;&gt; print(&quot; 24&quot;.lstrip())24&gt;&gt;&gt; print(&quot; 24 &quot;.rstrip()) 24&gt;&gt;&gt; print(&quot; 24 &quot;.strip())24 ljust()：返回一个原字符串左对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串。语法: rjust()：返回一个原字符串右对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。123456字符串序列.ljust(长度, 填充字符)&gt;&gt;&gt; print(&quot; 24 &quot;.rjust(50,&quot;0&quot;))0000000000000000000000000000000000000000000000 24 &gt;&gt;&gt; print(&quot; 24 &quot;.ljust(50,&quot;0&quot;)) 24 0000000000000000000000000000000000000000000000&gt;&gt;&gt; center()：返回一个原字符串居中对齐,并使用指定字符(默认空格)填充至对应长度 的新字符串，语法和ljust()相同。1234&gt;&gt;&gt; print(&quot; 24 &quot;.center(50)) 24 &gt;&gt;&gt; print(&quot; 24 &quot;.center(50,&quot;0&quot;))00000000000000000000000 24 00000000000000000000000 判断所谓判断即是判断真假，返回的结果是布尔型数据类型：True 或 False。 startswith()：检查字符串是否是以指定子串开头，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。语法:1字符串序列.startswith(子串, 开始位置下标, 结束位置下标) 12345mystr = &quot;hello world and itcast and itheima and Python &quot; ## 结果：Trueprint(mystr.startswith('hello')) ## 结果Falseprint(mystr.startswith('hello', 5, 20)) endswith()：：检查字符串是否是以指定子串结尾，是则返回 True，否则返回 False。如果设置开始和结束位置下标，则在指定范围内检查。 语法1字符串序列.endswith(子串, 开始位置下标, 结束位置下标) 1234567mystr = &quot;hello world and itcast and itheima and Python&quot; ## 结果：Trueprint(mystr.endswith('Python')) ## 结果：Falseprint(mystr.endswith('python')) ## 结果：Falseprint(mystr.endswith('Python', 2, 20)) isalpha()：如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False。123456789101112131415161718192021mystr1 = 'hello'mystr2 = 'hello12345' ## 结果：Trueprint(mystr1.isalpha()) ## 结果：Falseprint(mystr2.isalpha())&gt;&gt;&gt; print(&quot;234&quot;.isalpha())False&gt;&gt;&gt; print(&quot;lll&quot;.isalpha())True&gt;&gt;&gt; print(&quot;ty &quot;.isalpha())False&gt;&gt;&gt; print(&quot;kkkk&quot;.isalpha())True&gt;&gt;&gt; print(&quot; k&quot;.isalpha())False&gt;&gt;&gt; print(&quot;k&quot;.isalpha())True&gt;&gt;&gt; isdigit()：如果字符串只包含数字则返回 True 否则返回 False。123456mystr1 = 'aaa12345'mystr2 = '12345' ## 结果： Falseprint(mystr1.isdigit()) ## 结果：Falseprint(mystr2.isdigit()) isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False。123456mystr1 = 'aaa12345'mystr2 = '12345-' ## 结果：Trueprint(mystr1.isalnum()) ## 结果：Falseprint(mystr2.isalnum()) isspace()：如果字符串中只包含空白，则返回 True，否则返回 False。123456mystr1 = '1 2 3 4 5'mystr2 = ' ' ## 结果：Falseprint(mystr1.isspace()) ## 结果：Trueprint(mystr2.isspace()) 列表列表的应用场景 思考：有一个人的姓名(TOM)怎么书写存储程序？答：变量。 思考：如果一个班级100位学生，每个人的姓名都要存储，应该如何书写程序？声明100个变量吗？答：列表即可， 列表一次性可以存储多个数据。 列表的格式1[数据1, 数据2, 数据3, 数据4......] 列表可以一次性存储多个数据，且可以为不同数据类型。 列表的常用操作列表的作用是一次性存储多个数据，程序员可以对这些数据进行的操作有：增、删、改、查。 查找下标12345name_list = ['Tom', 'Lily', 'Rose']print(name_list[0]) ## Tomprint(name_list[1]) ## Lilyprint(name_list[2]) ## Rose 函数 index()：返回指定数据所在位置的下标 。 语法1列表序列.index(数据, 开始位置下标, 结束位置下标) 123name_list = ['Tom', 'Lily', 'Rose']print(name_list.index('Lily', 0, 2)) ## 1 注意：如果查找的数据不存在则报错。 count()：统计指定数据在当前列表中出现的次数。123name_list = ['Tom', 'Lily', 'Rose']print(name_list.count('Lily')) ## 1 len()：访问列表长度，即列表中数据的个数。123name_list = ['Tom', 'Lily', 'Rose']print(len(name_list)) ## 3 判断是否存在 in：判断指定数据在某个列表序列，如果在返回True，否则返回False12345name_list = ['Tom', 'Lily', 'Rose']## 结果：Trueprint('Lily' in name_list)## 结果：Falseprint('Lilys' in name_list) not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False12345name_list = ['Tom', 'Lily', 'Rose']## 结果：Falseprint('Lily' not in name_list)## 结果：Trueprint('Lilys' not in name_list) 需求：查找用户输入的名字是否已经存在。 12345678name_list = ['Tom', 'Lily', 'Rose']name = input('请输入您要搜索的名字：')if name in name_list: print(f'您输入的名字是{name}, 名字已经存在')else: print(f'您输入的名字是{name}, 名字不存在') 增加作用：增加指定数据到列表中。 append()：列表结尾追加数据。语法:1列表序列.append(数据) 12345name_list = ['Tom', 'Lily', 'Rose']name_list.append('xiaoming')## 结果：['Tom', 'Lily', 'Rose', 'xiaoming']print(name_list) 列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。 ==如果append()追加的数据是一个序列，则追加整个序列到列表== 12345name_list = ['Tom', 'Lily', 'Rose']name_list.append(['xiaoming', 'xiaohong'])## 结果：['Tom', 'Lily', 'Rose', ['xiaoming', 'xiaohong']]print(name_list) extend()：列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表。. 语法1列表序列.extend(数据) 12345name_list = ['Tom', 'Lily', 'Rose']name_list.extend('xiaoming')## 结果：['Tom', 'Lily', 'Rose', 'x', 'i', 'a', 'o', 'm', 'i', 'n', 'g']print(name_list) 12345name_list = ['Tom', 'Lily', 'Rose']name_list.extend(['xiaoming', 'xiaohong'])## 结果：['Tom', 'Lily', 'Rose', 'xiaoming', 'xiaohong']print(name_list) insert()：指定位置新增数据。. 语法1列表序列.insert(位置下标, 数据) 12345name_list = ['Tom', 'Lily', 'Rose']name_list.insert(1, 'xiaoming')## 结果：['Tom', 'xiaoming', 'Lily', 'Rose']print(name_list) 删除 del 语法：1del 目标 删除列表1234name_list = ['Tom', 'Lily', 'Rose']## 结果：报错提示：name 'name_list' is not defineddel name_listprint(name_list) 删除指定数据12345name_list = ['Tom', 'Lily', 'Rose']del name_list[0]## 结果：['Lily', 'Rose']print(name_list) pop()：删除指定下标的数据(默认为最后一个)，并返回该数据。. 语法1列表序列.pop(下标) 1234567name_list = ['Tom', 'Lily', 'Rose']del_name = name_list.pop(1)## 结果：Lilyprint(del_name)## 结果：['Tom', 'Rose']print(name_list) remove()：移除列表中某个数据的第一个匹配项。 语法1列表序列.remove(数据) 12345name_list = ['Tom', 'Lily', 'Rose']name_list.remove('Rose')## 结果：['Tom', 'Lily']print(name_list) clear()：清空列表1234name_list = ['Tom', 'Lily', 'Rose']name_list.clear()print(name_list) ## 结果： [] 修改 修改指定下标数据12345name_list = ['Tom', 'Lily', 'Rose']name_list[0] = 'aaa'## 结果：['aaa', 'Lily', 'Rose']print(name_list) 逆置：reverse()12345num_list = [1, 5, 2, 3, 6, 8]num_list.reverse()## 结果：[8, 6, 3, 2, 5, 1]print(num_list) 排序：sort() 语法1列表序列.sort( key=None, reverse=False) 注意：reverse表示排序规则，reverse = True 降序， reverse = False 升序（默认） 12345num_list = [1, 5, 2, 3, 6, 8]num_list.sort()## 结果：[1, 2, 3, 5, 6, 8]print(num_list) 复制函数：copy() 12345name_list = ['Tom', 'Lily', 'Rose']name_li2 = name_list.copy()## 结果：['Tom', 'Lily', 'Rose']print(name_li2) 列表的循环遍历需求：依次打印列表中的各个数据。 while123456name_list = ['Tom', 'Lily', 'Rose']i = 0while i &lt; len(name_list): print(name_list[i]) i += 1 for1234name_list = ['Tom', 'Lily', 'Rose']for i in name_list: print(i) 列表嵌套所谓列表嵌套指的就是一个列表里面包含了其他的子列表。 应用场景：要存储班级一、二、三三个班级学生姓名，且每个班级的学生姓名在一个列表。 1name_list = [['小明', '小红', '小绿'], ['Tom', 'Lily', 'Rose'], ['张三', '李四', '王五']] 思考： 如何查找到数据”李四”？ 1234## 第一步：按下标查找到李四所在的列表print(name_list[2])## 第二步：从李四所在的列表里面，再按下标找到数据李四print(name_list[2][1]) 元组元组的应用场景思考：如果想要存储多个数据，但是这些数据是不能修改的数据，怎么做？答：列表？列表可以一次性存储多个数据，但是列表中的数据允许更改。 12num_list = [10, 20, 30]num_list[0] = 100 ==一个元组可以存储多个数据，元组内的数据是不能修改的。== 定义元组元组特点：定义元组使用==小括号==，且==逗号==隔开各个数据，数据可以是不同的数据类型。 1234## 多个数据元组t1 = (10, 20, 30)## 单个数据元组t2 = (10,) 注意：如果定义的元组只有一个数据，那么这个数据后面也好添加逗号，否则数据类型为唯一的这个数据的数据类型 12345678t2 = (10,)print(type(t2)) ## tuplet3 = (20)print(type(t3)) ## intt4 = ('hello')print(type(t4)) ## str 元组的常见操作元组数据不支持修改，只支持查找，具体如下： 按下标查找数据12tuple1 = ('aa', 'bb', 'cc', 'bb')print(tuple1[0]) ## aa index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index方法相同。12tuple1 = ('aa', 'bb', 'cc', 'bb')print(tuple1.index('aa')) ## 0 count()：统计某个数据在当前元组出现的次数。12tuple1 = ('aa', 'bb', 'cc', 'bb')print(tuple1.count('bb')) ## 2 len()：统计元组中数据的个数。12tuple1 = ('aa', 'bb', 'cc', 'bb')print(len(tuple1)) ## 4 注意：元组内的直接数据如果修改则立即报错 12tuple1 = ('aa', 'bb', 'cc', 'bb')tuple1[0] = 'aaa' 但是如果元组里面有列表，修改列表里面的数据则是支持的，故自觉很重要。 12345tuple2 = (10, 20, ['aa', 'bb', 'cc'], 50, 30)print(tuple2[2]) ## 访问到列表## 结果：(10, 20, ['aaaaa', 'bb', 'cc'], 50, 30)tuple2[2][0] = 'aaaaa'print(tuple2) 字典字典的应用场景 思考1： 如果有多个数据，例如：’Tom’, ‘男’, 20，如何快速存储？答：列表 1list1 = ['Tom', '男', 20] 思考2：如何查找到数据’Tom’？答：查找到下标为0的数据即可。 1list1[0] 思考3：如果将来数据顺序发生变化，如下所示，还能用list1[0]访问到数据’Tom’吗？。 1list1 = ['男', 20, 'Tom'] 答：不能，数据’Tom’此时下标为2。 思考4：数据顺序发生变化，每个数据的下标也会随之变化，如何保证数据顺序变化前后能使用同一的标准查找数据呢？答：字典，字典里面的数据是以==键值对==形式出现，字典数据和数据顺序没有关系，即字典不支持下标，后期无论数据如何变化，只需要按照对应的键的名字查找数据即可。 创建字典的语法字典特点： 符号为==大括号== 数据为==键值对==形式出现 各个键值对之间用==逗号==隔开 1234567## 有数据字典dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}## 空字典dict2 = {}dict3 = dict() 注意：一般称冒号前面的为键(key)，简称k；冒号后面的为值(value)，简称v。 字典常见操作增写法：==字典序列[key] = 值== 注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。 12345678910dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}dict1['name'] = 'Rose'## 结果：{'name': 'Rose', 'age': 20, 'gender': '男'}print(dict1)dict1['id'] = 110## {'name': 'Rose', 'age': 20, 'gender': '男', 'id': 110}print(dict1) 注意：字典为可变类型。 删 del() / del：删除字典或删除字典中指定键值对。 12345dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}del dict1['gender']## 结果：{'name': 'Tom', 'age': 20}print(dict1) clear()：清空字典 1234dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}dict1.clear()print(dict1) # {} 改写法：==字典序列[key] = 值== 注意：如果key存在则修改这个key对应的值 ；如果key不存在则新增此键值对。 查 key值查找123dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}print(dict1['name']) # Tomprint(dict1['id']) # 报错 如果当前查找的key存在，则返回对应的值；否则则报错。 get() 语法 1字典序列.get(key, 默认值) 注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。 1234dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}print(dict1.get('name')) # Tomprint(dict1.get('id', 110)) # 110print(dict1.get('id')) # None keys()12dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}print(dict1.keys()) # dict_keys(['name', 'age', 'gender']) values()12dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}print(dict1.values()) # dict_values(['Tom', 20, '男']) items()12dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}print(dict1.items()) # dict_items([('name', 'Tom'), ('age', 20), ('gender', '男')]) 字典的循环遍历遍历字典的key123dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}for key in dict1.keys(): print(key) 遍历字典的value123dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}for value in dict1.values(): print(value) 遍历字典的元素 123dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}for item in dict1.items(): print(item) [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GyUf8MGo-1617796856463)(04-字典.assets/image-20190212104046564.png)] 遍历字典的键值123dict1 = {'name': 'Tom', 'age': 20, 'gender': '男'}for key, value in dict1.items(): print(f'{key} = {value}') 集合创建集合创建集合使用{}或set()， 但是如果要创建空集合只能使用set()，因为{}用来创建空字典。 1234567891011121314s1 = {10, 20, 30, 40, 50}print(s1)s2 = {10, 30, 20, 10, 30, 40, 30, 50}print(s2)s3 = set('abcdefg')print(s3)s4 = set()print(type(s4)) ## sets5 = {}print(type(s5)) ## dict 特点： 集合可以去掉重复数据；· 集合数据是无序的，故不支持下标· 集合常见操作方法增加数据 add()1234s1 = {10, 20}s1.add(100)s1.add(10)print(s1) ## {100, 10, 20} 因为集合有去重功能，所以，当向集合内追加的数据是当前集合已有数据的话，则不进行任何操作。 update(), 追加的数据是序列。12345s1 = {10, 20}## s1.update(100) ## 报错s1.update([100, 200])s1.update('abc')print(s1) 删除数据 remove()，删除集合中的指定数据，如果数据不存在则报错。1234567s1 = {10, 20}s1.remove(10)print(s1)s1.remove(10) ## 报错print(s1) discard()，删除集合中的指定数据，如果数据不存在也不会报错。1234567s1 = {10, 20}s1.discard(10)print(s1)s1.discard(10)print(s1) pop()，随机删除集合中的某个数据，并返回这个数据。12345s1 = {10, 20, 30, 40, 50}del_num = s1.pop()print(del_num)print(s1) 查找数据 in：判断数据在集合序列 not in：判断数据不在集合序列1234s1 = {10, 20, 30, 40, 50}print(10 in s1)print(10 not in s1) 公共操作 一. 运算符 运算符 描述 支持的容器类型 + 合并 字符串、列表、元组 * 复制 字符串、列表、元组 in 元素是否存在 字符串、列表、元组、字典 not in 元素是否不存在 字符串、列表、元组、字典 +123456789101112131415## 1. 字符串 str1 = 'aa'str2 = 'bb'str3 = str1 + str2print(str3) ## aabb## 2. 列表 list1 = [1, 2]list2 = [10, 20]list3 = list1 + list2print(list3) ## [1, 2, 10, 20]## 3. 元组 t1 = (1, 2)t2 = (10, 20)t3 = t1 + t2print(t3) ## (10, 20, 100, 200) *12345678## 1. 字符串print('-' * 10) ## ----------## 2. 列表list1 = ['hello']print(list1 * 4) ## ['hello', 'hello', 'hello', 'hello']## 3. 元组t1 = ('world',)print(t1 * 4) ## ('world', 'world', 'world', 'world') in或not in1234567891011## 1. 字符串print('a' in 'abcd') ## Trueprint('a' not in 'abcd') ## False## 2. 列表list1 = ['a', 'b', 'c', 'd']print('a' in list1) ## Trueprint('a' not in list1) ## False## 3. 元组t1 = ('a', 'b', 'c', 'd')print('aa' in t1) ## Falseprint('aa' not in t1) ## True 公共方法 函数 描述 len() 计算容器中元素个数 del 或 del() 删除 max() 返回容器中元素最大值 min() 返回容器中元素最小值 range(start, end, step) 生成从start到end的数字，步长为 step，供for循环使用 enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 len()123456789101112131415## 1. 字符串str1 = 'abcdefg'print(len(str1)) ## 7## 2. 列表list1 = [10, 20, 30, 40]print(len(list1)) ## 4## 3. 元组t1 = (10, 20, 30, 40, 50)print(len(t1)) ## 5## 4. 集合s1 = {10, 20, 30}print(len(s1)) ## 3## 5. 字典dict1 = {'name': 'Rose', 'age': 18}print(len(dict1)) ## 2 del()12345678## 1. 字符串str1 = 'abcdefg'del str1print(str1)## 2. 列表list1 = [10, 20, 30, 40]del(list1[0])print(list1) ## [20, 30, 40] max()123456## 1. 字符串str1 = 'abcdefg'print(max(str1)) ## g## 2. 列表list1 = [10, 20, 30, 40]print(max(list1)) ## 40 min()123456## 1. 字符串str1 = 'abcdefg'print(min(str1)) ## a## 2. 列表list1 = [10, 20, 30, 40]print(min(list1)) ## 10 range()123456789## 1 2 3 4 5 6 7 8 9for i in range(1, 10, 1): print(i)## 1 3 5 7 9for i in range(1, 10, 2): print(i)## 0 1 2 3 4 5 6 7 8 9for i in range(10): print(i) 注意：range()生成的序列不包含end数字。 enumerate() 语法1enumerate(可遍历对象, start=0) 注意：start参数用来设置遍历数据的下标的起始值，默认为0。 1234567891011121314151617list1 = ['a', 'b', 'c', 'd', 'e']for i in enumerate(list1): print(i)for index, char in enumerate(list1, start=1): print(f'下标是{index}, 对应的字符是{char}')(0, 'a')(1, 'b')(2, 'c')(3, 'd')(4, 'e')下标是{1}, 对应的字符是{a}下标是{2}, 对应的字符是{b}下标是{3}, 对应的字符是{c}下标是{4}, 对应的字符是{d}下标是{5}, 对应的字符是{e} 容器类型转换tuple()作用：将某个序列转换成元组 1234list1 = [10, 20, 30, 40, 50, 20]s1 = {100, 200, 300, 400, 500}print(tuple(list1))print(tuple(s1)) list()作用：将某个序列转换成列表 1234t1 = ('a', 'b', 'c', 'd', 'e')s1 = {100, 200, 300, 400, 500}print(list(t1))print(list(s1)) set()作用：将某个序列转换成集合 1234list1 = [10, 20, 30, 40, 50, 20]t1 = ('a', 'b', 'c', 'd', 'e')print(set(list1))print(set(t1)) 注意： 1. 集合可以快速完成列表去重 2. 集合不支持下标 推导式列表推导式作用：用一个表达式创建一个有规律的列表或控制一个有规律列表。列表推导式又叫列表生成式。需求：创建一个0-10的列表。 while循环实现123456789## 1. 准备一个空列表list1 = []## 2. 书写循环，依次追加数字到空列表list1中i = 0while i &lt; 10: list1.append(i) i += 1print(list1) for循环实现1234list1 = []for i in range(10): list1.append(i)print(list1) 列表推导式实现12list1 = [i for i in range(10)]print(list1) 带if的列表推导式需求：创建0-10的偶数列表 方法一：range()步长实现12list1 = [i for i in range(0, 10, 2)]print(list1) 方法二：if实现12list1 = [i for i in range(10) if i % 2 == 0]print(list1) 多个for循环实现列表推导式 需求：创建列表如下： 1[(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] 代码如下：12list1 = [(i, j) for i in range(1, 3) for j in range(3)]print(list1) 字典推导式思考：如果有如下两个列表：12list1 = ['name', 'age', 'gender']list2 = ['Tom', 20, 'man'] 如何快速合并为一个字典？答：字典推导式 字典推导式作用：快速合并列表为字典或提取字典中目标数据。 创建一个字典：字典key是1-5数字，value是这个数字的2次方。 12dict1 = {i: i**2 for i in range(1, 5)}print(dict1) ## {1: 1, 2: 4, 3: 9, 4: 16} 将两个列表合并为一个字典 12345list1 = ['name', 'age', 'gender']list2 = ['Tom', 20, 'man']dict1 = {list1[i]: list2[i] for i in range(len(list1))}print(dict1) 提取字典中目标数据 1234counts = {'MBP': 268, 'HP': 125, 'DELL': 201, 'Lenovo': 199, 'acer': 99}## 需求：提取上述电脑数量大于等于200的字典数据count1 = {key: value for key, value in counts.items() if value &gt;= 200}print(count1) ## {'MBP': 268, 'DELL': 201} 集合推导式需求：创建一个集合，数据为下方列表的2次方。 1list1 = [1, 1, 2] 代码如下： 123list1 = [1, 1, 2]set1 = {i ** 2 for i in list1}print(set1) ## {1, 4} 注意：集合有数据去重功能。 函数函数的作用需求：用户到ATM机取钱： 输入密码后显示”选择功能”界面 查询余额后显示”选择功能”界面 取2000钱后显示”选择功能”界面 特点：显示“选择功能”界面需要重复输出给用户，怎么实现？函数就是将==一段具有独立功能的代码块== 整合到一个整体并命名，在需要的位置==调用这个名称==即可完成对应的需求。函数在开发过程中，可以更高效的实现==代码重用==。 函数的使用步骤定义函数1234def 函数名(参数): 代码1 代码2 ...... 调用函数1函数名(参数) 注意： 不同的需求，参数可有可无。 在Python中，函数必须==先定义后使用==。 需求：复现ATM取钱功能。 搭建整体框架(复现需求) 12345678print('密码正确登录成功')#### 显示&quot;选择功能&quot;界面print('查询余额完毕')#### 显示&quot;选择功能&quot;界面print('取了2000元钱')#### 显示&quot;选择功能&quot;界面 确定“选择功能”界面内容 123print('查询余额')print('存款')print('取款') 封装”选择功能” 注意：一定是先定义函数，后调用函数。 1234567#### 封装ATM机功能选项 -- 定义函数def select_func(): print('-----请选择功能-----') print('查询余额') print('存款') print('取款') print('-----请选择功能-----') 调用函数 在需要显示“选择功能”函数的位置调用函数。 123456789print('密码正确登录成功')#### 显示&quot;选择功能&quot;界面 -- 调用函数select_func()print('查询余额完毕')#### 显示&quot;选择功能&quot;界面 -- 调用函数select_func()print('取了2000元钱')#### 显示&quot;选择功能&quot;界面 -- 调用函数select_func() 函数的参数作用思考：完成需求如下：一个函数完成两个数1和2的加法运算，如何书写程序？ 123456#### 定义函数def add_num1(): result = 1 + 2 print(result)#### 调用函数add_num1() 思考：上述add_num1函数只能完成数字1和2的加法运算，如果想要这个函数变得更灵活，可以计算任何用户指定的两个数字的和，如何书写程序？ 分析：用户要在调用函数的时候指定具体数字，那么在定义函数的时候就需要接收用户指定的数字。函数调用时候指定的数字和定义函数时候接收的数字即是函数的参数。 123456#### 定义函数时同时定义了接收用户数据的参数a和b，a和b是形参def add_num2(a, b): result = a + b print(result)#### 调用函数时传入了真实的数据10 和 20，真实数据为实参add_num2(10, 20) 函数的返回值作用例如：我们去超市购物，比如买烟，给钱之后，是不是售货员会返回给我们烟这个商品，在函数中，如果需要返回结果给用户需要使用函数返回值。 12345def buy(): return '烟'#### 使用变量保存函数返回值goods = buy()print(goods) 应用需求：制作一个计算器，计算任意两数字之和，并保存结果。 12345def sum_num(a, b): return a + b#### 用result变量保存函数返回值result = sum_num(1, 2)print(result) 函数的说明文档 思考：定义一个函数后，程序员如何书写程序能够快速提示这个函数的作用？答：注释 思考：如果代码多，我们是不是需要在很多代码中找到这个函数定义的位置才能看到注释？如果想更方便的查看函数的作用怎么办？答：函数的说明文档 函数的说明文档也叫函数的文档说明。 语法 定义函数的说明文档1234def 函数名(参数): &quot;&quot;&quot; 说明文档的位置 &quot;&quot;&quot; 代码 ...... 查看函数的说明文档1help(函数名) 123456def sum_num(a, b): &quot;&quot;&quot; 求和函数 &quot;&quot;&quot; return a + bhelp(sum_num) 函数嵌套调用所谓函数嵌套调用指的是==一个函数里面又调用了另外一个函数==。 1234567891011def testB(): print('---- testB start----') print('这里是testB函数执行的代码...(省略)...') print('---- testB end----')def testA(): print('---- testA start----') testB() print('---- testA end----')testA() 如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置。 打印图形 打印一条横线 123def print_line(): print('-' * 20)print_line() 123456789101112131415WARNING! The remote SSH server rejected X11 forwarding request.Last failed login: Fri Apr 9 17:40:20 CST 2021 from 49.234.64.13 on ssh:nottyThere were 27 failed login attempts since the last successful login.Last login: Thu Apr 8 23:53:27 2021 from 111.194.47.197Welcome to Alibaba Cloud Elastic Compute Service ![root@liruilong ~]# python3Python 3.6.8 (default, Nov 16 2020, 16:55:22) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; print('-' * 20)--------------------&gt;&gt;&gt; 打印多条横线 12345678910def print_line(): print('-' * 20)def print_lines(num): i = 0 while i &lt; num: print_line() i += 1print_lines(5) 函数计算 求三个数之和 123456def sum_num(a, b, c): return a + b + cresult = sum_num(1, 2, 3)print(result) # 6 求三个数平均值 123456def average_num(a, b, c): sumResult = sum_num(a, b, c) return sumResult / 3result = average_num(1, 2, 3)print(result) # 2.0 函数变量作用域 变量作用域指的是变量生效的范围，主要分为两类：==局部变量==和==全局变量==。 局部变量：所谓局部变量是定义在函数体内部的变量，即只在函数体内部生效。12345def testA(): a = 100 print(a)testA() # 100print(a) # 报错：name 'a' is not defined 变量a是定义在testA函数内部的变量，在函数外部访问则立即报错。 局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。 全局变量:所谓全局变量，指的是在函数体内、外都能生效的变量。 思考：如果有一个数据，在函数A和函数B中都要使用，该怎么办？ 答：将这个数据存储在一个全局变量里面。 12345678#### 定义全局变量aa = 100def testA(): print(a) # 访问全局变量a，并打印变量a存储的数据def testB(): print(a) # 访问全局变量a，并打印变量a存储的数据testA() # 100testB() # 100 思考：testB函数需求修改变量a的值为200，如何修改程序？ 123456789a = 100def testA(): print(a)def testB(): a = 200 print(a)testA() # 100testB() # 200print(f'全局变量a = {a}') # 全局变量a = 100 思考：在testB函数内部的a = 200中的变量a是在修改全局变量a吗？ 答：不是。观察上述代码发现，15行得到a的数据是100，仍然是定义全局变量a时候的值，而没有返回testB函数内部的200。综上：testB函数内部的a = 200是定义了一个局部变量。 思考：如何在函数体内部修改全局变量？ 1234567891011a = 100def testA(): print(a)def testB(): # global 关键字声明a是全局变量 global a a = 200 print(a)testA() # 100testB() # 200print(f'全局变量a = {a}') # 全局变量a = 200 多函数程序执行流程一般在实际开发过程中，一个程序往往由多个函数（后面知识中会讲解类）组成，并且多个函数共享某些数据，如下所示： 共用全局变量12345678910111213#### 1. 定义全局变量glo_num = 0def test1(): global glo_num # 修改全局变量 glo_num = 100def test2(): # 调用test1函数中修改后的全局变量 print(glo_num)#### 2. 调用test1函数，执行函数内部代码：声明和修改全局变量test1()#### 3. 调用test2函数，执行函数内部代码：打印test2() # 100 返回值作为参数传递12345678def test1(): return 50def test2(num): print(num)#### 1. 保存函数test1的返回值result = test1()#### 2.将函数返回值所在变量作为参数传递到test2函数test2(result) # 50 函数的返回值 思考：如果一个函数如些两个return (如下所示)，程序如何执行？ 12345def return_num(): return 1 return 2result = return_num()print(result) # 1 答：只执行了第一个return，原因是因为return可以退出当前函数，导致return下方的代码不执行。 思考：如果一个函数要有多个返回值，该如何书写代码？ 1234def return_num(): return 1, 2result = return_num()print(result) # (1, 2) 注意： return a, b写法，返回多个数据的时候，默认是元组类型。 return后面可以连接列表、元组或字典，以返回多个值。 函数的参数位置参数位置参数：调用函数时根据函数定义的参数位置来传递参数。 123def user_info(name, age, gender): print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')user_info('TOM', 20, '男') 注意：传递和定义参数的顺序及个数必须一致。 关键字参数函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。 123456def user_info(name, age, gender): print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')user_info('Rose', age=20, gender='女')user_info('小明', gender='男', age=16) 注意：**函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。** 缺省参数缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。 1234def user_info(name, age, gender='男'): print(f'您的名字是{name}, 年龄是{age}, 性别是{gender}')user_info('TOM', 20)user_info('Rose', 18, '女') 注意：函数调用时，如果为缺省参数传值则修改默认参数值；否则使用这个默认值。 不定长参数不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。 包裹位置传递123456def user_info(*args): print(args)#### ('TOM',)user_info('TOM')#### ('TOM', 18)user_info('TOM', 18) 注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。 包裹关键字传递1234def user_info(**kwargs): print(kwargs)#### {'name': 'TOM', 'age': 18, 'id': 110}user_info(name='TOM', age=18, id=110) 综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。 拆包和交换变量值拆包 拆包：元组12345def return_num(): return 100, 200num1, num2 = return_num()print(num1) # 100print(num2) # 200 拆包：字典1234567dict1 = {'name': 'TOM', 'age': 18}a, b = dict1#### 对字典进行拆包，取出来的是字典的keyprint(a) # nameprint(b) # ageprint(dict1[a]) # TOMprint(dict1[b]) # 18 交换变量值需求：有变量a = 10和b = 20，交换两个变量的值。借助第三变量存储数据。12345678910#### 1. 定义中间变量c = 0#### 2. 将a的数据存储到cc = a#### 3. 将b的数据20赋值到a，此时a = 20a = b#### 4. 将之前c的数据10赋值到b，此时b = 10b = cprint(a) # 20print(b) # 10 1234a, b = 1, 2a, b = b, aprint(a) # 2print(b) # 1 引用在python中，值是靠引用来传递来的。 我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标识。 int类型为不可变类型 列表为可变类型123456789101112131415161718192021222324252627#### 1. int类型a = 1b = aprint(b) # 1print(id(a)) # 140708464157520print(id(b)) # 140708464157520a = 2print(b) # 1,说明int类型为不可变类型 print(id(a)) # 140708464157552，此时得到是的数据2的内存地址print(id(b)) # 140708464157520#### 2. 列表aa = [10, 20]bb = aaprint(id(aa)) # 2325297783432print(id(bb)) # 2325297783432aa.append(30)print(bb) # [10, 20, 30], 列表为可变类型print(id(aa)) # 2325297783432print(id(bb)) # 2325297783432 引用当做实参代码如下：123456789101112def test1(a): print(a) print(id(a)) a += a print(a) print(id(a))# int：计算前后id值不同b = 100test1(b)# 列表：计算前后id值相同c = [11, 22]test1(c) 可变和不可变类型所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变. – – 可变类型 - 列表 - 字典- 集合 不可变类型 - 整型- 浮点型 - 字符串- 元组 应用：学员管理系统系统简介需求：进入系统显示系统功能界面，功能如下： 1、添加学员 2、删除学员 3、修改学员信息 4、查询学员信息 5、显示所有学员信息 6、退出系统系统共6个功能，用户根据自己需求选取。步骤分析 显示功能界面 用户输入功能序号 根据用户输入的功能序号，执行不同的功能(函数)3.1 定义函数3.2 调用函数需求实现显示功能界面 定义函数print_info，负责显示系统功能。 12345678910111213def print_info(): print('-' * 20) print('欢迎登录学员管理系统') print('1: 添加学员') print('2: 删除学员') print('3: 修改学员信息') print('4: 查询学员信息') print('5: 显示所有学员信息') print('6: 退出系统') print('-' * 20) print_info() 用户输入序号，选择功能1user_num = input('请选择您需要的功能序号：') 根据用户选择，执行不同的功能123456789101112if user_num == '1': print('添加学员')elif user_num == '2': print('删除学员')elif user_num == '3': print('修改学员信息')elif user_num == '4': print('查询学员信息')elif user_num == '5': print('显示所有学员信息')elif user_num == '6': print('退出系统') 工作中，需要根据实际需求调优代码。 用户选择系统功能的代码需要循环使用，直到用户主动退出系统。 如果用户输入1-6以外的数字，需要提示用户。 1234567891011121314151617181920while True: # 1. 显示功能界面 print_info() # 2. 用户选择功能 user_num = input('请选择您需要的功能序号：') # 3. 根据用户选择，执行不同的功能 if user_num == '1': print('添加学员') elif user_num == '2': print('删除学员') elif user_num == '3': print('修改学员信息') elif user_num == '4': print('查询学员信息') elif user_num == '5': print('显示所有学员信息') elif user_num == '6': print('退出系统') else: print('输入错误，请重新输入!!!') 定义不同功能的函数所有功能函数都是操作学员信息，所有存储所有学员信息应该是一个==全局变量==，数据类型为==列表==。 1info = [] 添加学员 接收用户输入学员信息，并保存 判断是否添加学员信息2.1 如果学员姓名已经存在，则报错提示2.2 如果学员姓名不存在，则准备空字典，将用户输入的数据追加到字典，再列表追加字典数据 对应的if条件成立的位置调用该函数 12345678910111213141516171819202122def add_info(): &quot;&quot;&quot; 添加学员 &quot;&quot;&quot; # 接收用户输入学员信息 new_id = input('请输入学号：') new_name = input('请输入姓名：') new_tel = input('请输入手机号：') # 声明info是全局变量 global info # 检测用户输入的姓名是否存在，存在则报错提示 for i in info: if new_name == i['name']: print('该用户已经存在！') return # 如果用户输入的姓名不存在，则添加该学员信息 info_dict = {} # 将用户输入的数据追加到字典 info_dict['id'] = new_id info_dict['name'] = new_name info_dict['tel'] = new_tel # 将这个学员的字典数据追加到列表 info.append(info_dict) print(info) 删除学员按用户输入的学员姓名进行删除 用户输入目标学员姓名 检查这个学员是否存在2.1 如果存在，则列表删除这个数据2.2 如果不存在，则提示“该用户不存在” 对应的if条件成立的位置调用该函数 1234567891011121314#### 删除学员def del_info(): &quot;&quot;&quot;删除学员&quot;&quot;&quot; # 1. 用户输入要删除的学员的姓名 del_name = input('请输入要删除的学员的姓名：') global info # 2. 判断学员是否存在:如果输入的姓名存在则删除，否则报错提示 for i in info: if del_name == i['name']: info.remove(i) break else: print('该学员不存在') print(info) 修改学员信息 用户输入目标学员姓名 检查这个学员是否存在2.1 如果存在，则修改这位学员的信息，例如手机号2.2 如果不存在，则报错 对应的if条件成立的位置调用该函数 1234567891011121314#### 修改函数def modify_info(): &quot;&quot;&quot;修改函数&quot;&quot;&quot; # 1. 用户输入要修改的学员的姓名 modify_name = input('请输入要修改的学员的姓名：') global info # 2. 判断学员是否存在：如果输入的姓名存在则修改手机号，否则报错提示 for i in info: if modify_name == i ['name']: i['tel'] = input('请输入新的手机号：') break else: print('该学员不存在') print(info) 查询学员信息 需求分析 用户输入目标学员姓名 检查学员是否存在2.1 如果存在，则显示这个学员的信息2.2 如果不存在，则报错提示 对应的if条件成立的位置调用该函数 1234567891011121314#### 查询学员def search_info(): &quot;&quot;&quot;查询学员&quot;&quot;&quot; # 1. 输入要查找的学员姓名： search_name = input('请输入要查找的学员姓名：') global info # 2. 判断学员是否存在：如果输入的姓名存在则显示这位学员信息，否则报错提示 for i in info: if search_name == i['name']: print('查找到的学员信息如下：----------') print(f&quot;该学员的学号是{i['id']}, 姓名是{i['name']}, 手机号是{i['tel']}&quot;) break else: print('该学员不存在') 显示所有学员信息 需求分析打印所有学员信息123456#### 显示所有学员信息def print_all(): &quot;&quot;&quot; 显示所有学员信息 &quot;&quot;&quot; print('学号\\t姓名\\t手机号') for i in info: print(f'{i[&quot;id&quot;]}\\t{i[&quot;name&quot;]}\\t{i[&quot;tel&quot;]}') 退出系统在用户输入功能序号6的时候要退出系统，代码如下：12345......elif user_num == '6': exit_flag = input('确定要退出吗？yes or no') if exit_flag == 'yes': break 递归递归的应用场景递归是一种编程思想，应用场景： 在我们日常开发中，如果要遍历一个文件夹下面所有的文件，通常会使用递归来实现； 在后续的算法课程中，很多算法都离不开递归，例如：快速排序。递归的特点 函数内部自己调用自己 必须有出口应用：3以内数字累加和 代码123456789101112#### 3 + 2 + 1def sum_numbers(num): # 1.如果是1，直接返回1 -- 出口 if num == 1: return 1 # 2.如果不是1，重复执行累加并返回结果 return num + sum_numbers(num-1)sum_result = sum_numbers(3)#### 输出结果为6print(sum_result) 执行结果 lambda 表达式lambda的应用场景如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化。 lambda语法1lambda 参数列表 ： 表达式 注意 lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用。 lambda表达式能接收任何数量的参数但只能返回一个表达式的值。123456789#### 函数def fn1(): return 200print(fn1)print(fn1())#### lambda表达式fn2 = lambda: 100print(fn2)print(fn2()) 注意：直接打印lambda表达式，输出的是此lambda的内存地址 示例：计算a + b函数实现1234def add(a, b): return a + bresult = add(1, 2)print(result) 思考：需求简单，是否代码多？ lambda实现12fn1 = lambda a, b: a + bprint(fn1(1, 2)) lambda的参数形式.无参数12fn1 = lambda: 100print(fn1()) 一个参数12fn1 = lambda a: aprint(fn1('hello world')) 默认参数12fn1 = lambda a, b, c=100: a + b + cprint(fn1(10, 20)) 可变参数：*args12fn1 = lambda *args: argsprint(fn1(10, 20, 30)) 注意：这里的可变参数传入到lambda之后，返回值为元组。 可变参数：**kwargs12fn1 = lambda **kwargs: kwargsprint(fn1(name='python', age=20)) lambda的应用带判断的lambda12fn1 = lambda a, b: a if a &gt; b else bprint(fn1(1000, 500)) 列表数据按字典key的值排序1234567891011121314students = [ {'name': 'TOM', 'age': 20}, {'name': 'ROSE', 'age': 19}, {'name': 'Jack', 'age': 22}]#### 按name值升序排列students.sort(key=lambda x: x['name'])print(students)#### 按name值降序排列students.sort(key=lambda x: x['name'], reverse=True)print(students)#### 按age值升序排列students.sort(key=lambda x: x['age'])print(students) 高阶函数==把函数作为参数传入==，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。体验高阶函数 在Python中，abs()函数可以完成对数字求绝对值计算。 1abs(-10) # 10 round()函数可以完成对数字的四舍五入计算。 12round(1.2) # 1round(1.9) # 2 需求：任意两个数字，按照指定要求整理数字后再进行求和计算。 方法1123456def add_num(a, b): return abs(a) + abs(b)result = add_num(-1, 2)print(result) # 3 方法2123456def sum_num(a, b, f): return f(a) + f(b)result = sum_num(-1, 2, abs)print(result) # 3 注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。 函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。 内置高阶函数map()map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。 需求：计算list1序列中各个数字的2次方。 1234567list1 = [1, 2, 3, 4, 5]def func(x): return x ** 2result = map(func, list1)print(result) # &lt;map object at 0x0000013769653198&gt;print(list(result)) # [1, 4, 9, 16, 25] reduce()reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。 注意：reduce()传入的参数func必须接收2个参数。 需求：计算list1序列中各个数字的累加和。 12345678import functoolslist1 = [1, 2, 3, 4, 5]def func(a, b): return a + bresult = functools.reduce(func, list1)print(result) # 15 filter()filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个 filter 对象。如果要转换为列表, 可以使用 list() 来转换。 123456list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]def func(x): return x % 2 == 0result = filter(func, list1)print(result) # &lt;filter object at 0x0000017AF9DC3198&gt;print(list(result)) # [2, 4, 6, 8, 10] 文件文件操作文件操作的作用思考：什么是文件？思考：文件操作包含什么？答：打开、关闭、读、写、复制….思考：文件操作的的作用是什么？答：读取内容、写入内容、备份内容…… 总结：文件操作的作用就是==把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力==。 文件的基本操作文件操作步骤 打开文件 读写等操作 关闭文件 注意：可以只打开和关闭文件，不进行任何读写操作。 2.1.1 打开 在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下： 1open(name, mode) name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。mode：设置打开文件的模式(访问模式)：只读、写入、追加等。打开文件模式 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 1f = open('test.txt', 'w') 注意：此时的f是open函数的文件对象。 文件对象方法写1对象.write('内容') 123456#### 1. 打开文件f = open('test.txt', 'w')#### 2.文件写入f.write('hello world')#### 3. 关闭文件f.close() 注意： w 和a模式：如果文件不存在则创建该文件；如果文件存在，w模式先清空再写入，a模式直接末尾追加。 r模式：如果文件不存在则报错。 读 read()1文件对象.read(num) num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。 readlines():readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。123456f = open('test.txt')content = f.readlines()#### ['hello world\\n', 'abcdefg\\n', 'aaa\\n', 'bbb\\n', 'ccc']print(content)#### 关闭文件f.close() readline():readline()一次读取一行内容。1234567f = open('test.txt')content = f.readline()print(f'第一行：{content}')content = f.readline()print(f'第二行：{content}')#### 关闭文件f.close() seek()作用：用来移动文件指针。语法如下：1文件对象.seek(偏移量, 起始位置) 起始位置： 0：文件开头 1：当前位置 2：文件结尾 关闭1文件对象.close() 文件备份需求：用户输入当前目录下任意文件名，程序完成对该文件的备份功能(备份文件名为xx[备份]后缀，例如：test[备份].txt)。步骤 接收用户输入的文件名 规划备份文件名 备份文件写入数据代码实现 接收用户输入目标文件名1old_name = input('请输入您要备份的文件名：') 规划备份文件名2.1 提取目标文件后缀2.2 组织备份的文件名，xx[备份]后缀12345678# 2.1 提取文件后缀点的下标index = old_name.rfind('.')# print(index) # 后缀中.的下标# print(old_name[:index]) # 源文件名（无后缀）## 2.2 组织新文件名 旧文件名 + [备份] + 后缀new_name = old_name[:index] + '[备份]' + old_name[index:]# 打印新文件名（带后缀）# print(new_name) 备份文件写入数据3.1 打开源文件 和 备份文件3.2 将源文件数据写入备份文件3.3 关闭文件123456789101112#### 3.1 打开文件old_f = open(old_name, 'rb')new_f = open(new_name, 'wb')#### 3.2 将源文件数据写入备份文件while True: con = old_f.read(1024) if len(con) == 0: break new_f.write(con)#### 3.3 关闭文件old_f.close()new_f.close() 思考如果用户输入.txt，这是一个无效文件，程序如何更改才能限制只有有效的文件名才能备份？ 答：添加条件判断即可。 123456789101112131415old_name = input('请输入您要备份的文件名：')index = old_name.rfind('.')if index &gt; 0: postfix = old_name[index:]new_name = old_name[:index] + '[备份]' + postfixold_f = open(old_name, 'rb')new_f = open(new_name, 'wb')while True: con = old_f.read(1024) if len(con) == 0: break new_f.write(con)old_f.close()new_f.close() 文件和文件夹的操作在Python中文件和文件夹的操作要借助os模块里面的相关功能，具体步骤如下： 导入os模块1import os 使用os模块相关功能1os.函数名() 文件重命名1os.rename(目标文件名, 新文件名) 删除文件1os.remove(目标文件名) 创建文件夹1os.mkdir(文件夹名字) 删除文件夹1os.rmdir(文件夹名字) 获取当前目录1os.getcwd() 改变默认目录1os.chdir(目录) 获取目录列表1os.listdir(目录) 应用案例 需求：批量修改文件名，既可添加指定字符串，又能删除指定字符串。 步骤 设置添加删除字符串的的标识 获取指定目录的所有文件 将原有文件名添加/删除指定字符串，构造新名字 os.rename()重命名 123456789101112131415161718192021import os#### 设置重命名标识：如果为1则添加指定字符，flag取值为2则删除指定字符flag = 1#### 获取指定目录dir_name = './'#### 获取指定目录的文件列表file_list = os.listdir(dir_name)#### print(file_list)#### 遍历文件列表内的文件for name in file_list: # 添加指定字符 if flag == 1: new_name = 'Python-' + name # 删除指定字符 elif flag == 2: num = len('Python-') new_name = name[num:] # 打印新文件名，测试程序正确性 print(new_name) # 重命名 os.rename(dir_name+name, dir_name+new_name) 面向对象基础理解面向对象面向对象是一种抽象化的编程思想，很多编程语言中都有的一种思想。 例如：洗衣服思考：几种途径可以完成洗衣服？答： 手洗 和 机洗。手洗：找盆 - 放水 - 加洗衣粉 - 浸泡 - 搓洗 - 拧干水 - 倒水 - 漂洗N次 - 拧干 - 晾晒。机洗：打开洗衣机 - 放衣服 - 加洗衣粉 - 按下开始按钮 - 晾晒。思考：对比两种洗衣服途径，同学们发现了什么？答：机洗更简单思考：机洗，只需要找到一台洗衣机，加入简单操作就可以完成洗衣服的工作，而不需要关心洗衣机内部发生了什么事情。 总结：==面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。== 类和对象 思考：洗衣机洗衣服描述过程中，洗衣机其实就是一个事物，即对象，洗衣机对象哪来的呢？答：洗衣机是由工厂工人制作出来。思考：工厂工人怎么制作出的洗衣机？答：工人根据设计师设计的功能图纸制作洗衣机。总结：图纸 → 洗衣机 → 洗衣服。在面向对象编程过程中，有两个重要组成部分：==类== 和 ==对象==。==类和对象的关系：用类去创建一个对象。== 理解类和对象类类是对一系列具有相同==特征==和==行为==的事物的统称，是一个==抽象的概念==，不是真实存在的事物。 特征即是属性 行为即是方法类比如是制造洗衣机时要用到的图纸，也就是说==类是用来创建对象==。对象对象是类创建出来的真实存在的事物，例如：洗衣机。 注意：开发中，先有类，再有对象。 面向对象实现方法定义类Python2中类分为：经典类 和 新式类123class 类名(): 代码 ...... 注意：类名要满足标识符命名规则，同时遵循==大驼峰命名习惯==。 123class Washer(): def wash(self): print('我会洗衣服') 拓展：经典类 不由任意内置类型派生出的类，称之为经典类 123class 类名: 代码 ...... 创建对象:对象又名实例。1对象名 = 类名() 123456# 创建对象haier1 = Washer()# &lt;__main__.Washer object at 0x0000018B7B224240&gt;print(haier1)# haier对象调用实例方法haier1.wash() 注意：创建对象的过程也叫实例化对象。 self:self指的是调用该函数的对象。1234567891011121314151617# 1. 定义类class Washer(): def wash(self): print('我会洗衣服') # &lt;__main__.Washer object at 0x0000024BA2B34240&gt; print(self)# 2. 创建对象haier1 = Washer()# &lt;__main__.Washer object at 0x0000018B7B224240&gt;print(haier1)# haier1对象调用实例方法haier1.wash()haier2 = Washer()# &lt;__main__.Washer object at 0x0000022005857EF0&gt;print(haier2) 注意：打印对象和self得到的结果是一致的，都是当前对象的内存中存储地址。 添加和获取对象属性属性即是特征，比如：洗衣机的宽度、高度、重量…对象属性既可以在类外面添加和获取，也能在类里面添加和获取。 类外面添加对象属性1对象名.属性名 = 值 12haier1.width = 500haier1.height = 800 类外面获取对象属性1对象名.属性名 12print(f'haier1洗衣机的宽度是{haier1.width}')print(f'haier1洗衣机的高度是{haier1.height}') 类里面获取对象属性1self.属性名 体验1234567891011121314# 定义类class Washer(): def print_info(self): # 类里面获取实例属性 print(f'haier1洗衣机的宽度是{self.width}') print(f'haier1洗衣机的高度是{self.height}')# 创建对象haier1 = Washer()# 添加实例属性haier1.width = 500haier1.height = 800haier1.print_info()#haier1洗衣机的宽度是{500}#haier1洗衣机的高度是{800} 魔法方法 在Python中，__xx__()的函数叫做魔法方法，指的是具有特殊功能的函数。 __init__()思考：洗衣机的宽度高度是与生俱来的属性，可不可以在生产过程中就赋予这些属性呢？答：理应如此。==__init__()方法的作用：初始化对象。== 12345678910111213class Washer(): # 定义初始化功能的函数 def __init__(self): # 添加实例属性 self.width = 500 self.height = 800 def print_info(self): # 类里面调用实例属性 print(f'洗衣机的宽度是{self.width}, 高度是{self.height}')haier1 = Washer()haier1.print_info() 注意： __init__()方法，在创建一个对象时默认被调用，不需要手动调用 __init__(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去。 带参数的__init__()思考：一个类可以创建多个对象，如何对不同的对象设置不同的初始化属性呢？答：传参数。 123456789101112class Washer(): def __init__(self, width, height): self.width = width self.height = height def print_info(self): print(f'洗衣机的宽度是{self.width}') print(f'洗衣机的高度是{self.height}')haier1 = Washer(10, 20)haier1.print_info()haier2 = Washer(30, 40)haier2.print_info() __str__()当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了__str__方法，那么就会打印从在这个方法中 return 的数据。 123456789class Washer(): def __init__(self, width, height): self.width = width self.height = height def __str__(self): return '这是海尔洗衣机的说明书'haier1 = Washer(10, 20)# 这是海尔洗衣机的说明书print(haier1) __del__()当删除对象时，python解释器也会默认调用__del__()方法。 123456789class Washer(): def __init__(self, width, height): self.width = width self.height = height def __del__(self): print(f'{self}对象已经被删除')haier1 = Washer(10, 20)# &lt;__main__.Washer object at 0x0000026118223278&gt;对象已经被删除del haier1 综合应用烤地瓜需求主线： 被烤的时间和对应的地瓜状态：0-3分钟：生的3-5分钟：半生不熟5-8分钟：熟的超过8分钟：烤糊了 添加的调料：用户可以按自己的意愿添加调料步骤分析需求涉及一个事物： 地瓜，故案例涉及一个类：地瓜类。定义类 地瓜的属性 被烤的时间 地瓜的状态 添加的调料 地瓜的方法 被烤 用户根据意愿设定每次烤地瓜的时间 判断地瓜被烤的总时间是在哪个区间，修改地瓜状态 添加调料 用户根据意愿设定添加的调料 将用户添加的调料存储 显示对象信息5.1.2.2 创建对象，调用相关实例方法代码实现 地瓜属性 定义地瓜初始化属性，后期根据程序推进更新实例属性12345678class SweetPotato(): def __init__(self): # 被烤的时间 self.cook_time = 0 # 地瓜的状态 self.cook_static = '生的' # 调料列表 self.condiments = [] 定义烤地瓜方法12345678910111213class SweetPotato(): ...... def cook(self, time): &quot;&quot;&quot;烤地瓜的方法&quot;&quot;&quot; self.cook_time += time if 0 &lt;= self.cook_time &lt; 3: self.cook_static = '生的' elif 3 &lt;= self.cook_time &lt; 5: self.cook_static = '半生不熟' elif 5 &lt;= self.cook_time &lt; 8: self.cook_static = '熟了' elif self.cook_time &gt;= 8: self.cook_static = '烤糊了' 书写str魔法方法，用于输出对象状态1234class SweetPotato(): ...... def __str__(self): return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}' 创建对象，测试实例属性和实例方法1234digua1 = SweetPotato()print(digua1)digua1.cook(2)print(digua1) 定义添加调料方法，并调用该实例方法1234567891011121314151617181920212223class SweetPotato(): ...... def add_condiments(self, condiment): &quot;&quot;&quot;添加调料&quot;&quot;&quot; self.condiments.append(condiment) def __str__(self): return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}, 添加的调料有{self.condiments}'digua1 = SweetPotato()print(digua1)digua1.cook(2)digua1.add_condiments('酱油')print(digua1)digua1.cook(2)digua1.add_condiments('辣椒面儿')print(digua1)digua1.cook(2)print(digua1)digua1.cook(2)print(digua1) 代码总览12345678910111213141516171819202122232425262728293031323334353637383940414243# 定义类class SweetPotato(): def __init__(self): # 被烤的时间 self.cook_time = 0 # 地瓜的状态 self.cook_static = '生的' # 调料列表 self.condiments = [] def cook(self, time): &quot;&quot;&quot;烤地瓜的方法&quot;&quot;&quot; self.cook_time += time if 0 &lt;= self.cook_time &lt; 3: self.cook_static = '生的' elif 3 &lt;= self.cook_time &lt; 5: self.cook_static = '半生不熟' elif 5 &lt;= self.cook_time &lt; 8: self.cook_static = '熟了' elif self.cook_time &gt;= 8: self.cook_static = '烤糊了' def add_condiments(self, condiment): &quot;&quot;&quot;添加调料&quot;&quot;&quot; self.condiments.append(condiment) def __str__(self): return f'这个地瓜烤了{self.cook_time}分钟, 状态是{self.cook_static}, 添加的调料有{self.condiments}'digua1 = SweetPotato()print(digua1)digua1.cook(2)digua1.add_condiments('酱油')print(digua1)digua1.cook(2)digua1.add_condiments('辣椒面儿')print(digua1)digua1.cook(2)print(digua1)digua1.cook(2)print(digua1) 搬家具将小于房子剩余面积的家具摆放到房子中步骤分析需求涉及两个事物：房子 和 家具，故被案例涉及两个类：房子类 和 家具类。定义类 房子类 实例属性 房子地理位置 房子占地面积 房子剩余面积 房子内家具列表 实例方法 容纳家具 显示房屋信息 家具类 家具名称 家具占地面积创建对象并调用相关方法 家具类 123456class Furniture(): def __init__(self, name, area): # 家具名字 self.name = name # 家具占地面积 self.area = area 房子类 1234567891011121314151617181920class Home(): def __init__(self, address, area): # 地理位置 self.address = address # 房屋面积 self.area = area # 剩余面积 self.free_area = area # 家具列表 self.furniture = [] def __str__(self): return f'房子坐落于{self.address}, 占地面积{self.area}, 剩余面积{self.free_area}, 家具有{self.furniture}' def add_furniture(self, item): &quot;&quot;&quot;容纳家具&quot;&quot;&quot; if self.free_area &gt;= item.area: self.furniture.append(item.name) # 家具搬入后，房屋剩余面积 = 之前剩余面积 - 该家具面积 self.free_area -= item.area else: print('家具太大，剩余面积不足，无法容纳') 创建对象并调用实例属性和方法1234567891011121314bed = Furniture('双人床', 6)jia1 = Home('北京', 1200)print(jia1)jia1.add_furniture(bed)print(jia1)sofa = Furniture('沙发', 10)jia1.add_furniture(sofa)print(jia1)ball = Furniture('篮球场', 1500)jia1.add_furniture(ball)print(jia1) 魔法方法 __init__(): 初始化 __str__():输出对象信息 __del__():删除对象时调用 面向对象-继承继承的概念生活中的继承，一般指的是子女继承父辈的财产。 拓展1：经典类或旧式类:不由任意内置类型派生出的类，称之为经典类。123class 类名: 代码 ...... 拓展2：新式类12class 类名(object): 代码 Python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，具体如下：1234567891011# 父类Aclass A(object): def __init__(self): self.num = 1 def info_print(self): print(self.num)# 子类Bclass B(A): passresult = B()result.info_print() # 1 在Python中，所有类默认继承object类，object类是顶级类或基类；其他子类叫做派生类。 单继承 故事主线：一个煎饼果子老师傅，在煎饼果子界摸爬滚打多年，研发了一套精湛的摊煎饼果子的技术。师父要把这套技术传授给他的唯一的最得意的徒弟。分析：徒弟是不是要继承师父的所有技术？ 123456789101112131415# 1. 师父类class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')# 2. 徒弟类class Prentice(Master): pass# 3. 创建对象daqiudaqiu = Prentice()# 4. 对象访问实例属性print(daqiu.kongfu)# 5. 对象调用实例方法daqiu.make_cake() 多继承 故事推进：daqiu是个爱学习的好孩子，想学习更多的煎饼果子技术，于是，在百度搜索到黑马程序员，报班学习煎饼果子技术。 所谓多继承意思就是一个类同时继承了多个父类。 123456789101112131415161718class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print( &quot;%s&quot; % self.kongfu)# 创建学校类class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print( &quot;%s&quot; % self.kongfu)class Prentice(School, Master): passdaqiu = Prentice()print(daqiu.kongfu)daqiu.make_cake()#[煎饼果子配方]#[煎饼果子配方] 注意：当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。 子类重写父类同名方法和属性 故事：daqiu掌握了师父和培训的技术后，自己潜心钻研出自己的独门配方的一套全新的煎饼果子技术。 12345678910111213141516171819202122232425class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')# 独创配方class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')daqiu = Prentice()print(daqiu.kongfu)daqiu.make_cake()print(Prentice.__mro__) 子类和父类具有同名属性和方法，默认使用子类的同名属性和方法。 子类调用父类的同名方法和属性 故事：很多顾客都希望也能吃到古法和新的技术的煎饼果子。 123456789101112131415161718192021222324252627282930313233343536373839class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): # 如果是先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化 self.__init__() print(f'运用{self.kongfu}制作煎饼果子') # 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化 def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)daqiu = Prentice()daqiu.make_cake()daqiu.make_master_cake()daqiu.make_school_cake()daqiu.make_cake() 多层继承 故事：N年后，daqiu老了，想要把所有技术传承给自己的徒弟。 1234567891011121314151617181920212223242526272829303132333435363738class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' def make_cake(self): self.__init__() print(f'运用{self.kongfu}制作煎饼果子') def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)# 徒孙类class Tusun(Prentice): passxiaoqiu = Tusun()xiaoqiu.make_cake()xiaoqiu.make_school_cake()xiaoqiu.make_master_cake() super()调用父类方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class School(Master): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子') # 方法2.1 # super(School, self).__init__() # super(School, self).make_cake() # 方法2.2 super().__init__() super().make_cake()class Prentice(School): def __init__(self): self.kongfu = '[独创煎饼果子技术]' def make_cake(self): self.__init__() print(f'运用{self.kongfu}制作煎饼果子') # 子类调用父类的同名方法和属性：把父类的同名属性和方法再次封装 def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self) # 一次性调用父类的同名属性和方法 def make_old_cake(self): # 方法一：代码冗余；父类类名如果变化，这里代码需要频繁修改 # Master.__init__(self) # Master.make_cake(self) # School.__init__(self) # School.make_cake(self) # 方法二: super() # 方法2.1 super(当前类名, self).函数() # super(Prentice, self).__init__() # super(Prentice, self).make_cake() # 方法2.2 super().函数() super().__init__() super().make_cake()daqiu = Prentice()daqiu.make_old_cake() 注意：使用super() 可以自动查找父类。调用顺序遵循 __mro__ 类属性的顺序。比较适合单继承使用。 私有权限定义私有属性和方法在Python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类。 故事：daqiu把技术传承给徒弟的同时，不想把自己的钱(2000000个亿)继承给徒弟，这个时候就要为钱这个实例属性设置私有权限。 ·设置私有权限的方法：在属性名和方法名 前面 加上两个下划线 __。· 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' # 定义私有属性 self.__money = 2000000 # 定义私有方法 def __info_print(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(f'运用{self.kongfu}制作煎饼果子') def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)# 徒孙类class Tusun(Prentice): passdaqiu = Prentice()# 对象不能访问私有属性和私有方法# print(daqiu.__money)# daqiu.__info_print()xiaoqiu = Tusun()# 子类无法继承父类的私有属性和私有方法# print(xiaoqiu.__money) # 无法访问实例属性__money# xiaoqiu.__info_print() 注意：私有属性和私有方法只能在类里面访问和修改。 获取和修改私有属性值在Python中，一般定义函数名get_xx用来获取私有属性，定义set_xx用来修改私有属性值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Master(object): def __init__(self): self.kongfu = '[古法煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class School(object): def __init__(self): self.kongfu = '[黑马煎饼果子配方]' def make_cake(self): print(f'运用{self.kongfu}制作煎饼果子')class Prentice(School, Master): def __init__(self): self.kongfu = '[独创煎饼果子配方]' self.__money = 2000000 # 获取私有属性 def get_money(self): return self.__money # 修改私有属性 def set_money(self): self.__money = 500 def __info_print(self): print(self.kongfu) print(self.__money) def make_cake(self): self.__init__() print(f'运用{self.kongfu}制作煎饼果子') def make_master_cake(self): Master.__init__(self) Master.make_cake(self) def make_school_cake(self): School.__init__(self) School.make_cake(self)# 徒孙类class Tusun(Prentice): passdaqiu = Prentice()xiaoqiu = Tusun()# 调用get_money函数获取私有属性money的值print(xiaoqiu.get_money())# 调用set_money函数修改私有属性money的值xiaoqiu.set_money()print(xiaoqiu.get_money()) 异常了解异常当检测到一个错误时，解释器就无法继续执行了，反而出现了一些错误的提示，这就是所谓的”异常”。 例如：以r方式打开一个不存在的文件。 1open('test.txt', 'r') 异常的写法1234try: 可能发生错误的代码except: 如果出现异常执行的代码 需求：尝试以r模式打开文件，如果文件不存在，则以w方式打开。 1234try: f = open('test.txt', 'r')except: f = open('test.txt', 'w') 捕获指定异常1234try: 可能发生错误的代码except 异常类型: 如果捕获到该异常类型执行的代码 1234try: print(num)except NameError: print('有错误') 注意： 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。 一般try下方只放一行尝试执行的代码。 捕获多个指定异常当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。 12345try: print(1/0)except (NameError, ZeroDivisionError): print('有错误') 捕获异常描述信息1234try: print(num)except (NameError, ZeroDivisionError) as result: print(result) 捕获所有异常Exception是所有程序异常类的父类。 1234try: print(num)except Exception as result: print(result) 异常的elseelse表示的是如果没有异常要执行的代码。 123456try: print(1)except Exception as result: print(result)else: print('我是else，是没有异常的时候执行的代码') 异常的finallyfinally表示的是无论是否异常都要执行的代码，例如关闭文件。 12345678try: f = open('test.txt', 'r')except Exception as result: f = open('test.txt', 'w')else: print('没有异常，真开心')finally: f.close() 异常的传递​ 1. 尝试只读方式打开test.txt文件，如果文件存在则读取文件内容，文件不存在则提示用户即可。 ​ 2. 读取内容要求：尝试循环读取内容，读取过程中如果检测到用户意外终止程序，则except捕获异常并提示用户。 12345678910111213141516171819import timetry: f = open('test.txt') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) except: # 如果在读取文件的过程中，产生了异常，那么就会捕获到 # 比如 按下了 ctrl+c print('意外终止了读取数据') finally: f.close() print('关闭文件')except: print(&quot;没有这个文件&quot;) 自定义异常在Python中，抛出自定义异常的语法为 raise 异常类对象。 需求：密码长度不足，则报异常（用户输入密码，如果输入的长度不足3位，则报错，即抛出自定义异常，并捕获该异常）。 12345678910111213141516171819202122# 自定义异常类，继承Exceptionclass ShortInputError(Exception): def __init__(self, length, min_len): self.length = length self.min_len = min_len # 设置抛出异常的描述信息 def __str__(self): return f'你输入的长度是{self.length}, 不能少于{self.min_len}个字符'def main(): try: con = input('请输入密码：') if len(con) &lt; 3: raise ShortInputError(len(con), 3) except Exception as result: print(result) else: print('密码已经输入完成')main() 模块和包模块Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。模块能定义函数，类和变量，模块里也能包含可执行的代码。 导入模块导入模块的方式 import 模块名 from 模块名 import 功能名 from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 import12345# 1. 导入模块import 模块名import 模块名1, 模块名2...# 2. 调用功能模块名.功能名() 12import mathprint(math.sqrt(9)) # 3.0 from..import..1from 模块名 import 功能1, 功能2, 功能3... 12from math import sqrtprint(sqrt(9)) from .. import *1from 模块名 import * 12from math import *print(sqrt(9)) as定义别名1234# 模块定义别名import 模块名 as 别名# 功能定义别名from 模块名 import 功能 as 别名 12345678# 模块别名import time as tttt.sleep(2)print('hello')# 功能别名from time import sleep as slsl(2)print('hello') 制作模块在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块名必须要符合标识符命名规则。 定义模块新建一个Python文件，命名为my_module1.py，并定义testA函数。 12def testA(a, b): print(a + b) 测试模块在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息.，例如，在my_module1.py文件中添加测试代码。 12345def testA(a, b): print(a + b)testA(1, 1) 此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行testA函数的调用。解决办法如下：·main函数· 12345def testA(a, b): print(a + b)# 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行testA函数调用if __name__ == '__main__': testA(1, 1) 调用模块12import my_module1my_module1.testA(1, 1) 注意事项如果使用from .. import ..或from .. import *导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是后面导入的模块的功能。 体验1234567891011# 模块1代码def my_test(a, b): print(a + b)# 模块2代码def my_test(a, b): print(a - b)# 导入模块和调用功能代码from my_module1 import my_testfrom my_module2 import my_test# my_test函数是模块2中的函数my_test(1, 1) 模块定位顺序当导入一个模块，Python解析器对模块位置的搜索顺序是： 当前目录 如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。 如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/ 模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。 注意 自己的文件名不要和已有模块名重复，否则导致模块功能无法使用 使用from 模块名 import 功能的时候，如果功能名字重复，调用到的是最后定义或导入的功能。__all__ 如果一个模块文件中有__all__变量，当使用from xxx import *导入时，只能导入这个列表中的元素。 my_module1模块代码123456789__all__ = ['testA']def testA(): print('testA')def testB(): print('testB') 导入模块的文件代码123from my_module1 import *testA()testB() 包包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为__init__.py 文件，那么这个文件夹就称之为包。 制作包[New] — [Python Package] — 输入包名 — [OK] — 新建功能模块(有联系的模块)。 注意：新建包后，包内部会自动创建__init__.py文件，这个文件控制着包的导入行为。 新建包mypackage 新建包内模块：my_module1 和 my_module2 模块内代码如下123456# my_module1print(1)def info_print1(): print('my_module1') 123456# my_module2print(2)def info_print2(): print('my_module2') 导入包方法一123import 包名.模块名包名.模块名.目标 123import my_package.my_module1my_package.my_module1.info_print1() 方法二 注意：必须在__init__.py文件中添加__all__ = []，控制允许导入的模块列表。 12from 包名 import *模块名.目标 123from my_package import *my_module1.info_print1() 课程：面向对象版学员管理系统系统需求使用面向对象编程思想完成学员管理系统的开发，具体如下： 系统要求：学员数据存储在文件中 系统功能：添加学员、删除学员、修改学员信息、查询学员信息、显示所有学员信息、保存学员信息及退出系统等功能。准备程序文件 角色分析 学员 管理系统 工作中注意事项 为了方便维护代码，一般一个角色一个程序文件； 项目要有主程序入口，习惯为main.py 创建程序文件创建项目目录，例如：StudentManagerSystem程序文件如下： 程序入口文件：main.py 学员文件：student.py 管理系统文件：managerSystem.pystudent.py需求： 学员信息包含：姓名、性别、手机号； 添加__str__魔法方法，方便查看学员对象信息1234567class Student(object): def __init__(self, name, gender, tel): self.name = name self.gender = gender self.tel = tel def __str__(self): return f'{self.name}, {self.gender}, {self.tel}' managerSystem.py需求： 存储数据的位置：文件(student.data) 加载文件数据 修改数据后保存到文件 存储数据的形式：列表存储学员对象 系统功能 添加学员 删除学员 修改学员 查询学员信息 显示所有学员信息 保存学员信息 退出系统定义类1234class StudentManager(object): def __init__(self): # 存储数据所用的列表 self.student_list = [] 管理系统框架 需求：系统功能循环使用，用户输入不同的功能序号执行不同的功能。 步骤 定义程序入口函数 加载数据 显示功能菜单 用户输入功能序号 根据用户输入的功能序号执行不同的功能 定义系统功能函数，添加、删除学员等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class StudentManager(object): def __init__(self): # 存储数据所用的列表 self.student_list = [] # 一. 程序入口函数，启动程序后执行的函数 def run(self): # 1. 加载学员信息 self.load_student() while True: # 2. 显示功能菜单 self.show_menu() # 3. 用户输入功能序号 menu_num = int(input('请输入您需要的功能序号：')) # 4 根据用户输入的功能序号执行不同的功能 if menu_num == 1: # 添加学员 self.add_student() elif menu_num == 2: # 删除学员 self.del_student() elif menu_num == 3: # 修改学员信息 self.modify_student() elif menu_num == 4: # 查询学员信息 self.search_student() elif menu_num == 5: # 显示所有学员信息 self.show_student() elif menu_num == 6: # 保存学员信息 self.save_student() elif menu_num == 7: # 退出系统 break # 二. 定义功能函数 # 2.1 显示功能菜单 @staticmethod def show_menu(): print('请选择如下功能-----------------') print('1:添加学员') print('2:删除学员') print('3:修改学员信息') print('4:查询学员信息') print('5:显示所有学员信息') print('6:保存学员信息') print('7:退出系统') # 2.2 添加学员 def add_student(self): pass # 2.3 删除学员 def del_student(self): pass # 2.4 修改学员信息 def modify_student(self): pass # 2.5 查询学员信息 def search_student(self): pass # 2.6 显示所有学员信息 def show_student(self): pass # 2.7 保存学员信息 def save_student(self): pass # 2.8 加载学员信息 def load_student(self): pass main.py123456# 1. 导入managerSystem模块from managerSystem import *# 2. 启动学员管理系统if __name__ == '__main__': student_manager = StudentManager() student_manager.run() 定义系统功能函数添加功能 需求：用户输入学员姓名、性别、手机号，将学员添加到系统。 步骤 用户输入姓名、性别、手机号 创建该学员对象 将该学员对象添加到列表 代码12345678910111213141516171819# 添加学员函数内部需要创建学员对象，故先导入student模块from student import *class StudentManager(object): ...... # 2.2 添加学员 def add_student(self): # 1. 用户输入姓名、性别、手机号 name = input('请输入您的姓名：') gender = input('请输入您的性别：') tel = input('请输入您的手机号：') # 2. 创建学员对象：先导入学员模块，再创建对象 student = Student(name, gender, tel) # 3. 将该学员对象添加到列表 self.student_list.append(student) # 打印信息 print(self.student_list) print(student) 删除学员 需求：用户输入目标学员姓名，如果学员存在则删除该学员。 步骤 用户输入目标学员姓名 遍历学员数据列表，如果用户输入的学员姓名存在则删除，否则则提示该学员不存在。 代码12345678910111213# 2.3 删除学员：删除指定姓名的学员def del_student(self): # 1. 用户输入目标学员姓名 del_name = input('请输入要删除的学员姓名：') # 2. 如果用户输入的目标学员存在则删除，否则提示学员不存在 for i in self.student_list: if i.name == del_name: self.student_list.remove(i) break else: print('查无此人！') # 打印学员列表，验证删除功能 print(self.student_list) 修改学员信息 需求：用户输入目标学员姓名，如果学员存在则修改该学员信息。 步骤 用户输入目标学员姓名； 遍历学员数据列表，如果用户输入的学员姓名存在则修改学员的姓名、性别、手机号数据，否则则提示该学员不存在。 代码1234567891011121314# 2.4 修改学员信息def modify_student(self): # 1. 用户输入目标学员姓名 modify_name = input('请输入要修改的学员的姓名：') # 2. 如果用户输入的目标学员存在则修改姓名、性别、手机号等数据，否则提示学员不存在 for i in self.student_list: if i.name == modify_name: i.name = input('请输入学员姓名：') i.gender = input('请输入学员性别：') i.tel = input('请输入学员手机号：') print(f'修改该学员信息成功，姓名{i.name},性别{i.gender}, 手机号{i.tel}') break else: print('查无此人！') 查询学员信息 需求：用户输入目标学员姓名，如果学员存在则打印该学员信息 步骤 用户输入目标学员姓名 遍历学员数据列表，如果用户输入的学员姓名存在则打印学员信息，否则提示该学员不存在。 代码1234567891011# 2.5 查询学员信息def search_student(self): # 1. 用户输入目标学员姓名 search_name = input('请输入要查询的学员的姓名：') # 2. 如果用户输入的目标学员存在，则打印学员信息，否则提示学员不存在 for i in self.student_list: if i.name == search_name: print(f'姓名{i.name},性别{i.gender}, 手机号{i.tel}') break else: print('查无此人!') 显示所有学员信息 打印所有学员信息 步骤 遍历学员数据列表，打印所有学员信息 代码12345# 2.6 显示所有学员信息def show_student(self): print('姓名\\t性别\\t手机号') for i in self.student_list: print(f'{i.name}\\t{i.gender}\\t{i.tel}') 保存学员信息 需求：将修改后的学员数据保存到存储数据的文件。 步骤 打开文件 文件写入数据 关闭文件 思考 文件写入的数据是学员对象的内存地址吗？ 文件内数据要求的数据类型是什么？ 拓展__dict__123456789class A(object): a = 0 def __init__(self): self.b = 1aa = A()# 返回类内部所有属性和方法对应的字典print(A.__dict__)# 返回实例属性和值组成的字典print(aa.__dict__) 在Python中 代码12345678910111213# 2.7 保存学员信息def save_student(self): # 1. 打开文件 f = open('student.data', 'w') # 2. 文件写入学员数据 # 注意1：文件写入的数据不能是学员对象的内存地址，需要把学员数据转换成列表字典数据再做存储 new_list = [i.__dict__ for i in self.student_list] # [{'name': 'aa', 'gender': 'nv', 'tel': '111'}] print(new_list) # 注意2：文件内数据要求为字符串类型，故需要先转换数据类型为字符串才能文件写入数据 f.write(str(new_list)) # 3. 关闭文件 f.close() 加载学员信息 需求：每次进入系统后，修改的数据是文件里面的数据 步骤 尝试以&quot;r&quot;模式打开学员数据文件，如果文件不存在则以&quot;w&quot;模式打开文件 如果文件存在则读取数据并存储数据 读取数据 转换数据类型为列表并转换列表内的字典为对象 存储学员数据到学员列表 关闭文件 代码12345678910111213141516# 2.8 加载学员信息def load_student(self): # 尝试以&quot;r&quot;模式打开数据文件，文件不存在则提示用户；文件存在（没有异常）则读取数据 try: f = open('student.data', 'r') except: f = open('student.data', 'w') else: # 1. 读取数据 data = f.read() # 2. 文件中读取的数据都是字符串且字符串内部为字典数据，故需要转换数据类型再转换字典为对象后存储到学员列表 new_list = eval(data) self.student_list = [Student(i['name'], i['gender'], i['tel']) for i in new_list] finally: # 3. 关闭文件 f.close() 多任务的介绍Python 多进程导入进程包12#导入进程包import multiprocessing Process进程类的说明1Process([group [, target [, name [, args [, kwargs]]]]]) group：指定进程组，目前只能使用None target：执行的目标任务名 name：进程名字 args：以元组方式给执行任务传参 kwargs：以字典方式给执行任务传参Process创建的实例对象的常用方法: start()：启动子进程实例（创建子进程） join()：等待子进程执行结束 terminate()：不管任务是否完成，立即终止子进程Process创建的实例对象的常用属性: name：当前进程的别名，默认为Process-N，N为从1开始递增的整数多进程完成多任务的代码1234567891011121314151617181920212223import multiprocessingimport time# 跳舞任务def dance(): for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2)# 唱歌任务def sing(): for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2)if __name__ == '__main__': # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果:唱歌中…跳舞中…唱歌中…跳舞中…唱歌中…跳舞中…唱歌中…跳舞中…唱歌中…跳舞中… 获取进程编号获取进程编号的目的获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。获取进程编号的两种操作 获取当前进程编号 获取当前父进程编号 是OS模块获取当前进程编号os.getpid() 表示获取当前进程编号123456789101112131415161718192021222324252627282930313233343536373839import multiprocessingimport timeimport os# 跳舞任务def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9)# 唱歌任务def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2)if __name__ == '__main__': # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果:main: 70763main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70768dance: &lt;Process(myprocess1, started)&gt;跳舞中…sing: 70769sing: &lt;Process(Process-2, started)&gt;唱歌中…唱歌中…唱歌中…唱歌中…唱歌中… 获取当前父进程编号os.getppid() 表示获取当前父进程编号12345678910111213141516171819202122232425262728293031323334353637383940414243import multiprocessingimport timeimport os# 跳舞任务def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;dance的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9)# 唱歌任务def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;sing的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2)if __name__ == '__main__': # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() main: 70860main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70861dance: &lt;Process(myprocess1, started)&gt;dance的父进程编号: 70860跳舞中…sing: 70862sing: &lt;Process(Process-2, started)&gt;sing的父进程编号: 70860唱歌中…唱歌中…唱歌中…唱歌中…唱歌中… 进程执行带有参数的任务进程执行带有参数的任务的介绍我们使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?Process类执行任务并给任务传参数有两种方式: args 表示以元组的方式给执行任务传参 kwargs 表示以字典方式给执行任务传参 args参数的使用 123456789101112131415import multiprocessingimport time# 带有参数的任务def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;)if __name__ == '__main__': # 创建子进程 # args: 以元组的方式给任务传入参数 sub_process = multiprocessing.Process(target=task, args=(5,)) sub_process.start() 任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成kwargs参数的使用 12345678910111213141516import multiprocessingimport time# 带有参数的任务def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;)if __name__ == '__main__': # 创建子进程 # kwargs: 表示以字典方式传入参数 sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3}) sub_process.start() 任务执行中..任务执行中..任务执行中..任务执行完成 进程的注意点进程的注意点介绍: 进程之间不共享全局变量 主进程会等待所有的子进程执行结束再结束进程之间不共享全局变量:123456789101112131415161718192021222324252627282930import multiprocessingimport time# 定义全局变量g_list = list()# 添加数据的任务def add_data(): for i in range(5): g_list.append(i) print(&quot;add:&quot;, i) time.sleep(0.2) # 代码执行到此，说明数据添加完成 print(&quot;add_data:&quot;, g_list)def read_data(): print(&quot;read_data&quot;, g_list)if __name__ == '__main__': # 创建添加数据的子进程 add_data_process = multiprocessing.Process(target=add_data) # 创建读取数据的子进程 read_data_process = multiprocessing.Process(target=read_data) # 启动子进程执行对应的任务 add_data_process.start() # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据 add_data_process.join() read_data_process.start() print(&quot;main:&quot;, g_list) # 总结: 多进程之间不共享全局变量 add: 0add: 1add: 2add: 3add: 4add_data: [0, 1, 2, 3, 4]main: []read_data [] 创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。 主进程会等待所有的子进程执行结束再结束假如我们现在创建一个子进程，这个子进程执行完大概需要2秒钟，现在让主进程执行0.5秒钟就退出程序，查看一下执行结果. 1234567891011121314151617import multiprocessingimport time# 定义进程所需要执行的任务def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2)if __name__ == '__main__': # 创建子进程 sub_process = multiprocessing.Process(target=task) sub_process.start() # 主进程延时0.5秒钟 time.sleep(0.5) print(&quot;over&quot;) exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 任务执行中…任务执行中…任务执行中…over任务执行中…任务执行中…任务执行中…任务执行中…任务执行中…任务执行中…任务执行中… 主进程会等待所有的子进程执行结束再结束,假如我们就让主进程执行0.5秒钟，子进程就销毁不再执行，那怎么办呢?我们可以设置守护主进程 或者 在主进程退出之前 让子进程销毁 守护主进程:守护主进程就是主进程退出子进程销毁不再执行 子进程销毁:子进程执行结束123456789101112131415161718192021import multiprocessingimport time# 定义进程所需要执行的任务def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2)if __name__ == '__main__': # 创建子进程 sub_process = multiprocessing.Process(target=task) # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程 # sub_process.daemon = True sub_process.start() time.sleep(0.5) print(&quot;over&quot;) # 让子进程销毁 sub_process.terminate() exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁 多线程的使用导入线程模块12#导入线程模块import threading 线程类Thread参数说明1Thread([group [, target [, name [, args [, kwargs]]]]]) group: 线程组，目前只能使用None target: 执行的目标任务名 args: 以元组的方式给执行任务传参 kwargs: 以字典方式给执行任务传参 name: 线程名，一般不用设置启动线程 启动线程使用start方法多线程完成多任务1234567891011121314151617181920212223242526272829import threadingimport time# 唱歌任务def sing(): # 扩展： 获取当前线程 # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在唱歌...%d&quot; % i) time.sleep(1)# 跳舞任务def dance(): # 扩展： 获取当前线程 # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在跳舞...%d&quot; % i) time.sleep(1)if __name__ == '__main__': # 扩展： 获取当前线程 # print(&quot;当前执行的线程为：&quot;, threading.current_thread()) # 创建唱歌的线程 # target： 线程执行的函数名 sing_thread = threading.Thread(target=sing) # 创建跳舞的线程 dance_thread = threading.Thread(target=dance) # 开启线程 sing_thread.start() dance_thread.start() 正在唱歌…0正在跳舞…0正在唱歌…1正在跳舞…1正在唱歌…2正在跳舞…2 线程执行带有参数的任务线程执行带有参数的任务的介绍前面我们使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?Thread类执行任务并给任务传参数有两种方式: args 表示以元组的方式给执行任务传参 kwargs 表示以字典方式给执行任务传参 args参数的使用 12345678910111213141516import threadingimport time# 带有参数的任务def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;)if __name__ == '__main__': # 创建子线程 # args: 以元组的方式给任务传入参数 sub_thread = threading.Thread(target=task, args=(5,)) sub_thread.start() 任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成kwargs参数的使用 12345678910111213141516import threadingimport time# 带有参数的任务def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;)if __name__ == '__main__': # 创建子线程 # kwargs: 表示以字典方式传入参数 sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3}) sub_thread.start() 任务执行中..任务执行中..任务执行中..任务执行完成 线程的注意点 线程之间执行是无序的 主线程会等待所有的子线程执行结束再结束 线程之间共享全局变量 线程之间共享全局变量数据出现错误问题线程之间执行是无序的 线程之间执行是无序的，它是由cpu调度决定的 ，cpu调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。 进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。12345678910111213import threadingimport timedef task(): time.sleep(1) print(&quot;当前线程:&quot;, threading.current_thread().name)if __name__ == '__main__': for _ in range(5): sub_thread = threading.Thread(target=task) sub_thread.start() 当前线程: Thread-1当前线程: Thread-2当前线程: Thread-4当前线程: Thread-5当前线程: Thread-3 主线程会等待所有的子线程执行结束再结束假如我们现在创建一个子线程，这个子线程执行完大概需要2.5秒钟，现在让主线程执行1秒钟就退出程序，查看一下执行结果123456789101112131415import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5)if __name__ == '__main__': sub_thread = threading.Thread(target=show_info) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) test: 0test: 1overtest: 2test: 3test: 4主线程会等待所有的子线程执行结束再结束,假如我们就让主线程执行1秒钟，子线程就销毁不再执行，那怎么办呢? 我们可以设置守护主线程守护主线程:守护主线程就是主线程退出子线程销毁不再执行设置守护主线程有两种方式： threading.Thread(target=show_info, daemon=True) 线程对象.setDaemon(True)123456789101112131415161718192021import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5)if __name__ == '__main__': # 创建子线程守护主线程 # daemon=True 守护主线程 # 守护主线程方式1 sub_thread = threading.Thread(target=show_info, daemon=True) # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码 # 守护主线程方式2 # sub_thread.setDaemon(True) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) test: 0test: 1over 线程之间共享全局变量 需求: 定义一个列表类型的全局变量创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务查看线程之间是否共享全局变量数据 123456789101112131415161718192021222324252627import threadingimport time# 定义全局变量my_list = list()# 写入数据任务def write_data(): for i in range(5): my_list.append(i) time.sleep(0.1) print(&quot;write_data:&quot;, my_list)# 读取数据任务def read_data(): print(&quot;read_data:&quot;, my_list)if __name__ == '__main__': # 创建写入数据的线程 write_thread = threading.Thread(target=write_data) # 创建读取数据的线程 read_thread = threading.Thread(target=read_data) write_thread.start() # 延时 # time.sleep(1) # 主线程等待写入线程执行完成以后代码在继续往下执行 write_thread.join() print(&quot;开始读取数据啦&quot;) read_thread.start() write_data: [0, 1, 2, 3, 4]开始读取数据啦read_data: [0, 1, 2, 3, 4] 线程之间共享全局变量数据出现错误问题需求: 定义两个函数，实现循环100万次，每循环一次给全局变量加1 创建两个子线程执行对应的两个函数，查看计算后的结果12345678910111213141516171819202122232425import threading# 定义全局变量g_num = 0# 循环一次给全局变量加1def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num)# 循环一次给全局变量加1def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num)if __name__ == '__main__': # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 启动线程 second_thread.start() sum1: 1210949sum2: 1496035 多线程同时对全局变量操作数据发生了错误,错误分析: 两个线程first_thread和second_thread都要对全局变量g_num(默认是0)进行加1运算，但是由于是多线程同时操作，有可能出现下面情况： 在g_num=0时，first_thread取得g_num=0。此时系统把first_thread调度为”sleeping”状态，把second_thread转换为”running”状态，t2也获得g_num=0 然后second_thread对得到的值进行加1并赋给g_num，使得g_num=1 然后系统又把second_thread调度为”sleeping”，把first_thread转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。 这样导致虽然first_thread和first_thread都对g_num加1，但结果仍然是g_num=1全局变量数据错误的解决办法: 线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机 线程同步的方式: 线程等待(join) 互斥锁12345678910111213141516171819202122232425262728import threading# 定义全局变量g_num = 0# 循环1000000次每次给全局变量加1def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num)# 循环1000000次每次给全局变量加1def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num)if __name__ == '__main__': # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程 # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行 first_thread.join() # 启动线程 second_thread.start() sum1: 1000000sum2: 2000000 互斥锁互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。注意:互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。互斥锁的使用互斥锁使用步骤:1234567# 创建锁mutex = threading.Lock()# 上锁mutex.acquire()...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...# 释放锁mutex.release() 注意点:acquire和release方法之间的代码同一时刻只能有一个线程去操作如果在调用acquire方法的时候 其他线程已经使用了这个互斥锁，那么此时acquire方法会堵塞，直到这个互斥锁释放后才能再次上锁。使用互斥锁完成2个线程对同一个全局变量各加100万次的操作123456789101112131415161718192021222324252627282930313233343536import threading# 定义全局变量g_num = 0# 创建全局互斥锁lock = threading.Lock()# 循环一次给全局变量加1def sum_num1(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 释放锁 lock.release()# 循环一次给全局变量加1def sum_num2(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) # 释放锁 lock.release()if __name__ == '__main__': # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() second_thread.start() # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待 # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行 sum1: 1000000sum2: 2000000 说明:通过执行结果可以地址互斥锁能够保证多个线程访问共享数据不会出现数据错误问题 死锁:死锁: 一直等待对方释放锁的情景就是死锁 死锁示例需求:根据下标在列表中取值, 保证同一时刻只能有一个线程去取值 1234567891011121314151617181920212223242526import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] # 判断下标释放越界 if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release()if __name__ == '__main__': # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 避免死锁==在合适的地方释放锁- 123456789101112131415161718192021222324252627import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) # 当下标越界需要释放锁，让后面的线程还可以取值 lock.release() return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release()if __name__ == '__main__': # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 进程和线程的对比的三个方向 ==关系对比== 线程是依附在进程里面的，没有进程就没有线程。 一个进程默认提供一条线程，进程可以创建多个线程。 ==区别对比== 进程之间不共享全局变量， 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步 创建进程的资源开销要比创建线程的资源开销要大 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位 线程不能够独立执行，必须依存在进程中 多进程开发比单进程多线程开发稳定性要强 ==优缺点对比== 进程优缺点: 优点：可以用多核 缺点：资源开销大 线程优缺点: 优点：资源开销小 缺点：不能使用多核网络编程socket 的概念socket (简称 套接字) 是进程之间通信一个工具，好比现实生活中的插座，所有的家用电器要想工作都是基于插座进行，进程之间想要进行网络通信需要基于这个 socket。 socket 的作用：负责进程之间的网络数据传输，好比数据的搬运工。 socket 使用场景：不夸张的说，只要跟网络相关的应用程序或者软件都使用到了 socket 。 TCP 网络应用程序开发流程TCP 网络应用程序开发流程的介绍TCP 网络应用程序开发分为: TCP 客户端程序开发 TCP 服务端程序开发 说明:客户端程序是指运行在用户设备上的程序 服务端程序是指运行在服务器设备上的程序，专门为客户端提供数据服务。 TCP 客户端程序开发流程的介绍步骤说明: 创建客户端套接字对象 和服务端套接字建立连接 发送数据 接收数据 关闭客户端套接字TCP 客户端程序开发导入 socket 模块 import socket创建客户端 socket 对象 socket.socket(AddressFamily, Type)==参数说明:== AddressFamily 表示IP地址类型, 分为TPv4和IPv6 Type 表示传输协议类型==方法说明:== connect((host, port)) 表示和服务端套接字建立连接, host是服务器ip地址，port是应用程序的端口号 send(data) 表示发送数据，data是二进制数据 recv(buffersize) 表示接收数据, buffersize是每次接收数据的长度1234567891011121314151617181920212223import socketif __name__ == '__main__': # 创建tcp客户端套接字 # 1. AF_INET：表示ipv4 # 2. SOCK_STREAM: tcp传输协议 tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 和服务端应用程序建立连接 tcp_client_socket.connect((&quot;192.168.131.62&quot;, 8080)) # 代码执行到此，说明连接建立成功 # 准备发送的数据 send_data = &quot;你好服务端，我是客户端小黑!&quot;.encode(&quot;gbk&quot;) # 发送数据 tcp_client_socket.send(send_data) # 接收数据, 这次接收的数据最大字节数是1024 recv_data = tcp_client_socket.recv(1024) # 返回的直接是服务端程序发送的二进制数据 print(recv_data) # 对数据进行解码 recv_content = recv_data.decode(&quot;gbk&quot;) print(&quot;接收服务端的数据为:&quot;, recv_content) # 关闭套接字 tcp_client_socket.close() b’hello’接收服务端的数据为: hello TCP 服务端程序开发流程的介绍步骤说明: 创建服务端端套接字对象 绑定端口号 设置监听 等待接受客户端的连接请求 接收数据 发送数据 关闭套接字 TCP服务端程序开发导入 socket 模块 import socket创建服务端 socket 对象 socket.socket(AddressFamily, Type)==参数说明:== AddressFamily 表示IP地址类型, 分为TPv4和IPv6 Type 表示传输协议类型==方法说明:== bind((host, port)) 表示绑定端口号, host 是 ip 地址，port 是端口号，ip 地址一般不指定，表示本机的任何一个ip地址都可以。 listen (backlog) 表示设置监听，backlog参数表示最大等待建立连接的个数。 accept() 表示等待接受客户端的连接请求 send(data) 表示发送数据，data 是二进制数据 crecv(buffersize) 表示接收数据, buffersize 是每次接收数据的长度123456789101112131415161718192021222324252627282930313233343536import socketif __name__ == '__main__': # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用，让程序退出端口号立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 给程序绑定端口号 tcp_server_socket.bind((&quot;&quot;, 8989)) # 设置监听 # 128:最大等待建立连接的个数， 提示： 目前是单任务的服务端，同一时刻只能服务与一个客户端，后续使用多任务能够让服务端同时服务与多个客户端， # 不需要让客户端进行等待建立连接 # listen后的这个套接字只负责接收客户端连接请求，不能收发消息，收发消息使用返回的这个新套接字来完成 tcp_server_socket.listen(128) # 等待客户端建立连接的请求, 只有客户端和服务端建立连接成功代码才会解阻塞，代码才能继续往下执行 # 1. 专门和客户端通信的套接字： service_client_socket # 2. 客户端的ip地址和端口号： ip_port service_client_socket, ip_port = tcp_server_socket.accept() # 代码执行到此说明连接建立成功 print(&quot;客户端的ip地址和端口号:&quot;, ip_port) # 接收客户端发送的数据, 这次接收数据的最大字节数是1024 recv_data = service_client_socket.recv(1024) # 获取数据的长度 recv_data_length = len(recv_data) print(&quot;接收数据的长度为:&quot;, recv_data_length) # 对二进制数据进行解码 recv_content = recv_data.decode(&quot;gbk&quot;) print(&quot;接收客户端的数据为:&quot;, recv_content) # 准备发送的数据 send_data = &quot;ok, 问题正在处理中...&quot;.encode(&quot;gbk&quot;) # 发送数据给客户端 service_client_socket.send(send_data) # 关闭服务与客户端的套接字， 终止和客户端通信的服务 service_client_socket.close() # 关闭服务端的套接字, 终止和客户端提供建立连接请求的服务 tcp_server_socket.close() 客户端的ip地址和端口号: (‘172.16.47.209’, 52472)接收数据的长度为: 5接收客户端的数据为: hello 说明:当客户端和服务端建立连接后，服务端程序退出后端口号不会立即释放，需要等待大概1-2分钟。解决办法有两种: 更换服务端端口号 设置端口号复用(推荐大家使用)，也就是说让服务端程序退出后端口号立即释放。设置端口号复用的代码如下:1234# 参数1: 表示当前套接字# 参数2: 设置端口号复用选项# 参数3: 设置端口号复用选项对应的值tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) TCP网络应用程序的注意点 当 TCP 客户端程序想要和 TCP 服务端程序进行通信的时候必须要先建立连接 TCP 客户端程序一般不需要绑定端口号，因为客户端是主动发起建立连接的。 TCP 服务端程序必须绑定端口号，否则客户端找不到这个 TCP 服务端程序。 listen 后的套接字是被动套接字，只负责接收新的客户端的连接请求，不能收发消息。 当 TCP 客户端程序和 TCP 服务端程序连接成功后， TCP 服务器端程序会产生一个新的套接字，收发客户端消息使用该套接字。 关闭 accept 返回的套接字意味着和这个客户端已经通信完毕。 关闭 listen 后的套接字意味着服务端的套接字关闭了，会导致新的客户端不能连接服务端，但是之前已经接成功的客户端还能正常通信。 当客户端的套接字调用 close 后，服务器端的 recv 会解阻塞，返回的数据长度为0，服务端可以通过返回数据的长度来判断客户端是否已+ 经下线，反之服务端关闭套接字，客户端的 recv 也会解阻塞，返回的数据长度也为0。 案例-多任务版TCP服务端程序开发具体实现步骤 编写一个TCP服务端程序，循环等待接受客户端的连接请求 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞 把创建的子线程设置成为守护主线程，防止主线程无法退出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import socketimport threading# 处理客户端的请求操作def handle_client_request(service_client_socket, ip_port): # 循环接收客户端发送的数据 while True: # 接收客户端发送的数据 recv_data = service_client_socket.recv(1024) # 容器类型判断是否有数据可以直接使用if语句进行判断，如果容器类型里面有数据表示条件成立，否则条件失败 # 容器类型: 列表、字典、元组、字符串、set、range、二进制数据 if recv_data: print(recv_data.decode(&quot;gbk&quot;), ip_port) # 回复 service_client_socket.send(&quot;ok，问题正在处理中...&quot;.encode(&quot;gbk&quot;)) else: print(&quot;客户端下线了:&quot;, ip_port) break # 终止和客户端进行通信 service_client_socket.close()if __name__ == '__main__': # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用，让程序退出端口号立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9090)) # 设置监听, listen后的套接字是被动套接字，只负责接收客户端的连接请求 tcp_server_socket.listen(128) # 循环等待接收客户端的连接请求 while True: # 等待接收客户端的连接请求 service_client_socket, ip_port = tcp_server_socket.accept() print(&quot;客户端连接成功:&quot;, ip_port) # 当客户端和服务端建立连接成功以后，需要创建一个子线程，不同子线程负责接收不同客户端的消息 sub_thread = threading.Thread(target=handle_client_request, args=(service_client_socket, ip_port)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程 sub_thread.start() # tcp服务端套接字可以不需要关闭，因为服务端程序需要一直运行 # tcp_server_socket.close() 客户端连接成功: (‘172.16.47.209’, 51528)客户端连接成功: (‘172.16.47.209’, 51714)hello1 (‘172.16.47.209’, 51528)hello2 (‘172.16.47.209’, 51714) socket之send和recv原理剖析1. 认识TCP socket的发送和接收缓冲区当创建一个TCP socket对象的时候会有一个发送缓冲区和一个接收缓冲区，这个发送和接收缓冲区指的就是内存中的一片空间。 2. send原理剖析send是不是直接把数据发给服务端?不是，要想发数据，必须得通过网卡发送数据，应用程序是无法直接通过网卡发送数据的，它需要调用操作系统接口，也就是说，应用程序把发送的数据先写入到发送缓冲区(内存中的一片空间)，再由操作系统控制网卡把发送缓冲区的数据发送给服务端网卡 。 3. recv原理剖析recv是不是直接从客户端接收数据?不是，应用软件是无法直接通过网卡接收数据的，它需要调用操作系统接口，由操作系统通过网卡接收数据，把接收的数据写入到接收缓冲区(内存中的一片空间），应用程序再从接收缓存区获取客户端发送的数据。 send和recv原理剖析图说明: 发送数据是发送到发送缓冲区 接收数据是从接收缓冲区 获取 Python静态Web服务器搭建Python自带静态Web服务器如何搭建Python自带的静态Web服务器搭建Python自带的静态Web服务器使用 python3 -m http.server 端口号, 端口号不指定默认是8000访问搭建的静态Web服务器 IP:端口 返回固定页面数据开发自己的静态Web服务器实现步骤: 编写一个TCP服务端程序1234tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 循环接受客户端的连接请求while True: conn_socket, ip_port = tcp_server_socket.accept() 获取浏览器发送的http请求报文数据1client_request_data = conn_socket.recv(4096) 读取固定页面数据，把页面数据组装成HTTP响应报文数据发送给浏览器。12response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_bodyconn_socket.send(response_data) HTTP响应报文数据发送完成以后，关闭服务于客户端的套接字。 1conn_socket.close() 1234567891011121314151617181920212223242526272829303132333435363738394041import socketif __name__ == '__main__': # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) with open(&quot;static/index.html&quot;, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) # 关闭服务与客户端的套接字 new_socket.close() 根据不同映射返回固定页面数据目前的Web服务器，不管用户访问什么页面，返回的都是固定页面的数据，接下来需要根据用户的请求返回指定页面的数据 返回指定页面数据的实现步骤: 获取用户请求资源的路径12request_list = client_request_conent.split(” ”, maxsplit=2) request_path = request_list[1] 根据请求资源的路径，读取指定文件的数据12with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file:file_data = file.read() 组装指定文件数据的响应报文，发送给浏览器12response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_bodyconn_socket.send(response_data) 判断请求的文件在服务端不存在，组装404状态的响应报文，发送给浏览器1234try: # 打开指定文件,代码省略...except Exception as e: conn_socket.send(404响应报文数据) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import socketdef main(): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close()if __name__ == '__main__': main() 静态Web服务器-多任务版目前的Web服务器，不能支持多用户同时访问，只能一个一个的处理客户端的请求，那么如何开发多任务版的web服务器同时处理 多个客户端的请求? 可以使用多线程，比进程更加节省内存资源。 多任务版web服务器程序的实现步骤: 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。1234while True: conn_socket, ip_port = tcp_server_socket.accept() # 开辟子线程并执行对应的任务 sub_thread = threading.Thread(target=handle_client_request, args=(conn_socket,)) 把创建的子线程设置成为守护主线程，防止主线程无法退出。1234# 开辟子线程并执行对应的任务 sub_thread = threading.Thread(target=handle_client_request, args=(conn_socket,)) sub_thread.setDaemon(True) # 设置守护主线程 sub_thread.start() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import socketimport threading# 处理客户端的请求def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close()# 程序入口函数def main(): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() print(ip_port) # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start()if __name__ == '__main__': main() 静态Web服务器-多任务版静态Web服务器的问题目前的Web服务器，不能支持多用户同时访问，只能一个一个的处理客户端的请求，那么如何开发多任务版的web服务器同时处理 多个客户端的请求? 可以使用多线程，比进程更加节省内存资源。多任务版web服务器程序的实现步骤: 当客户端和服务端建立连接成功，创建子线程，使用子线程专门处理客户端的请求，防止主线程阻塞。1234while True: conn_socket, ip_port = tcp_server_socket.accept() # 开辟子线程并执行对应的任务 sub_thread = threading.Thread(target=handle_client_request, args=(conn_socket,)) 把创建的子线程设置成为守护主线程，防止主线程无法退出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import socketimport threading# 处理客户端的请求def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close()# 程序入口函数def main(): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) while True: # 等待接受客户端的连接请求 new_socket, ip_port = tcp_server_socket.accept() print(ip_port) # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start()if __name__ == '__main__': main() 静态Web服务器-面向对象开发实现步骤: 把提供服务的Web服务器抽象成一个类(HTTPWebServer)1class HttpWebServer(object): 提供Web服务器的初始化方法，在初始化方法里面创建socket对象12def __init__(self): # 初始化服务端套接字，设置监听，代码省略.. 提供一个开启Web服务器的方法，让Web服务器处理客户端请求操作。123456def start(self):while True: service_client_socket, ip_port = self.tcp_server_socket.accept() # 连接建立成功，开辟子线程处理客户端的请求 sub_thread = threading.Thread(target=self.handle_client_request, args=(service_client_socket,)) sub_thread.start() 以面向对象的方式开发静态Web服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import socketimport threading# 定义web服务器类class HttpWebServer(object): def __init__(self): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, 9000)) # 设置监听 tcp_server_socket.listen(128) # 保存创建成功的服务器套接字 self.tcp_server_socket = tcp_server_socket # 处理客户端的请求 定义为静态方法 @staticmethod def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() # 启动web服务器进行工作 def start(self): while True: # 等待接受客户端的连接请求 new_socket, ip_port = self.tcp_server_socket.accept() # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start()# 程序入口函数def main(): # 创建web服务器对象 web_server = HttpWebServer() # 启动web服务器进行工作 web_server.start()if __name__ == '__main__': main() 命令行启动动态绑定端口号 开发命令行启动动态绑定端口号的静态web服务器实现步骤: 获取执行python程序的终端命令行参数1sys.argv 判断参数的类型，设置端口号必须是整型1234if not sys.argv[1].isdigit(): print(&quot;启动命令如下: python3 xxx.py 9090&quot;) returnport = int(sys.argv[1]) 给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号12def __init__(self, port): self.tcp_server_socket.bind((“”, port)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import socketimport threadingimport sys# 定义web服务器类class HttpWebServer(object): def __init__(self, port): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, port)) # 设置监听 tcp_server_socket.listen(128) # 保存创建成功的服务器套接字 self.tcp_server_socket = tcp_server_socket # 处理客户端的请求 @staticmethod def handle_client_request(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() # 启动web服务器进行工作 def start(self): while True: # 等待接受客户端的连接请求 new_socket, ip_port = self.tcp_server_socket.accept() # 当客户端和服务器建立连接程，创建子线程 sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,)) # 设置守护主线程 sub_thread.setDaemon(True) # 启动子线程执行对应的任务 sub_thread.start()# 程序入口函数def main(): print(sys.argv) # 判断命令行参数是否等于2, if len(sys.argv) != 2: print(&quot;执行命令如下: python3 xxx.py 8000&quot;) return # 判断字符串是否都是数字组成 if not sys.argv[1].isdigit(): print(&quot;执行命令如下: python3 xxx.py 8000&quot;) return # 获取终端命令行参数 port = int(sys.argv[1]) # 创建web服务器对象 web_server = HttpWebServer(port) # 启动web服务器进行工作 web_server.start()if __name__ == '__main__': main() Python程序操作MySQL数据库安装pymysql第三方包: 12[root@liruilong ~]# yum -y install pymysql[root@liruilong ~]# ls pymysql的使用: 导入 pymysql 包 : import pymysql 创建连接对象:调用pymysql模块中的connect()函数来创建连接对象conn=connect(参数列表) 参数host：连接的mysql主机，如果本机是’localhost’ 参数port：连接的mysql主机的端口，默认是3306 参数user：连接的用户名 参数password：连接的密码 参数database：数据库的名称 参数charset：通信采用的编码方式，推荐使用utf8连接对象操作说明: 关闭连接 conn.close() 提交数据 conn.commit() 撤销数据 conn.rollback() 获取游标对象：获取游标对象的目标就是要执行sql语句，完成对数据库的增、删、改、查操作。 12# 调用连接对象的cursor()方法获取游标对象 cur =conn.cursor() 游标操作说明: 使用游标执行SQL语句: execute(operation [parameters ]) 执行SQL语句，返回受影响的行数，主要用于执行insert、update、delete、select等语句 获取查询结果集中的一条数据:cur.fetchone()返回一个元组, 如 (1,’张三’) 获取查询结果集中的所有数据: cur.fetchall()返回一个元组,如((1,’张三’),(2,’李四’)) 关闭游标: cur.close(),表示和数据库操作完成 pymysql完成数据的查询操作1234567891011121314151617181920212223242526import pymysql# 创建连接对象conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')# 获取游标对象cursor = conn.cursor()# 查询 SQL 语句sql = &quot;select * from students;&quot;# 执行 SQL 语句 返回值就是 SQL 语句在执行过程中影响的行数row_count = cursor.execute(sql)print(&quot;SQL 语句执行影响的行数%d&quot; % row_count)# 取出结果集中一行数据, 例如:(1, '张三')# print(cursor.fetchone())# 取出结果集中的所有数据, 例如:((1, '张三'), (2, '李四'), (3, '王五'))for line in cursor.fetchall(): print(line)# 关闭游标cursor.close()# 关闭连接conn.close() pymysql完成对数据的增删改1234567891011121314151617181920212223242526272829import pymysql# 创建连接对象conn = pymysql.connect(host='localhost', port=3306, user='root', password='mysql',database='python', charset='utf8')# 获取游标对象cursor = conn.cursor()try: # 添加 SQL 语句 # sql = &quot;insert into students(name) values('刘璐'), ('王美丽');&quot; # 删除 SQ L语句 # sql = &quot;delete from students where id = 5;&quot; # 修改 SQL 语句 sql = &quot;update students set name = '王铁蛋' where id = 6;&quot; # 执行 SQL 语句 row_count = cursor.execute(sql) print(&quot;SQL 语句执行影响的行数%d&quot; % row_count) # 提交数据到数据库 conn.commit()except Exception as e: # 回滚数据， 即撤销刚刚的SQL语句操作 conn.rollback()# 关闭游标cursor.close()# 关闭连接conn.close() conn.commit() 表示将修改操作提交到数据库 conn.rollback() 表示回滚数据 防止SQL注入什么是SQL注入?用户提交带有恶意的数据与SQL语句进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。 ·如何防止SQL注入?SQL语句参数化 SQL语言中的参数使用%s来占位，此处不是python中的字符串格式化操作,将SQL语句中%s占位所需要的参数存在一个列表中，把参数列表传递给execute方法中第二个参数防止SQL注入的示例代码: 123456789101112131415161718192021222324252627282930313233343536373839404142from pymysql import connectdef main(): find_name = input(&quot;请输入物品名称：&quot;) # 创建Connection连接 conn = connect(host='localhost',port=3306,user='root',password='mysql',database='jing_dong',charset='utf8') # 获得Cursor对象 cs1 = conn.cursor() # 非安全的方式 # 输入 ' or 1 = 1 or ' (单引号也要输入) # sql = &quot;select * from goods where name='%s'&quot; % find_name # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql) # # 执行select语句，并返回受影响的行数：查询所有数据 # count = cs1.execute(sql) # 安全的方式 # 构造参数列表 params = [find_name] # 执行select语句，并返回受影响的行数：查询所有数据 count = cs1.execute(&quot;select * from goods where name=%s&quot;, params) # 注意： # 如果要是有多个参数，需要进行参数化 # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可 # %s 不需要带引号 # 打印受影响的行数 print(count) # 获取查询的结果 # result = cs1.fetchone() result = cs1.fetchall() # 打印查询的结果 print(result) # 关闭Cursor对象 cs1.close() # 关闭Connection对象 conn.close()if __name__ == '__main__': main() 事务的介绍事务就是用户定义的一系列执行SQL语句的操作, 这些操作要么完全地执行，要么完全地都不执行， 它是一个不可分割的工作执行单元。 事务的使用场景:在日常生活中，有时我们需要进行银行转账，这个银行转账操作背后就是需要执行多个SQL语句，假如这些SQL执行到一半突然停电了，那么就会导致这个功能只完成了一半，这种情况是不允许出现，要想解决这个问题就需要通过事务来完成。 事务的四大特性 原子性Atomicity:一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性 一致性Consistency:数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在转账过程中系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。） 隔离性Isolation:通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。） 持久性Durability:一旦事务提交，则其所做的修改会永久保存到数据库。 事务的使用： 在使用事务之前，先要确保表的存储引擎是 InnoDB 类型, 只有这个类型才可以使用事务，MySQL数据库中表的存储引擎默认是 InnoDB 类型。 表的存储引擎说明:表的存储引擎就是提供存储数据一种机制，不同表的存储引擎提供不同的存储机制。 开启事务后执行修改命令，变更数据会保存到MySQL服务端的缓存文件中，而不维护到物理表中 MySQL数据库默认采用自动提交(autocommit)模式，如果没有显示的开启一个事务,那么每条sql语句都会被当作一个事务执行提交的操作当设置autocommit=0就是取消了自动提交事务模式，直到显示的执行commit和rollback表示该事务结束。 set autocommit = 0 表示取消自动提交事务模式，需要手动执行commit完成事务的提交 索引索引的介绍索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。 应用场景:当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。 索引的使用 查看表中已有索引: show index from 表名; 主键列会自动创建索引 索引名不指定，默认使用字段名验证索引性能操作：123456789101112-- 开启运行时间监测：set profiling=1;-- 查找第1万条数据ha-99999select * from test_index where title='ha-99999';-- 查看执行的时间：show profiles;-- 给title字段创建索引：alter table test_index add index (title);-- 再次执行查询语句select * from test_index where title='ha-99999';-- 再次查看执行的时间show profiles; 联合索引联合索引又叫复合索引，即一个索引覆盖表中两个或者多个字段，一般用在多个字段一起查询的时候。12345678910-- 创建teacher表create table teacher( id int not null primary key auto_increment, name varchar(10), age int);-- 创建联合索引alter table teacher add index (name,age); 联合索引的好处:减少磁盘空间开销，因为每创建一个索引，其实就是创建了一个索引文件，那么会增加磁盘空间的开销。 联合索引的最左原则在使用联合索引的时候，我们要遵守一个最左原则,即index(name,age)支持 name 、name 和 age 组合查询,而不支持单独 age 查询，因为没有用到创建的联合索引。最左原则示例: 12345-- 下面的查询使用到了联合索引select * from stu where name='张三' -- 这里使用了联合索引的name部分select * from stu where name='李四' and age=10 -- 这里完整的使用联合索引，包括 name 和 age 部分 -- 下面的查询没有使用到联合索引select * from stu where age=10 -- 因为联合索引里面没有这个组合，只有 name | name age 这两种组合 在使用联合索引的查询数据时候一定要保证联合索引的最左侧字段出现在查询条件里面，否则联合索引失效 MySQL中索引的优点和缺点和使用原则 优点：. ==加快数据的查询速度== 缺点：. ==创建索引会耗费时间和占用磁盘空间，并且随着数据量的增加所耗费的时间也会增加== 使用原则： 通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。 对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引， 数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效+ 果。 在一字段上相同值比较多不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。 闭包&amp;装饰器闭包的介绍:我们前面已经学过了函数，我们知道当函数调用完，函数内定义的变量都销毁了，但是我们有时候需要保存函数内的这个变量，每次在这个变量的基础上完成一些列的操作，比如: 每次在这个变量的基础上和其它数字进行求和计算，那怎么办呢?我们就可以通过咱们今天学习的闭包来解决这个需求。闭包的定义:在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。 闭包的构成条件通过闭包的定义，我们可以得知闭包的形成条件: 在函数嵌套(函数里面再定义函数)的前提下 内部函数使用了外部函数的变量(还包括外部函数的参数) 外部函数返回了内部函数123456789101112131415# 定义一个外部函数def func_out(num1): # 定义一个内部函数 def func_inner(num2): # 内部函数使用了外部函数的变量(num1) result = num1 + num2 print(&quot;结果是:&quot;, result) # 外部函数返回了内部函数，这里返回的内部函数就是闭包 return func_inner# 创建闭包实例 f = func_out(1)# 执行闭包f(2)f(3) 结果是: 3结果是: 4 闭包执行结果的说明:通过上面的输出结果可以看出闭包保存了外部函数内的变量num1，每次执行闭包都是在num1 = 1 基础上进行计算。 闭包的作用闭包可以保存外部函数内的变量，不会随着外部函数调用完而销毁。注意点:由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。 闭包的使用案例 需求: 根据配置信息使用闭包实现不同人的对话信息，例如对话:张三: 到北京了吗? 李四: 已经到了，放心吧。 定义外部函数接收不同的配置信息参数，参数是人名 定义内部函数接收对话信息参数 在内部函数里面把配置信息和对话信息进行拼接输出功能代码的实现12345678910111213141516# 外部函数def config_name(name): # 内部函数 def say_info(info): print(name + &quot;: &quot; + info) return say_infotom = config_name(&quot;Tom&quot;)tom(&quot;你好!&quot;)tom(&quot;你好, 在吗?&quot;)jerry = config_name(&quot;jerry&quot;)jerry(&quot;不在, 不和玩!&quot;) 运行结果:Tom: 你好!Tom: 你好, 在吗?jerry: 不在, 不和玩! 闭包案例说明:闭包还可以提高代码的可重用性，不需要再手动定义额外的功能函数。 修改闭包内使用的外部变量修改闭包内使用的外部变量的错误示例: 12345678910111213141516171819202122# 定义一个外部函数def func_out(num1): # 定义一个内部函数 def func_inner(num2): # 这里本意想要修改外部num1的值，实际上是在内部函数定义了一个局部变量num1 num1 = 10 # 内部函数使用了外部函数的变量(num1) result = num1 + num2 print(&quot;结果是:&quot;, result) print(num1) func_inner(1) print(num1) # 外部函数返回了内部函数，这里返回的内部函数就是闭包 return func_inner# 创建闭包实例f = func_out(1)# 执行闭包f(2) 装饰器 装饰器的定义:就是给已有函数增加额外功能的函数，它本质上就是一个闭包函数。类似于AOP环绕通知的逆向应用装饰器的功能特点: 不修改已有函数的源代码 不修改已有函数的调用方式 给已有函数增加额外的功能 12345678910111213141516171819202122# 添加一个登录验证的功能def check(fn): def inner(): print(&quot;请先登录....&quot;) fn() return innerdef comment(): print(&quot;发表评论&quot;)# 使用装饰器来装饰函数comment = check(comment)comment()# 装饰器的基本雏形# def decorator(fn): # fn:目标函数.# def inner():# '''执行函数之前'''# fn() # 执行被装饰的函数# '''执行函数之后'''# return inner 执行结果:请先登录….发表评论 闭包函数有且只有一个参数，必须是函数类型，这样定义的函数才是装饰器。 写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展。 装饰器的语法糖写法如果有多个函数都需要添加登录验证的功能，每次都需要编写func = check(func)这样代码对已有函数进行装饰，这种做法还是比较麻烦。 Python给提供了一个装饰函数更加简单的写法，那就是语法糖，语法糖的书写格式是: @装饰器名字，通过语法糖的方式也可以完成对已有函数的装饰. 1234567891011121314# 添加一个登录验证的功能def check(fn): print(&quot;装饰器函数执行了&quot;) def inner(): print(&quot;请先登录....&quot;) fn() return inner# 使用语法糖方式来装饰函数@checkdef comment(): print(&quot;发表评论&quot;)comment() 装饰器的使用装饰器的使用场景 函数执行时间的统计 输出日志信息 装饰器实现已有函数执行时间的统计 123456789101112131415161718import time# 装饰器函数def get_time(func): def inner(): begin = time.time() func() end = time.time() print(&quot;函数执行花费%f&quot; % (end-begin)) return inner@get_timedef func1(): for i in range(100000): print(i)func1() …9999599996999979999899999函数执行花费0.329066 通用装饰器的使用装饰带有参数的函数123456789101112131415# 添加输出日志的功能def logging(fn): def inner(num1, num2): print(&quot;--正在努力计算--&quot;) fn(num1, num2) return inner# 使用装饰器装饰函数@loggingdef sum_num(a, b): result = a + b print(result)sum_num(1, 2) –正在努力计算–3 装饰带有返回值的函数123456789101112131415161718# 添加输出日志的功能def logging(fn): def inner(num1, num2): print(&quot;--正在努力计算--&quot;) result = fn(num1, num2) return result return inner# 使用装饰器装饰函数@loggingdef sum_num(a, b): result = a + b return resultresult = sum_num(1, 2)print(result) –正在努力计算–3 装饰带有不定长参数的函数12345678910111213141516171819202122# 添加输出日志的功能def logging(fn): def inner(*args, **kwargs): print(&quot;--正在努力计算--&quot;) fn(*args, **kwargs) return inner# 使用语法糖装饰函数@loggingdef sum_num(*args, **kwargs): result = 0 for value in args: result += value for value in kwargs.values(): result += value print(result)sum_num(1, 2, a=10) –正在努力计算–13 通用装饰器12345678910111213141516171819202122232425262728293031# 添加输出日志的功能def logging(fn): def inner(*args, **kwargs): print(&quot;--正在努力计算--&quot;) result = fn(*args, **kwargs) return result return inner# 使用语法糖装饰函数@loggingdef sum_num(*args, **kwargs): result = 0 for value in args: result += value for value in kwargs.values(): result += value return result@loggingdef subtraction(a, b): result = a - b print(result)result = sum_num(1, 2, a=10)print(result)subtraction(4, 2) –正在努力计算–13–正在努力计算–2 多个装饰器的使用多个装饰器的装饰过程是: 离函数最近的装饰器先装饰，然后外面的装饰器再进行装饰，由内到外的装饰过程 1234567891011121314151617181920212223242526def make_div(func): &quot;&quot;&quot;对被装饰的函数的返回值 div标签&quot;&quot;&quot; def inner(*args, **kwargs): return &quot;&lt;div&gt;&quot; + func() + &quot;&lt;/div&gt;&quot; return innerdef make_p(func): &quot;&quot;&quot;对被装饰的函数的返回值 p标签&quot;&quot;&quot; def inner(*args, **kwargs): return &quot;&lt;p&gt;&quot; + func() + &quot;&lt;/p&gt;&quot; return inner# 装饰过程: # 1 content = make_p(content) # 2 content = make_div(content)# content = make_div(make_p(content))@make_div@make_pdef content(): return &quot;人生苦短&quot;result = content()print(result) 带有参数的装饰器带有参数的装饰器就是使用装饰器装饰函数的时候可以传入指定参数，语法格式: @装饰器(参数,...)错误写法:==装饰器只能接收一个参数，并且还是函数类型。== 123456789101112131415161718def decorator(fn, flag): def inner(num1, num2): if flag == &quot;+&quot;: print(&quot;--正在努力加法计算--&quot;) elif flag == &quot;-&quot;: print(&quot;--正在努力减法计算--&quot;) result = fn(num1, num2) return result return inner@decorator('+')def add(a, b): result = a + b return resultresult = add(1, 3)print(result) Traceback (most recent call last): File “/home/python/Desktop/test/hho.py”, line 12, in @decorator(‘+’)TypeError: decorator() missing 1 required positional argument: ‘flag’ 正确写法:==在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。==在装饰器外面再包裹上一个函数，让最外面的函数接收参数，返回的是装饰器，因为@符号后面必须是装饰器实例。 12345678910111213141516171819202122232425262728293031323334# 添加输出日志的功能def logging(flag): def decorator(fn): def inner(num1, num2): if flag == &quot;+&quot;: print(&quot;--正在努力加法计算--&quot;) elif flag == &quot;-&quot;: print(&quot;--正在努力减法计算--&quot;) result = fn(num1, num2) return result return inner # 返回装饰器 return decorator# 使用装饰器装饰函数@logging(&quot;+&quot;)def add(a, b): result = a + b return result@logging(&quot;-&quot;)def sub(a, b): result = a - b return resultresult = add(1, 2)print(result)result = sub(1, 2)print(result) 类装饰器的使用装饰器还有一种特殊的用法就是类装饰器，就是通过定义一个类来装饰函数。 123456789101112131415class Check(object): def __init__(self, fn): # 初始化操作在此完成 self.__fn = fn # 实现__call__方法，表示对象是一个可调用对象，可以像调用函数一样进行调用。 def __call__(self, *args, **kwargs): # 添加装饰功能 print(&quot;请先登陆...&quot;) self.__fn()@Checkdef comment(): print(&quot;发表评论&quot;)comment() @Check 等价于 comment = Check(comment), 所以需要提供一个init方法，并多增加一个fn参数。 要想类的实例对象能够像函数一样调用，需要在类里面使用call方法，把类的实例变成可调用对象(callable)，也就是说可以像调用函数一样进行调用。在call方法里进行对fn函数的装饰，可以添加额外的功能。 执行结果:请先登陆…发表评论 mini-web框架web框架概述web框架和web服务器的关系介绍： 前面已经学习过web服务器, 我们知道web服务器主要是接收用户的http请求,根据用户的请求返回不同的资源数据，但是之前我们开发的是静态web服务器，返回的都是静态资源数据，假如我们想要web服务器返回动态资源那么该如何进行处理呢？ 使用web框架专门负责处理用户的动态资源请求，这个web框架其实就是一个为web服务器提供服务的应用程序，简称web框架。 关系说明: web服务器接收浏览器发起的请求，如果是动态资源请求找web框架来处理 web框架负责处理浏览器的动态资源请求，把处理的结果发生给web服务器 web服务器再把响应结果发生给浏览器 静态资源:不需要经常变化的资源，这种资源web服务器可以提前准备好，比如: png/jpg/css/js等文件。 动态资源:和静态资源相反, 这种资源会经常变化，比如: 我们在京东浏览商品时经常会根据条件进行筛选，选择不同条件, 浏览的商品就不同，这种资源web服务器无法提前准备好，需要web框架来帮web服务器进行准备，在这里web服务器可以把.html的资源请求认为是动态资源请求交由web框架进行处理。 WSGI协议:Web服务器网关接口(Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。它是web服务器和web框架之间进行协同工作的一个规则，WSGI协议规定web服务器把动态资源的请求信息传给web框架处理，web框架把处理好的结果返回给web服务器。 框架程序开发框架职责介绍 接收web服务器的动态资源请求，给web服务器提供处理动态资源请求的服务。动态资源判断根据请求资源路径的后缀名进行判断 如果请求资源路径的后缀名是.html则是动态资源请求, 让web框架程序进行处理。 否则是静态资源请求，让web服务器程序进行处理。 web服务器程序(web.py)代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import socketimport threadingimport sysimport framework# 定义web服务器类class HttpWebServer(object): def __init__(self, port): # 创建tcp服务端套接字 tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 设置端口号复用, 程序退出端口立即释放 tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True) # 绑定端口号 tcp_server_socket.bind((&quot;&quot;, port)) # 设置监听 tcp_server_socket.listen(128) self.tcp_server_socket = tcp_server_socket # 处理客户的请求,申明静态方法 @staticmethod def handle_client_quest(new_socket): # 代码执行到此，说明连接建立成功 recv_client_data = new_socket.recv(4096) if len(recv_client_data) == 0: print(&quot;关闭浏览器了&quot;) # 关闭服务与客户端的套接字 new_socket.close() return # 对二进制数据进行解码 recv_client_content = recv_client_data.decode(&quot;utf-8&quot;) print(recv_client_content) # 根据指定字符串进行分割， 最大分割次数指定2 request_list = recv_client_content.split(&quot; &quot;, maxsplit=2) # 获取请求资源路径 request_path = request_list[1] print(request_path) # 判断请求的是否是根目录，如果条件成立，指定首页数据返回 if request_path == &quot;/&quot;: request_path = &quot;/index.html&quot; # 判断是否是动态资源请求 if request_path.endswith(&quot;.html&quot;): &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot; # 字典存储用户的请求信息 env = { &quot;request_path&quot;: request_path } # 获取处理结果 status, headers, response_body = framework.handle_request(env) # 使用框架处理的数据拼接响应报文 # 响应行 response_line = &quot;HTTP/1.1 %s\\r\\n&quot; % status # 响应头 response_header = &quot;&quot; # 遍历头部信息 for header in headers: # 拼接多个响应头 response_header += &quot;%s: %s\\r\\n&quot; % header response_data = (response_line + response_header + &quot;\\r\\n&quot; + response_body).encode(&quot;utf-8&quot;) # 发送数据 new_socket.send(response_data) # 关闭socket new_socket.close() else: &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot; try: # 动态打开指定文件 with open(&quot;static&quot; + request_path, &quot;rb&quot;) as file: # 读取文件数据 file_data = file.read() except Exception as e: # 请求资源不存在，返回404数据 # 响应行 response_line = &quot;HTTP/1.1 404 Not Found\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; with open(&quot;static/error.html&quot;, &quot;rb&quot;) as file: file_data = file.read() # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) else: # 响应行 response_line = &quot;HTTP/1.1 200 OK\\r\\n&quot; # 响应头 response_header = &quot;Server: PWS1.0\\r\\n&quot; # 响应体 response_body = file_data # 拼接响应报文 response_data = (response_line + response_header + &quot;\\r\\n&quot;).encode(&quot;utf-8&quot;) + response_body # 发送数据 new_socket.send(response_data) finally: # 关闭服务与客户端的套接字 new_socket.close() def start(self): while True: # 等待接受客户端的连接请求 new_socket, ip_port = self.tcp_server_socket.accept() sub_thread = threading.Thread(target=self.handle_client_quest, args=(new_socket,)) # 设置守护线程 sub_thread.setDaemon(True) sub_thread.start()# 程序入口函数def main(): # 获取命令行参数判断长度 if len(sys.argv) != 2: print(&quot;执行命令如下: python3 xxx.py 9000&quot;) return # 判断端口号是否是数字 if not sys.argv[1].isdigit(): print(&quot;执行命令如下: python3 xxx.py 9000&quot;) return # 需要转成int类型 port = int(sys.argv[1]) # 创建web服务器 web_server = HttpWebServer(port) # 启动web服务器 web_server.start()if __name__ == '__main__': main() 处理客户端的动态资源请求 创建web框架程序 接收web服务器的动态资源请求 处理web服务器的动态资源请求并把处理结果返回给web服务器 web服务器把处理结果组装成响应报文发送给浏览器 web框架程序(framework.py)代码: 123456789101112131415161718192021222324252627282930313233343536373839404142&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 获取首页数据def index(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 处理后的数据 data = time.ctime() return status, response_header, data# 没有找到动态资源def not_found(): # 响应状态 status = &quot;404 Not Found&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 处理后的数据 data = &quot;not found&quot; return status, response_header, data# 处理动态资源请求def handle_request(env): # 获取动态请求资源路径 request_path = env[&quot;request_path&quot;] print(&quot;接收到的动态资源请求:&quot;, request_path) if request_path == &quot;/index.html&quot;: # 获取首页数据 result = index() return result else: # 没有找到动态资源 result = not_found() return result 模板替换功能开发,使用模拟数据替换模板变量framework.py示例代码: 1234567891011121314151617# 获取首页数据def index(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 1. 打开模板文件，读取数据 with open(&quot;template/index.html&quot;, &quot;r&quot;) as file: file_data = file.read() # 处理后的数据, 从数据库查询 data = time.ctime() # 2. 替换模板文件中的模板遍历 result = file_data.replace(&quot;{%content%}&quot;, data) return status, response_header, result 路由列表功能开发 什么是路由？路由就是请求的URL到处理函数的映射，也就是说提前把请求的URL和处理函数关联好。 路由列表:这么多的路由如何管理呢， 可以使用一个路由列表进行管理，通过路由列表保存每一个路由。 在路由列表添加路由,根据用户请求遍历路由列表处理用户请求1234567891011121314151617181920# 定义路由列表route_list = [ (&quot;/index.html&quot;, index), (&quot;/center.html&quot;, center)]# 处理动态资源请求def handle_request(env): # 获取动态请求资源路径 request_path = env[&quot;request_path&quot;] print(&quot;接收到的动态资源请求:&quot;, request_path) # 遍历路由列表，选择执行的函数 for path, func in route_list: if request_path == path: result = func() return result else: # 没有找到动态资源 result = not_found() return result 装饰器方式的添加路由前面我们已经实现了路由列表，但是每次添加路由都需要手动添加来完成，接下来我们想要完成路由的自动添加，可以通过装饰器来实现，在使用装饰器对处理函数进行装饰的时候我们需要知道装饰的函数和那个请求路径进行关联，也就是说装饰器需要接收一个url参数，这样我们定义的装饰器是一个带有参数的装饰器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&quot;&quot;&quot;miniweb框架，负责处理动态资源请求&quot;&quot;&quot;import time# 定义路由列表route_list = []# 定义带有参数的装饰器def route(path): # 装饰器 def decorator(func): # 当执行装饰器装饰指定函数的时候，把路径和函数添加到路由列表 route_list.append((path, func)) def inner(): # 执行指定函数 return func() return inner # 返回装饰器 return decorator# 获取首页数据@route(&quot;/index.html&quot;)def index(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 打开模板文件，读取数据 with open(&quot;template/index.html&quot;, &quot;r&quot;) as file: file_data = file.read() # 处理后的数据, 从数据库查询 data = time.ctime() # 替换模板文件中的模板遍历 result = file_data.replace(&quot;{%content%}&quot;, data) return status, response_header, result# 获取个人中心数据@route(&quot;/center.html&quot;)def center(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 打开模板文件，读取数据 with open(&quot;template/center.html&quot;, &quot;r&quot;) as file: file_data = file.read() # 处理后的数据, 从数据库查询 data = time.ctime() # 替换模板文件中的模板遍历 result = file_data.replace(&quot;{%content%}&quot;, data) return status, response_header, result# 没有找到动态资源def not_found(): # 响应状态 status = &quot;404 Not Found&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 处理后的数据 data = &quot;not found&quot; return status, response_header, data# 处理动态资源请求def handle_request(env): # 获取动态请求资源路径 request_path = env[&quot;request_path&quot;] print(&quot;接收到的动态资源请求:&quot;, request_path) # 遍历路由列表，选择执行的函数 for path, func in route_list: if request_path == path: result = func() return result else: # 没有找到动态资源 result = not_found() return result 显示股票信息页面的开发数据准备123456-- 创建数据库create database stock_db charset=utf8;-- 切换数据库use stock_db;-- 执行sql文件source stock_db.sql; 根据sql语句查询股票信息123456789101112131415161718192021222324252627282930# 获取首页数据@route(&quot;/index.html&quot;)def index(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 打开模板文件，读取数据 with open(&quot;template/index.html&quot;, &quot;r&quot;) as file: file_data = file.read() # 处理后的数据, 从数据库查询 conn = pymysql.connect(host=&quot;localhost&quot;, port=3306, user=&quot;root&quot;, password=&quot;mysql&quot;, database=&quot;stock_db&quot;, charset=&quot;utf8&quot;) # 获取游标 cursor = conn.cursor() # 查询sql语句 sql = &quot;select * from info;&quot; # 执行sql cursor.execute(sql) # 获取结果集 result = cursor.fetchall() print(result) 使用查询数据替换模板变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 获取首页数据@route(&quot;/index.html&quot;)def index(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 打开模板文件，读取数据 with open(&quot;template/index.html&quot;, &quot;r&quot;) as file: file_data = file.read() # 处理后的数据, 从数据库查询 conn = pymysql.connect(host=&quot;localhost&quot;, port=3306, user=&quot;root&quot;, password=&quot;mysql&quot;, database=&quot;stock_db&quot;, charset=&quot;utf8&quot;) # 获取游标 cursor = conn.cursor() # 查询sql语句 sql = &quot;select * from info;&quot; # 执行sql cursor.execute(sql) # 获取结果集 result = cursor.fetchall() print(result) data = &quot;&quot; for row in result: data += '''&lt;tr&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;%s&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;toAdd&quot; name=&quot;toAdd&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt; &lt;/tr&gt;''' % row # 替换模板文件中的模板遍历 result = file_data.replace(&quot;{%content%}&quot;, data) return status, response_header, result 个人中心数据接口的开发根据sql语句查询个人中心数据.将个人中心数据转成json字符串并返回12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 个人中心数据接口开发@route(&quot;/center_data.html&quot;)def center_data(): # 响应状态 status = &quot;200 OK&quot;; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;), (&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;)] conn = pymysql.connect(host=&quot;localhost&quot;, port=3306, user=&quot;root&quot;, password=&quot;mysql&quot;, database=&quot;stock_db&quot;, charset=&quot;utf8&quot;) # 获取游标 cursor = conn.cursor() # 查询sql语句 sql = '''select i.code, i.short, i.chg, i.turnover, i.price, i.highs, f.note_info from info as i inner join focus as f on i.id = f.info_id;''' # 执行sql cursor.execute(sql) # 获取结果集 result = cursor.fetchall() # 关闭游标 cursor.close() # 关闭数据库连接 conn.close() print(result) # 个人中心数据列表 center_data_list = list() # 遍历每一行数据转成字典 for row in result: # 创建空的字典 center_dict = dict() center_dict[&quot;code&quot;] = row[0] center_dict[&quot;short&quot;] = row[1] center_dict[&quot;chg&quot;] = row[2] center_dict[&quot;turnover&quot;] = row[3] center_dict[&quot;price&quot;] = str(row[4]) center_dict[&quot;highs&quot;] = str(row[5]) center_dict[&quot;note_info&quot;] = row[6] # 添加每个字典信息 center_data_list.append(center_dict) # 把列表字典转成json字符串, 并在控制台显示 json_str = json.dumps(center_data_list,ensure_ascii=False) print(json_str) return status, response_header, json_str 代码说明: json.dumps函数把字典转成json字符串:函数的第一个参数表示要把指定对象转成json字符串,参数的第二个参数ensure_ascii=False表示不使用ascii编码，可以在控制台显示中文。 响应头添加Content-Type表示指定数据的编码格式 ajax请求数据渲染个人中心页面12345678910111213141516# 获取个人中心数据@route(&quot;/center.html&quot;)def center(): # 响应状态 status = &quot;200 OK&quot; # 响应头 response_header = [(&quot;Server&quot;, &quot;PWS2.0&quot;)] # 打开模板文件，读取数据 with open(&quot;template/center.html&quot;, &quot;r&quot;) as file: file_data = file.read() # 替换模板文件中的模板遍历 result = file_data.replace(&quot;{%content%}&quot;, &quot;&quot;) return status, response_header, result 根据用户请求返回个人中心空模板文件数据,在个人中心模板文件添加ajax请求获取个人中心数据 123456789101112131415161718192021222324// 发送ajax请求获取个人中心页面数据$.get(&quot;center_data.html&quot;, function (data) { var data_array = data; // 获取table标签对象 var $table = $(&quot;.table&quot;) for(var i = 0; i &lt; data_array.length; i++){ // 获取每一条对象 var center_obj = data_array[i]; var row_html = '&lt;tr&gt;' + '&lt;td&gt;'+ center_obj.code +'&lt;/td&gt;' + '&lt;td&gt;'+ center_obj.short +'&lt;/td&gt;' + '&lt;td&gt;'+ center_obj.chg +'&lt;/td&gt;' + '&lt;td&gt;'+ center_obj.turnover +'&lt;/td&gt;' + '&lt;td&gt;'+ center_obj.price +'&lt;/td&gt;' + '&lt;td&gt;'+ center_obj.highs +'&lt;/td&gt;' + '&lt;td&gt;'+ center_obj.note_info +'&lt;/td&gt;' + '&lt;td&gt;&lt;a type=&quot;button&quot; class=&quot;btn btn-default btn-xs&quot; href=&quot;/update/000007.html&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 修改 &lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;button&quot; value=&quot;删除&quot; id=&quot;toDel&quot; name=&quot;toDel&quot; systemidvaule=&quot;000007&quot;&gt;&lt;/td&gt;&lt;/tr&gt;'; // 为table标签添加每一行组装的html数据 $table.append(row_html); }}, &quot;json&quot;); logging日志logging日志的介绍在现实生活中，记录日志非常重要，比如:银行转账时会有转账记录；飞机飞行过程中，会有个黑盒子（飞行数据记录器）记录着飞机的飞行过程，那在咱们python程序中想要记录程序在运行时所产生的日志信息，怎么做呢?可以使用 logging 这个包来完成记录程序日志信息的目的是: 可以很方便的了解程序的运行情况 可以分析用户的操作行为、喜好等信息 方便开发人员检查bug==logging日志级别介绍==日志等级可以分为5个，从低到高分别是:DEBUG,INFO,WARNING,ERROR,CRITICAL日志等级说明: DEBUG：程序调试bug时使用 INFO：程序正常运行时使用 WARNING：程序未按预期运行时使用，但并不是错误，如:用户登录密码错误 ERROR：程序出错误时使用，如:IO操作失败 CRITICAL：特别严重的问题，导致程序不能再继续运行时使用，如:磁盘空间为空，一般很少使用默认的是WARNING等级，当在WARNING或WARNING之上等级的才记录日志信息。日志等级从低到高的顺序是: DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICALlogging日志的使用在 logging 包中记录日志的方式有两种: 输出到控制台 保存到日志文件日志信息输出到控制台的示例代码:1234567import logginglogging.debug('这是一个debug级别的日志信息')logging.info('这是一个info级别的日志信息')logging.warning('这是一个warning级别的日志信息')logging.error('这是一个error级别的日志信息')logging.critical('这是一个critical级别的日志信息') 日志信息只显示了大于等于WARNING级别的日志，这说明·默认的日志级别设置为WARNING·logging日志等级和输出格式的设置:1234567891011import logging# 设置日志等级和输出日志格式logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')logging.debug('这是一个debug级别的日志信息')logging.info('这是一个info级别的日志信息')logging.warning('这是一个warning级别的日志信息')logging.error('这是一个error级别的日志信息')logging.critical('这是一个critical级别的日志信息') level 表示设置的日志等级 format 表示日志的输出格式, 参数说明: %(levelname)s: 打印日志级别名称 %(filename)s: 打印当前执行程序名 %(lineno)d: 打印日志的当前行号 %(asctime)s: 打印日志的时间 %(message)s: 打印日志信息日志信息保存到日志文件的示例代码: 123456789101112import logginglogging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s', filename=&quot;log.txt&quot;, filemode=&quot;w&quot;)logging.debug('这是一个debug级别的日志信息')logging.info('这是一个info级别的日志信息')logging.warning('这是一个warning级别的日志信息')logging.error('这是一个error级别的日志信息')logging.critical('这是一个critical级别的日志信息') logging日志在mini-web项目中应用web.py 程序使用logging日志示例:1.程序入口模块设置logging日志的设置 1234567891011import socket import threading import sys import framework import logging # logging日志的配置 logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s', filename=&quot;log.txt&quot;, filemode=&quot;w&quot;) 2.INFO级别的日志输出，示例代码: 123456789# 判断是否是动态资源请求 if request_path.endswith(&quot;.html&quot;): &quot;&quot;&quot;这里是动态资源请求，把请求信息交给框架处理&quot;&quot;&quot; logging.info(&quot;动态资源请求:&quot; + request_path) ... else: &quot;&quot;&quot;这里是静态资源请求&quot;&quot;&quot; logging.info(&quot;静态资源请求:&quot; + request_path) ... 3.WARNING级别的日志输出，示例代码: 1234567891011# 获取命令行参数判断长度 if len(sys.argv) != 2: print(&quot;执行命令如下: python3 xxx.py 9000&quot;) logging.warning(&quot;用户在命令行启动程序参数个数不正确!&quot;) return # 判断端口号是否是数字 if not sys.argv[1].isdigit(): print(&quot;执行命令如下: python3 xxx.py 9000&quot;) logging.warning(&quot;用户在命令行启动程序参数不是数字字符串!&quot;) return framework.py 程序使用logging日志示例:4.ERROR级别的日志输出，示例代码: 123456789101112131415# 处理动态资源请求def handle_request(env): # 获取动态请求资源路径 request_path = env[&quot;request_path&quot;] print(&quot;接收到的动态资源请求:&quot;, request_path) # 遍历路由列表，选择执行的函数 for path, func in route_list: if request_path == path: result = func() return result else: logging.error(&quot;没有设置相应的路由:&quot; + request_path) # 没有找到动态资源 result = not_found() return result ==logging日志配置信息在程序入口模块设置一次，整个程序都可以生效==。logging.basicConfig 表示 logging 日志配置操作","link":"/2021/04/19/Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Openstack","slug":"Openstack","link":"/tags/Openstack/"},{"name":"云计算管理平台","slug":"云计算管理平台","link":"/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/"},{"name":"K8S","slug":"K8S","link":"/tags/K8S/"},{"name":"容器管理","slug":"容器管理","link":"/tags/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"},{"name":"kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"},{"name":"程序人生","slug":"程序人生","link":"/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"北漂","slug":"北漂","link":"/tags/%E5%8C%97%E6%BC%82/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"系统架构","slug":"系统架构","link":"/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"RHCAS","slug":"RHCAS","link":"/tags/RHCAS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"网管","slug":"网管","link":"/tags/%E7%BD%91%E7%AE%A1/"},{"name":"企业级网络架构","slug":"企业级网络架构","link":"/tags/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Python","slug":"Python","link":"/tags/Python/"}],"categories":[{"name":"云计算管理平台","slug":"云计算管理平台","link":"/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/"},{"name":"容器","slug":"容器","link":"/categories/%E5%AE%B9%E5%99%A8/"},{"name":"程序人生","slug":"程序人生","link":"/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"证书考试笔记","slug":"证书考试笔记","link":"/categories/%E8%AF%81%E4%B9%A6%E8%80%83%E8%AF%95%E7%AC%94%E8%AE%B0/"},{"name":"网络架构","slug":"网络架构","link":"/categories/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"},{"name":"Spring Boot 学习笔记","slug":"Spring-Boot-学习笔记","link":"/categories/Spring-Boot-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","link":"/categories/Python/"}]}