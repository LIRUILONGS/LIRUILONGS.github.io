{"pages":[{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"关于 MVVM和MVC的一些总结","text":"爱自己，是终生浪漫的开始 ——王尔德 我的需求： 晚上练完车之后,之前参考我毕设的一个小伙伴要答辩，问了我一个问题，结果问的一下不知道怎么回答….以下是我回答他问题的答案：所以在回答完他之后，赶快整理一波.. 我需要解决的问题： MVVM到底是个什么东东，和前后端有没有关系，它和MVC区别是啥，有啥优势。 我是这样做的： 百度寻找，找了一些关于MVVM论文，博客，梳理出自己的答案。 嗯，资源比较零散，准确性有待考量，**所以不对的地方请小伙伴指出来**。 爱自己，是终生浪漫的开始 ——王尔德 对于MVC想来小伙伴是不陌生的，但是网上的资源各抒己见….我也整的晕头转向的，可能有前(后)端,有胖(瘦)客户端框架应用，具体还有细微的差异。 If you put ten software architects into a room and have them discuss what the Model-View-Controller pattern is, you will end up with twelve different opinions. –Josh Smith[^3]如果你把10个软件架构师放在一个房间里，让他们讨论模型-视图-控制器模式是什么，你最终会得到12种不同的观点。 我们这里讨论的MVC和MVVM是以BS架构为基础的java Web中的应用，因为博主只接触了这方面的，关于网上提到的IOS和一些客户端框架，没有接触过。本博客也不涉及。所以如果听都没听过java Web的,或者没了解过 Web框架的小伙伴个人感觉这篇博客不太适合，不太建议继续读下去。 我们先看看MVVM吧！嘻嘻 ^ _ ^ MVVM 名词解释： MVVM是Model-View-ViewModel的简写。它本质上就是MVC的改进版。MVVM 就是将其中的View的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事ViewModel已经帮我们做了，它可以取出 Model 的数据同时帮忙处理View中由于需要展示内容而涉及的业务逻辑。MVVM（Model-View-ViewModel）框架的由来便是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。^1 MVVMupright=1.5 MVVM（Model–view–viewmodel）是一种软件架构模式。 MVVM有助于将图形用户界面的开发与business logic(业务逻辑)或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集(Model)的后端逻辑的访问。 ^2 MVVM 的发展历程MVVM是马丁·福勒的PM（Presentation Model）设计模式的变体。MVVM以相同的方式抽象出视图的状态和行为， 但PM以不依赖于特定用户界面平台的方式抽象出视图（建立了视图模型）。 MVVM和PM都来自MVC模式。 MVVM由微软架构师Ken Cooper和Ted Peters开发，通过利用WPF（微软.NET图形系统）和Silverlight（WPF的互联网应用衍生品）的特性来简化用户界面的事件驱动程式设计。 微软的WPF和Silverlight架构师之一John Gossman于2005年在他的博客上发表了MVVM。 MVVM也被称为model-view-binder，特别是在不涉及.NET平台的实现中。ZK（Java写的一个Web应用框架）和KnockoutJS（一个JavaScript库）使用model-view-binder。^2 MVC到MVVM 的发展历程二十世纪八十年代施乐帕克实验室提出了MVC的概念，MVC的全称即Model-View-Controller，是模型(model)一视图(view)一控制器(controller)的缩写“…，它是一种客户端软件开发框架[^4]，个人认为，其实最初的Java Web来讲，Model2 即Servlet+JSP也是用的这个结构，所以说Model2(MVC)它相对已Model1(Javabean+JSP)来讲，已经实现了View和Model的部分解耦，但是不彻底，如图 view负责显示，Model负责提供数据，Controller负责逻辑的处理，其实现的流程大概是：[^4] (1)当用户需要发送请求时，首先是在View发送请求，由View将指令传送到Controller里。 (2)Controller接收到指令之后，先完成所需要的业务逻辑，然后要求Model根据业务逻辑改变状态； (3)Model将新的数据发送给View，View则根据新的数据更新视图，从而用户的请求得到反馈。 在MVC框架中，View是可以直接访问Model的(JSP里直接使用JavaBean)，这样不可避免的使View里面也需要包括一些业务逻辑，同时还需要Model保持不变，而Model又对应着多个不同的显示(View)，所以总体说来就是，在MVC模型里面，Model不依赖View，但是View是依赖于Model的。这样就导致更改View比较困难，且业务无法重用。从而MVC框架的弊端就显现出来[^4]，这也是使用Servlet+JSP的弊端。前后端没有解耦，Model与View没有彻底解耦。 为了解决MVC框架中View和Model联系紧密的问题，开发者研究开发了MVP模式，MVP即Model-View-Presenter，即把MVC中的Controller换成了Presenter，目的就是为了完全切断View跟Model之间的联系，在MVP模式中，View负责视图的显示,Model负责提供数据，Presenter则主要负责逻辑业务的处理。[^4] 有些SSM+JSP的开发方式也是基于这种，我之前的公司就这样写，前后端不分离使用的JSP，但是交互全是Ajax，传递的全是JSON，也没有返回ModelAndView，个人感觉这里其实是使用了MVP的模式。以前后端不分离的方式丢弃模板引擎的服务端渲染，追求前后端分离中彻底解耦了View和Model。看上去怪怪的，其实有时候项目开发更多的是和业务、体量、成本、效益等有关系，综合考虑，选最合适，不一定要按照常规的构建方式考虑，比如正常思考可能不分离是为了服务端渲染，首屏快载，SEO等，分离是为了降低服务器压力，接口复用，前后端工作职责解耦. 对于SSM+模板引擎的开发方式 如何是返回Modelandview的话，那缺点就是后端路由，前后端没有彻底解耦，优点就是服务端渲染，返回的是整个构建好的页面. 如果返回JSON的话，那优点就是前后端彻底解耦，接口复用，但是没有利用模板引擎的服务端渲染。 如果体量很大，那前后端是两个人写，那使用Modelandview的方式就很麻烦，需要接口协调，而且工作职责不清晰。会浪费好多时间。JSON就方便很多。 如果体量不是他大，前端的东西也不是特别多，考虑成本问题，前后端一个人写，那Modelandview就很合适，节省了接口协调，对接等时间成本问题。 在MVP框架中，View无法直接再与Model交互，View和Model之间的通信都是通过Presenter进行完成的，所有的交互都在Presenter内部发生，即由Presenter充当了View和Model的桥梁，做到View-Model之间通信的完全隔离。Presenter完全把Model和View进行分离，将主要的程序逻辑放在Presenter里实现。[^4] **Presenter与View也是没有直接相关联的，而是通过已定义的接口进行交互**，从而使得在变更View的时候可以保持Presenter的不变，即保证了Presenter的可重用性(接口的复用性)，同时也解决了MVC框架中的View和Model关联紧密的问题。[^4] 这样之后，对于Web项目来讲，前后端都是通过数据进行交互，那路由怎么处理，前端只能实现简单一部分跳转，涉及到复杂的需要通过Controller(Presenter)来处理的路由怎么处理，或者带状态的路由如何跳转，即Controller无法控制使用那个View。个人感觉，Web系统来讲这个时候完全的前后端分离可能不是适合所有项目，而且分离之后留给前端要解决的问题可能也不是能很好的解决。所以这个时候…. 有个叫Rod Johnson 带领一帮人搞出的SpringMVC，不像桌面应用的MVC， 这里的Model没法给View 发通知。[^5]也不像MVP, 这里的Controller 可以控制View来实现路由。即前后后端没有分离，但是将原来的View的构建解耦了。由模板和数据构成： 12345678public class MyGlobalException { @ExceptionHandler(MaxUploadSizeExceededException.class) public ModelAndView customException(MaxUploadSizeExceededException e) { ModelAndView mv = new ModelAndView(&quot;javaboy&quot;); mv.addObject(&quot;error&quot;, e.getMessage()); return mv; }} 即降低了View和Model耦合，同时又实现了后端路由。对于大型项目而言，前端的东西原来越多，造成服务端的压力越来越大，而且由于MVP的出现，逐渐向前后端分离靠拢，分离之后，View分担服务端的压力，或者说是浏览器分担了服务器压力，包括页面渲染，路由等问题，这时侯MVVM出现了..（**这里是自己猜的，没找到相关资料**） MVVM框架便是前后端分离框架发展史上的一次思想的完全变革。它是将数据模型双向绑定的思想作为变革的核心，即View的变动，自动反映在ViewModel上面，而ViewModel的变动也会随即反映在View上面，从而实现数据与模型的双向绑定。[^4] 在MVVM框架中，View用于发送用户的交互请求，之后将用户请求转交给ViewModel，ViewModel即可根据用户请求操作Model数据更新，待Model数据更新完毕，便会通知ViewModel数据发生了变化，然后ViewModel就会即刻更新View数据，完成视图的更新，从而完成用户的请求。[^4] 虽然MVVM框架和之前的MVC、MVP模式的目的相同，即完成视图(View)和模型(Model)的分离，但它却有着明显的优势。[^4] 首先，MVVM框架中的View完全可以独立于Model发生变化和修改，彻底解耦，View发生变化时Model可以不变，同样，当Model发生变化时View也可以不变化，并且一个ViewModel可以绑定到多个不同的View上面，这就体现了MVVM框架的低耦合性。 其次，绑定在一个ViewModel上面的多个View都可以使用ViewModel里面的视图逻辑，完成了框架可重用性的特性。除此之外，MVVM框架还具有可独立开发、可测试等特性，把框架作用发挥到最大化，也因此成为了开发者们青睐的框架。。 对于MVVM这种模式主要用于构建基于事件驱动的 UI 平台，对于前端开发领域中数据与界面相混合的情况特别适用[^6]，其中 Model 仅仅只是代表应用程序所需的数据信息，它不关注任何行为； View 是软件中与用户进行直接交互的部分，它需要响应 ViewModel 的事件并格式化数据，不负责控制应用的状态； ViewModel 用于封装业务逻辑层，这点类似于 MVC 模式中的控制器，它控制View 的很多显示逻辑，它可以把数据模型的变化传递给视图，也可以把视图中数据的变化传递给数据模型，即在 Model 和View 之间建立了双向绑定。 Vue与MVVM我第一次看到MVVM是因为Vue，相信好多小伙伴也是Vue认识MVVM架构模式。Vue官网中讲到：**虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例**通过双向数据绑定连接视图层和数据，而实际的界面 UI 操作（DOM 操作）被封装成对应的指令（Directives）和过滤器（Filters） MVVM原理：[^7]实现数据绑定的做法有大致如下几种： 脏值检查（angular.js）: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，angular只有在指定的事件触发时进入脏值检测. DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持（vue.js）:数据劫持，指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。简单地说，就是当我们触发函数的时候 动一些手脚做点我们自己想做的事情，也就是所谓的 &quot;劫持&quot;操作 在Vue中其实就是通过Object.defineProperty来劫持对象属性的setter和getter操作，并“种下”一个监听器，当数据发生变化的时候发出通知:Object.defineProperty(obj,prop,descriptor)参数：obj:目标对象prop:需要定义的属性或方法的名称descriptor:目标属性所拥有的特性可供定义的特性列表：value:属性的值writable:如果为false，属性的值就不能被重写。get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。set:一旦目标属性被赋值，就会调回此方法。configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。 Proxy数据代理:Proxy 可以被认为是 Object.defineProperty() 的升级版。外界对某个对象的访问，都必须经过这层拦截。因此它是针对 整个对象，而不是 对象的某个属性。 12345678910111213141516171819var data = {name:'test'}Object.keys(data).forEach(function(key){ Object.defineProperty(data,key,{ enumerable:true, configurable:true, get:function(){ console.log('get'); }, set:function(newValue){ console.log('监听到数据发生了变化'); document.getElementById(‘myText’).value=newValue; } })});document.getElementById(‘myText’).addEventListener(‘keyup’,function(e){ data.name=e.target.value; // 监听 View 的变化，同步更新 Model});data.name //控制台会打印出 “get”data.name = 'hxx' //控制台会打印出 &quot;监听到数据发生了变化&quot; 1234567891011121314151617var arr = [1,2,3]var handle = { //target目标对象 key属性名 receiver实际接受的对象 get(target,key,receiver) { console.log(`get ${key}`) // Reflect相当于映射到目标对象上 return Reflect.get(target,key,receiver) }, set(target,key,value,receiver) { console.log(`set ${key}`) return Reflect.set(target,key,value,receiver) }}//arr要拦截的对象，handle定义拦截行为var proxy = new Proxy(arr,handle)proxy.push(4) //可以翻到控制台测试一下会打印出什么 发布者-订阅者模式（backbone.js）: 上述介绍了简单的一对一双向绑定的实现，即一个数据模型只与一个视图进行绑定。当多个View与一个 Model 进行绑定时，每次更新 Model 时需要在 Model 的set访问器属性中更新多个 View，这样硬编码的方式不利于后期的维护。为了解决硬编码带来的耦合性过强的问题，在在实际实现中，需要使用到设计模式中的发布 - 订阅模式。 发布 - 订阅模式（又称观察者模式）是一种常用的设计模式，该模式包含发布者和订阅者两种角色。可以让多个订阅者订阅同一个发布者发布的主题，当发布者的主题发生变化时，对外发送一个通知，所有订阅了该主题的订阅者都会接收到更新的消息。因此，观察者模式定义的是一种一对多的关系。发布 - 订阅模式非常适合于 MVVM 双向绑定中多个视图绑定到同一个数据模型的情形。 实现双向数据绑定步骤[^7]要实现mvvm的双向绑定，就必须要实现以下几点： 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者（Dep） 实现一个Watcher，Watcher是订阅 - 发布模式中订阅者的实现，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回函数 （发布），从而更新视图 MVVM入口函数，整合以上三者当新建一个 Vue 对象时，框架进入初始化阶段。Vue 在初始化阶段主要执行两个操作： 第一个是遍历系统中数据的所有属性，来对各个属性的变化添加监听； 第二个操作是利用指令编译器 Compile 对视图中绑定的指令进行扫描进行视图的初始化，然后订阅 Watcher 来更新视图，此时 Watcher 会将自己添加到消息订阅器Dep中。至此，Vue的初始化过程结束。 在系统运行过程中，一旦系统中的数据模型发生了变化，观察者 Observer 的 setter 访问器属性就会被触发，此时消息订阅中心 Dep 会遍历它所维护的所有订阅者，对于每一个订阅了该数据的对象，向它发出一个更新通知，订阅者收到通知后就会对视图进行相应的更新。以上过程不断往复循环，这就是 MVVM 模式在 Vue.js 中的运行原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Two-way data-binding&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; {{ text }} &lt;/div&gt; &lt;script&gt; function observe (obj, vm) { Object.keys(obj).forEach(function (key) { defineReactive(vm, key, obj[key]); }); } function defineReactive (obj, key, val) { var dep = new Dep(); Object.defineProperty(obj, key, { get: function () { if (Dep.target) dep.addSub(Dep.target); return val }, set: function (newVal) { if (newVal === val) return val = newVal; dep.notify(); } }); } function nodeToFragment (node, vm) { var flag = document.createDocumentFragment(); var child; while (child = node.firstChild) { compile(child, vm); flag.appendChild(child); } return flag; } function compile (node, vm) { var reg = /\\{\\{(.*)\\}\\}/; // 节点类型为元素 if (node.nodeType === 1) { var attr = node.attributes; // 解析属性 for (var i = 0; i &lt; attr.length; i++) { if (attr[i].nodeName == 'v-model') { var name = attr[i].nodeValue; // 获取v-model绑定的属性名 node.addEventListener('input', function (e) { // 给相应的data属性赋值，进而触发该属性的set方法 vm[name] = e.target.value; }); node.value = vm[name]; // 将data的值赋给该node node.removeAttribute('v-model'); } } new Watcher(vm, node, name, 'input'); } // 节点类型为text if (node.nodeType === 3) { if (reg.test(node.nodeValue)) { var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); new Watcher(vm, node, name, 'text'); } } } function Watcher (vm, node, name, nodeType) { // this为watcher函数 Dep.target = this; // console.log(this); this.name = name; this.node = node; this.vm = vm; this.nodeType = nodeType; this.update(); Dep.target = null; } Watcher.prototype = { update: function () { this.get(); if (this.nodeType == 'text') { this.node.nodeValue = this.value; } if (this.nodeType == 'input') { this.node.value = this.value; } }, // 获取daa中的属性值 get: function () { this.value = this.vm[this.name]; // 触发相应属性的get } } function Dep () { this.subs = [] } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; function Vue (options) { this.data = options.data; var data = this.data; observe(data, this); var id = options.el; var dom = nodeToFragment(document.getElementById(id), this); // 编译完成后，将dom返回到app中 document.getElementById(id).appendChild(dom); } var vm = new Vue({ el: 'app', data: { text: 'hello world' } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我的理解 **架构意义角度(Web端的角度)**：MVC和MVVM在本质上都是为了实现View和Model的解耦，MVC是通过Controller实现了View和Model的解耦，一般用与客户端，或者Web端的整个架构过程；而MVVM是在MVC发展到MVP后(为了彻底解决View和Model的耦合问题)，在提出前后端分离的基础上(考虑Coltroller的复用性，接口复用性)，对View层进行了增强(Vue.js)，或者说细化了View层的表现手法，提出了通过ViewModel对视图层的View和Model解耦。个人感觉MVVM和MVP的整体架构是有相似的地方的，不同的是面对的问题域不同，MVP是Web架构整体的解决方案，MVVM主要用于构建基于事件驱动的 UI 平台(界面)，适用于前端开发领域中数据与界面相混合的情况，所以它只专注于视图层，抽象出视图的状态和行为，实现了用户界面的UI(View)和数据(Model)的解耦。这个View和Model虽然和MVC中描述的一样，但是不相同的，可以理解为MVC中View中包含了MVVM的架构方式。一般前后端分离的Web开发中会结合MVC和MVVM两种架构模式。使用MVC构建整体的Web架构，使用MVVM解决View层DOM和data的耦合问题。 设计模式角度考虑 ：MVC是基于观察者设计模式的，Model作为一个主题，View作为观察者，当一个Model变化时，会通知更新一个或多个依赖的View，反之；MVVM可以看做是基于中介者设计模式和观察者设计模式，View和Model通过ViewModel这个中介者对象进行交互，解耦了View和Model的同时实现数据双向绑定。同时ViewModel 作为一个主题对象，View和Model为两个观察者(或者可以理解为View为主题时，Model为观察者，反之。这里的Model View起到一个注册，通知的作用，对于观察者模式的定义，ModelView是主题的行为，但实际变化的是View或者Model，**个人觉得两种理解都没问题，理解不对的请小伙伴指出来**)，当Model变化时，ViewModel由数据绑定通知并更新与之相关的多个View，反之，当View变化时，ViewModel由DOM监听通知更新相关的多个Model。 引用文献资料[^3]:浅析 web 前端 MVVM[db/ol].https://zhuanlan.zhihu.com/p/54355504[^4]:程桂花.MVVM前后端数据交互中安全机制的研究与实现[D].浙江理工大学硕士学位设计,2017:6-7[^5]:你真的理解了MVC, MVP, MVVM吗？[db/ol].https://blog.csdn.net/wdr2003/article/details/79811767[^6]:易剑波.基于 MVVM 模式的 WEB 前端框架的研究[D].计算机工程应用技术,2016.19:76][^7]:Vue MVVM理解及原理实现[db/ol].https://juejin.cn/post/6844903929298288647","link":"/2021/06/26/%E5%85%B3%E4%BA%8E%20MVVM%E5%92%8CMVC%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"},{"title":"关于JAVA 反射 基础知识_编码经验的一些总结","text":"傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 写在前面 温习一下毕业以来学习的东西。准备做成一个系列。所以对于每一部分技术点进行一个笔记整理。更多详见 java面试的一些总结 笔记主要是以网上开源的一本《Java核心面试知识整理》面试笔记为原型，结合工作中学习的知识。《Effective Java》、《编写高质量代码(改善Java程序的151个建议)》这两本书为方向进行整理。 笔记立足DevOps。开发+运维+测试三个方向 ,面向对JAVA有一定了解的小伙伴用于温习，因为理论较多一点。**在不断更新，博文内容理解不足之处请小伙伴留言指正**。 傍晚时分，你坐在屋檐下，看着天慢慢地黑下去，心里寂寞而凄凉，感到自己的生命被剥夺了。当时我是个年轻人，但我害怕这样生活下去，衰老下去。在我看来，这是比死亡更可怕的事。——–王小波 二、JAVA 反射动态语言动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。 反射机制概念(运行状态中知道类所有的属性和方法)反射(Reflection)机制允许程序在运行时借助Reflection API取得任何类的内部信息，并不能直接操作对象的内部属性及方法。反射被视为动态语言的关键。 白话讲解：在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。 JAVA 反射 API如果面试被问到，对于反射API了你了解多少？怎么回答。 Reflection API 提供了Constructor，Field和Method类，这三个类定义在java.lang.reflect包中，分别用于描述类的构造方法，属性和方法。JAVA8之后在在java.lang.reflect包中添加了Executable抽象类，parameterl类这两个API，Executable描述类的执行对象，parameter描述方法参数信息。 当然，获取这些反射APl的实例信息，还需要一个最重要对象元类Class，java.lang.Class类封装一个对象和接口运行时的状态。当类加载时Class类型的对象自动创建，Class没有公共构造方法，其对象是JVM在类加载时通过类加载器中的defineClass()方法自动构造的，不能显示的实例化一个class对象。 如果面试被问到你刚才说了类加载，你可以讲讲类加载么？ 所谓类加载，就是指将类的class文件读入内存，并为之创建一个Java.lang.class对象。即当线程使用任何一个类时，系统都会为之创建一个java.lang.Class对象。java可以使用使用forName动态加载类文件，动态加载(Dynamic Loading)是指在程序运行时加载需要的类库文件，对Java程序来说，一般情况下，一个类文件在启动时或首次初始化时会被加载到内存中，而反射则可以在运行时决定是否要加载一个类，一个类文件只有在被加载到内存中才可能生成实例对象，即加载到内存中，生成Class对象，通过new关键字生成实例对象。 每个类被加载之后，会生成一个Class对象，通过Class对象可以访问JVM中该类的信息，一旦类被载入JVM中，同一个类将不会被再次载入，被载入的类都有一个唯一的标识，是该类得到全限定类名(包括包名和类名)。 ClassClass常用方法：如果面试被问到你对Class对象了解多少,说几个常用方法，怎么回答？ Class常用方法 描述 static Class forName(String className) 返回指定类名的Class对象 T newInstance() 调用默认的构造方法，返回该Class对象的一个实例 String getName() 返回Class对象锁对应的类名 构造器相关方法 描述 Constructor&lt;?&gt;[] getConstructors() 返回Class对象所对应类的所有public构造方法 Constructor&lt;T&gt;getConstructors(Class&lt;?&gt;...parameterType) 返回Class对象所对应的类的指定参数列表的public构造方法 Constructor&lt;?&gt;[]getDeclaredConstructors() 返回Class对象所对应的所有构造方法，与访问权限无关 Constructor&lt;T&gt;getDeclaredConstructors(Class&lt;?&gt;...parameterTypes) 返回Class对象所对应类的指定参数列表的所有构造方法，与访问权限无关,如果使用私有构造器构造，需要开启访问权限setAccessible(true)：设置通过反射访问该成员变量时取消访问权限检查。 方法相关方法 描述 Method[] getMethod() 返回Class对象所对应类的所有public方法 Method getMethod(String name,Class&lt;?&gt;...parameterType) 返回Class对象所对应的指定参数列表的public方法 Method[] getDeclaredMechods() 返回Class对象所对应的所有方法，与访问权限无关 Method getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes) 返回Class对象对应类的指定参数列表的方法，与访问权限无关 属性相关方法 描述 Field[] getFields() 返回Class对象所对应类的所有public成员变量 Field getField(String name) 返回Class对象所对应的类的指定参数的public成员变量 Field[] getDeclaredFields( ) 返回Class对象所对应类的所有成员变量,与访问权限无关 Field getDeclaredField(String name) 返回Class对象所对应类指定参数的成员变量，与访问权限无关 这里需要注意的是(Method、Constructor的也一样): 调用getDeclaredFields()方法可以获取包括私有和受保护的所有属性，但不包括父类的属性； 调用getField()方法可以获得所有的public属性。包括从父类继承的。 注解相关方法 描述 Annotation [] getAnnotation() 返回Class对象所对应类上存在的所有注解 &lt; A extends Annotation&gt;A getAnnotation(Class &lt; A &gt;annotationClass ) 返回Class对象所对应类上存在的指定类型的注解 Class自身信息相关方法 描述 Class&lt;?&gt;getDeclaringClasses() 返回Class对象所对应的外部类 Class&lt;?&gt;[] getDeclaredClasses() 返回Class对象所对应的类里包含的所有内部类 Class&lt;? super T&gt;getSuperclass() 返回Class对象所对应的类里的父类的Class对象 int getModifiers() 返回Class对象所对应类的修饰符，返回的整数是修饰符的对应常量，需要是使用Modified工具类解码 Class [] getInterfaces() 返回Class对象所对应类实现的所用接口 Class LoadergetClassLoader() 返回该类的类加载器 包相关方法 描述 Package getPackage() 返回Class对象所对应的包 Class谓词相关方法 描述 boolean isArray() 判断Class对象是否表示一个数组类 boolean isEnum() 判断Class对象是否表示一个枚举 boolean isInterface() 判断Class对象是否表示一个接口 boolean isInstance(Object obj) 判断obj对象是否是该Class对象的一个实例 boolean isAnnottation() 返回Class对象是否标识一个注解类型 获取Class对象的四种方式：如果面试被问到如何获取Class对象，怎么回答？ 使用Class类的forName(String classNmae)静态方法,参数class代表所需要类的全限定类名。forName()方法声明抛出ClassNotFoundException受检异常，调用必须捕获或抛出异常。1Class&lt;?&gt; reflection_demoClass = Class.forName(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); 调用某个类的class属性来获取该类对应的Class对象，对象.class;类的Class属性获得该类所对应的Class对象，会始代码更安全。程序性更好。string类型的字符串不能使用String.class方式。需要使用Class.forName（“java.lang.String”），Object类的.class文件默认是不包含参数信息的。1Class&lt;Reflection_Demo&gt; reflection_demoClass = Reflection_Demo.class; 调用某个类的getclass()方法来获取该类对应的class对象，该方法是Object类中的一个方法1Class&lt;? extends Reflection_Demo&gt; aClass = new Reflection_Demo().getClass(); 调用元类Class对应的getClassLoader()获取类加载器，ClassLoader，这个有点牵强，姑且算一种吧，嘻嘻。。12ClassLoader classLoader = Reflection_Demo.class.getClassLoader();Class&lt;?&gt; bClass = classLoader.loadClass(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); 下面我们看看剩下的API吧！ ExecutableExecutable抽象类：JAVA8在java.lang.reflect包下新增了一个Executable抽象类，代表可执行的类成员。Executable抽象类派生了Constructor和Method两个子类。Executable抽象类提供了大量方法来获取参数，修饰符或注解等信息。 方法 描述 parameter [] getparameters() 获取所有形参，返回一个parameter [] 数组 int getParameterCount() 获取形参个数 abstract int getModifiers() 获取修饰符，返回的整数是修饰符关键字对应的常量 boolean isVarArgs() 判断是否包含数量可变的形参 ConstructorConstructor类：用于表示类的构造方法。通过Class的getConstructor()方法来获取构造方法的集合。 方法 描述 String getName() 返回构造器的名称 Class [] getParameterTypes() 返回当前构造方法的参数类型 int getModifiers() 返回修饰符的整型标识，返回的整数是修饰符是标识常量，需要使用Modified工具类方法解码Modified.toSting(int mod),可以通过Modified.PUBLIC 查看对应的值 MethodMethod类：用于封装方法的信息，调用Class对象的getMethods(）方法或getMethod()可以获取当前类的所有方法或指定的方法。 常用方法 功能描述 String getName(） 返回方法的名称 Class[] getparameterType() 返回方法的参数类型 int getModifieds() 返回修饰符的整型标识 Class getReturnType() 返回当前方法的返回类型 FieldField类：用于封装属性信息，调用Class对象的getFields()或getField()方法可以获取当前类的所有属性或指定属性。 常用方法 描述 String getName() 获取属性的名称 int getMOdifiers() 返回修饰符的整型标识 getXxx(Object obj) 获取属性的值，此处的Xxx对应的java8中的基本类型，如果属性是引用类型，直接使用get(Object obj)方法 setXxx(Object obj,Xxx val) 设置属性的值，此处的Xxx对应Java8中的基本类型，如果属性是引用类型，直接使用set(Object obj，Object val)方法 Class [] getType() 返回当前属性的类型 parameterparameter类：是JAVA8中新增的API，每个paramtete 对象代表一个参数。Parameter类提供许多方法来获取参数信息 方法 功能 int getModifiers() 获取参数的修饰符 String getName() 获取参数的形参名 Type getparameterizedType() 获取带泛型的形参类型 Class&lt;?&gt;getType() 获取形参类型 boolean isVarArgs() 判断该参数是否为可变参数 boolean isNamePreaent() 判断.class文件中是否包含方法的形参名信息 利用反射创建对象的的两种方式：如果面试被问到使用反射如何创建对象，怎么回答？ Class 对象的 newInstance(): 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。1234Class&lt;?&gt; reflection_demoClass = Class.forName(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); Reflection_Demo o = (Reflection_Demo) reflection_demoClass.newInstance(); System.out.println(o);// com.liruilong.Reflection.Reflection_Demo@677327b6 调用Constructor对象的 newInstance(): 先使用 Class 对象获取指定的 Constructor 对象，再调用Constructor对象的newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。12345Class&lt;?&gt; reflection_demoClass = Class.forName(&quot;com.liruilong.Reflection.Reflection_Demo&quot;); Constructor&lt;?&gt; constructors = reflection_demoClass.getConstructor(null); Reflection_Demo o1 = (Reflection_Demo) constructors.newInstance(null); System.out.println(o1); // com.liruilong.Reflection.Reflection_Demo@14ae5a5 关于反射的一些其他编码经验：如果面试问关于反射，平常开发中有哪些经验，要怎么回答？ **注意Class类本身的特殊性**：Java语言把Java源文件编译为后缀为class的字节码文件，然后通过ClassLocale机制把类文件加载到内存中，最后生成实例执行，Java使用元类(MetaClass）来描述加载到内存中的类数据，即Class类，描述类的类对象，需要注意Class的一些特性。 无构造函数，不能主动实例化，Class对象在加载时由java虚拟机通过类加载器中的defineClass自动构造。 可以描述基本类型 Class as=int.class;8个基本类型执行JVM中并不是一个对象，一般存在于栈中，通过Class可以描述它们，可以使用int.calss描述int类型的类对象。 Class对象都是单例模式，一个Class对象描述一个类，只描述一个类，即一个类只有一个Class对象。Class是java 的反射入口，只有在获得一个类的动态描述时才能动态的加载调用。 **适时选择getDeclaredXXX和getXXX**：getDeclaredMethod方法获得的是所有public访问级别的方法，包括从父类继承来的方法，而getDeclareMethod获得自身类的所有方法，包括公有的(public)，私有(private),方法等，不受访问权限限制。如果需要列出所有继承自父类的方法，可以先获得父类，然后使用getDeclareMethods，之后持续递归。 反射访问属性或方法时将Accessible设置为true，java中通过反射执行方法的步骤，获取一个对象的方法，然后根据isAccessible返回值确定是否能执行，如果返回false，则需要调用setAccessible(true),在调用invoke执行方法。 Access并不是语法层次理解的访问权限，而是指是否更容易获得，是否进行安全检查。动态的修改一个类或方法或执行方法时都会受到Java安全体系的制约，而安全处理非常消耗资源，所以对于运行期要执行的方法或修改的属性就提供了Accessible可选项，由开发者决定是否要逃避安全体系的检查。 AccessibleObject是field，Method，constructor的父类，决定其是否可以快速访问而不进行访问控制检查，AccessobleObject类中是以override变量保存该值的。 Accessible属性只是用来判断是否需要进行安全检查的，如果不需要则直接执行，可以提升系统性能. AccessibleObject的其他两个子类field和 constructor也相似，所以要设置Accessible为true。1234567891011121314Method method= genericDemo.class.getMethod(&quot;toArray&quot;); if(!method.isAccessible()) method.setAccessible(true); method.invoke(obj, args); public class Foo { public final void doStuff() { System.out.println(&quot;Do liruilong ___$# ^_^&quot;); } public static void main(String[] args) throws Exception, Throwable { Method method = Foo.class.getMethod(&quot;doStuff&quot;); System.out.println(&quot;可以访问吗！！&quot;+method.isAccessible()); method.invoke(new Foo()); } 动态加载不适合数组，当使用forName加载一个类时，8个基本类型排除，它不是一个具体的类，还要具有可追索的类路径，否则包ClassNotFoundException异常。数组虽然是一个类，但没有定义类路径，可以加载编译后的对象动态动态加载一个对象数组，但是没有意义。在java中数组是定长的，没有长度的数组是不允许存在的。可以使用Array数组反射类来动态加载一个数组。 123//动态创建一个数组String [] strs = (String[]) Array.newInstance(String.class,8);int[][] ints = (int [][])Array.newInstance(int.class,2,3); 元素类型 编译后的类型 byte[] [B char[] [C Double[] [D Float[] [F Int[] [I Long[] [J Short[] [S Boolean [Z 引用类型(如String) [L引用类型 动态可以让代理模式更灵活，java的反射框架提供了动态代理(Dynamic Proxy)机制，允许在运行期对目标对象生成代理，静态代理：通过代理主题角色和具体主题角色共同实现抽象主题角色的逻辑的，只是代理主题角色把相关的执行逻辑委托给了具体主题角色而已。 123456789101112131415161718192021222324interface subject{ public void request();}class RealSubject implements subject{ public void request(){ }}class Proxy implements subject{ private subject subjects = null; public Proxy(){ subjects = new RealSubject(); } public Proxy(subject subjects){ this.subjects =subjects; } public void request(){ befoer(); subjects.request(); afert(); } public void befoer(){} public void afert(){}} java基于java.lang.reflect.Proxy用于实现动态代理，使SubjectHandler作为主要的逻辑委托对象，invoke是必须要实现的，完成对真实方法的调用。即通过InvocationHandler接口的实现类来实现，所有被代理的方法都是由InvocationHandler接管实际的处理任务。 12345678910111213141516171819202122232425262728293031323334interface subject{ public void request();}class RealSubject implements subject{ public void request(){ }}class SubjectHandler implements InvocationHandler{ private subject subjects; private SubjectHandler(subject subjects) { this.subjects = subjects; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;预处理&quot;); Object obj = method.invoke(subjects,args); System.out.println(&quot;后处理&quot;); return obj; }}//场景类 public static void main(String[] args) { subject subjects = new RealSubject(); InvocationHandler handler = new SubjectHandler(subjects); //当前加载器 ClassLoader cl = subjects.getClass().getClassLoader(); //动态代理 subject proxy = (subject) Proxy.newProxyInstance(cl,subjects.getClass().getInterfaces().request(),handler); //执行具体的角色方法 proxy.request(); } 使用反射增加装饰模式的普遍性，装饰模式：动态的给一个对象添加一些额外的职责。使用动态代理可以实现装饰模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//动物interface Animal{ public void doStuff();}//老鼠class Rat implements Animal{ @Override public void doStuff(){ System.out.println(&quot;Jetty Tom&quot;); }}//定义某种能力interface Featuer{ public void load();}class FlyFeatuer implements Featuer{ public void load(){ System.out.println(&quot;增加 一支翅膀&quot;); }}class DigFeatuer implements Featuer{ public void load(){ System.out.println(&quot;增加钻地能力！&quot;); }}class DecorateAnimal implements Animal{ private Animal animal; private Class&lt;? extends Featuer&gt; clz; public DecorateAnimal(Animal animal,Class&lt;? extends Featuer&gt; clz){ this.animal = animal; this.clz = clz; } @Override public void doStuff(){ InvocationHandler handler = new InvocationHandler() { //具体的包装行为 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object obj = null; //设置包装 // public class Modifier // extends ObjectModifier类提供了static方法和常量来解码类和成员访问修饰符。 修饰符集合被表示为具有表示不同修饰符的不同位位置的整数。 //method.getModifiers()返回由该对象表示的可执行文件的Java语言modifiers 。 if (Modifier.isPublic(method.getModifiers())){ obj = method.invoke(clz.newInstance(),args); } animal.doStuff(); return obj; } }; ClassLoader cl = getClass().getClassLoader(); Featuer Proxy = (Featuer) java.lang.reflect.Proxy.newProxyInstance(cl,clz.getInterfaces(),handler); Proxy.load(); }}public class Demo { public static void main(String[] args) { //定义Jerry老树 Animal Jerry = new Rat(); Jerry = new DecorateAnimal(Jerry,FlyFeatuer.class); Jerry = new DecorateAnimal(Jerry,DigFeatuer.class); Jerry.doStuff();}} 反射让模板方法模式更强大，模板方法模式：定义一个操作中的算法骨架，将一些步骤延迟到子类中，使子类不改变一个算法的结构即可定义该算法的某些特定的步骤，即父类定义抽象模板为骨架，其中包括基本方法(由子类实现的方法，并且在模板方法被调用)和模板方法(实现对基本方法的调用，完成固定的逻辑) 123456789101112131415161718192021222324252627282930313233343536373839public abstract class AbsPopulator{ public final void dataInitialing() throws Exception{ doInit(); } protected abstract void doInit();}public class UserPopulator extends AbsPopulator{ protected void doInit(){} /*初始化用户表，如创建，加载数据等*/}//基于反射增强的模板方法 public abstract class AbsPopulator{ public final void dataInitialing() throws Exception{ doInit(); //获得所有public方法 Method[] methods = getClass().getMethods(); for(Method m:methods){ //判断是否是数据初始化方法 if(isIinitDataMethod(m)){ m.invoke(this); } } } private boolean isIinitDataMethod(Method m) { return m.getName().startsWith(&quot;init&quot;)&amp;&amp;//init开始 Modifier.isPublic(m.getModifiers())&amp;&amp;//公开的方法 m.getReturnType().equals(&quot;Void.Type&quot;)&amp;&amp;//返回类型为void !m.isVarArgs()&amp;&amp;//输入参数不为空 !Modifier.isAbstract(m.getModifiers());//不能为抽象方法 } public class UserPopulator extends AbsPopulator{ public void Inituser(){} public void InitPassword(){} public void InitJobz(){} public void Inituser(){} /*初始化用户表，如创建，加载数据等*/ } 使用反射后，不需要定义任何抽象方法，只需要定义一个基本的方法鉴别器，即可加载否和规则的基本方法，模板方法根据鉴别器返回执行相应的方法。 不需要太多的关注反射效率，获得一个泛型类的实际泛型类型。这个Demo有点问题，以后再研究 123456789101112131415161718class Utils{ //获得一个泛型类的实际泛型类型 public static &lt;T&gt; Class&lt;T&gt; getGenricClassType(Class clz) { //返回 Type表示此所表示的实体（类，接口，基本类型或void）的直接超类 类 Type type = clz.getGenericSuperclass(); //ParameterizedType表示一个参数化类型，如Collection &lt;String&gt;。 if(type instanceof ParameterizedType){ ParameterizedType pt = (ParameterizedType){ ParameterizedType pt = (ParameterizedType)type; Type[] types = pt.getActualTypeArguments(); if (types.length&gt;0&amp;&amp;types[0] instanceof Class){ return (Class)types[0]; } } return (Class)Object.class; } }}","link":"/2021/06/26/%E5%85%B3%E4%BA%8EJAVA%20%E5%8F%8D%E5%B0%84%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86_%E7%BC%96%E7%A0%81%E7%BB%8F%E9%AA%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"系统架构","slug":"系统架构","link":"/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"}],"categories":[{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"}]}