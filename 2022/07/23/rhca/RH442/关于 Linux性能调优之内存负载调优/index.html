<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>关于Linux性能调优之内存负载调优 - 山河已无恙</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="山河已无恙"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="山河已无恙"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="整理一些Linux内存调优的笔记，分享给小伙伴 博文没有涉及的Demo,理论方法偏多，可以用作内存调优入门 博文内容涉及: Linux内存管理的基本理论 寻找内存泄露的进程 内存交换空间调优 不同方式的内存回收   食用方式 需了解Linux基础知识   理解不足小伙伴帮忙指正   原谅和忘记就意味着扔掉了我们获得的最贵经验 ——-《人生的智慧》叔本华"><meta property="og:type" content="blog"><meta property="og:title" content="山河已无恙"><meta property="og:url" content="https://liruilong.blog.csdn.net/?t=1&amp;type=blog"><meta property="og:site_name" content="山河已无恙"><meta property="og:description" content="整理一些Linux内存调优的笔记，分享给小伙伴 博文没有涉及的Demo,理论方法偏多，可以用作内存调优入门 博文内容涉及: Linux内存管理的基本理论 寻找内存泄露的进程 内存交换空间调优 不同方式的内存回收   食用方式 需了解Linux基础知识   理解不足小伙伴帮忙指正   原谅和忘记就意味着扔掉了我们获得的最贵经验 ——-《人生的智慧》叔本华"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://liruilong.blog.csdn.net/img/头像.jpg"><meta property="article:published_time" content="2022-07-23T09:35:59.000Z"><meta property="article:modified_time" content="2023-06-21T11:25:59.149Z"><meta property="article:author" content="LIRUILONGS"><meta property="article:tag" content="Linux"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/头像.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://liruilongs.github.io/2022/07/23/rhca/RH442/%E5%85%B3%E4%BA%8E%20Linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E5%AD%98%E8%B4%9F%E8%BD%BD%E8%B0%83%E4%BC%98/"},"headline":"山河已无恙","image":["https://img-blog.csdnimg.cn/23f71f4521f04f118f9c2ad66b3cb364.png"],"datePublished":"2022-07-23T09:35:59.000Z","dateModified":"2023-06-21T11:25:59.149Z","author":{"@type":"Person","name":"山河已无恙"},"description":"整理一些Linux内存调优的笔记，分享给小伙伴 博文没有涉及的Demo,理论方法偏多，可以用作内存调优入门 博文内容涉及: Linux内存管理的基本理论 寻找内存泄露的进程 内存交换空间调优 不同方式的内存回收   食用方式 需了解Linux基础知识   理解不足小伙伴帮忙指正   原谅和忘记就意味着扔掉了我们获得的最贵经验 ——-《人生的智慧》叔本华"}</script><link rel="canonical" href="https://liruilongs.github.io/2022/07/23/rhca/RH442/%E5%85%B3%E4%BA%8E%20Linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E5%AD%98%E8%B4%9F%E8%BD%BD%E8%B0%83%E4%BC%98/"><link rel="alternate" href="/path/to/atom.xml" title="山河已无恙" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif-demo@latest/img/favicon.png"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?3f06f2b732a5b1034c989f74e28d0eea";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">生活小记</a><a class="navbar-item" href="/message">留言墙</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/liruilonger"><i class="fab fa-git-square fa-1x"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LIRUILONGS"><i class="fab fa-github fa-1x"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul fa-1x"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search fa-1x"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon fa-1x" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-07-23  <a class="commentCountImg" href="/2022/07/23/rhca/RH442/%E5%85%B3%E4%BA%8E%20Linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E5%AD%98%E8%B4%9F%E8%BD%BD%E8%B0%83%E4%BC%98/#comment-container"><span class="display-none-class">3e8ec9ea25881acd1244151ce7a63793</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="3e8ec9ea25881acd1244151ce7a63793">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>9.6 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">关于Linux性能调优之内存负载调优</h1><div class="content"><ul>
<li>整理一些Linux内存调优的笔记，分享给小伙伴</li>
<li>博文没有涉及的Demo,理论方法偏多，可以用作内存调优入门</li>
<li>博文内容涉及:<ul>
<li>Linux内存管理的基本理论</li>
<li>寻找内存泄露的进程</li>
<li>内存交换空间调优</li>
<li>不同方式的内存回收</li>
</ul>
</li>
<li>食用方式<ul>
<li>需了解Linux基础知识</li>
</ul>
</li>
<li>理解不足小伙伴帮忙指正</li>
</ul>
<p><strong><font color="009688"> 原谅和忘记就意味着扔掉了我们获得的最贵经验 ——-《人生的智慧》叔本华</strong></font></p>
<span id="more"></span>

<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>整理一些Linux内存调优的笔记，分享给小伙伴</li>
<li>博文没有涉及的Demo,理论方法偏多，可以用作内存调优入门</li>
<li>博文内容涉及:<ul>
<li>Linux内存管理的基本理论</li>
<li>寻找内存泄露的进程</li>
<li>内存交换空间调优</li>
<li>不同方式的内存回收</li>
</ul>
</li>
<li>食用方式<ul>
<li>需了解Linux基础知识</li>
</ul>
</li>
<li>理解不足小伙伴帮忙指正</li>
</ul>
<p><strong><font color="009688"> 原谅和忘记就意味着扔掉了我们获得的最贵经验 ——-《人生的智慧》叔本华</strong></font></p>
<hr>
<p>讲内存之前，简单介绍下<code>调优的一些方法论</code>，一般调优首先需要分析系统性能，然后执行系统变更测试应用。</p>
<p><strong>分析系统性能的方法：</strong></p>
<p>分析利用率、饱和、错误 (Utilization, Saturation and Errors (USE))和系统资源</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>资源 Resource</td>
<td>服务器中的硬件资源(CPU、内存、网络、 磁盘和控制器)</td>
</tr>
<tr>
<td>利用率 Utilization</td>
<td>资源提供服务的平均时间(70%)</td>
</tr>
<tr>
<td>饱和度 Saturation</td>
<td>资源承担额外工作量的能力，这类工作通常 排队(队列长度)</td>
</tr>
<tr>
<td>错误 Errors</td>
<td>错误事件数量</td>
</tr>
</tbody></table>
<p><strong>执行系统变更的步骤：</strong></p>
<table>
<thead>
<tr>
<th>执行系统变更的步骤</th>
</tr>
</thead>
<tbody><tr>
<td>设定基线：在调优中，执行性能测试，收集指标</td>
</tr>
<tr>
<td>执行变更：在系统上执行变更，建议查阅相应官方文档</td>
</tr>
<tr>
<td>验证变更有效性：执行变更后，重新运行测试，比较一些关键指标</td>
</tr>
<tr>
<td>取消变更并与基线对比：如有需要，可以取消变更并返回到基线状态</td>
</tr>
<tr>
<td>应用最终更改：应用并记录最终变更</td>
</tr>
</tbody></table>
<hr>
<p>在现代处理器中，与CPU执行代码或处理信息相比，<code>向内存子系统保存信息或从中读取信息一般花费的时间更长</code>。</p>
<p>通常，在<code>CPU执行指令</code>或处理数据前，它会消耗相当多的空闲时间来<code>等待从内存中取出指令和数据</code>。处理器用不同层次的<code>高速缓存(cache)</code>来弥补这种缓慢的内存性能。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存是内核所做的比较复杂的事情之一。高效的内存管理对于系统中进程的良好性能至关重要。现代计算机系统使用分页来安全、灵活地管理系统内存。</p>
<p>为了提高效率，Linux将其分成<code>块</code>或<code>内存“页”</code>。当对内存进分配或传送时，Linux<code>操作的单位是页</code>，而不是<code>单个字节</code>。在报告一些内存统计数据时，Linux内核报告的是<code>每秒页面的数量</code>，该值根据其运行的架构可以发生变化。</p>
<p>系统上的物理RAM被分为页帧;一页帧保存一页数据。进程不直接寻址物理内存。相反，每个进程都有一个虚拟地址空间。当进程被分配内存时，页帧的物理地址被映射到进程的一个虚拟地址。从<code>进程</code>的角度来看，<code>它有一个私有的内存空间</code>，它只能看到映射到它的一个虚拟地址的物理页帧。</p>
<p><code>进程虚拟地址空间(页面)</code>的大小取决于处理器架构。在32位i386系统上，一个进程的虚拟地址空间可以容纳2^32 个字节(4gib)的内存;在64位x86-64系统上，地址空间的大小是2^64 字节(16 EiB)。然而，单个进程通常不会使用它的整个地址空间;它的大部分是未分配的，也没有映射到任何实际的物理内存。但是<code>虚拟地址空间的大小确实限制了进程可以拥有的最大内存</code>。</p>
<p>一些内存涉及的名词解释</p>
<h4 id="交换分区-物理内存不足"><a href="#交换分区-物理内存不足" class="headerlink" title="交换分区(物理内存不足)"></a>交换分区(物理内存不足)</h4><p>所有系统<code>RAM芯片的物理内存容量</code>都是固定的。即使应用程序需要的内存容量大于可用的物理内存，Linux内核仍然允许这些程序运行。Linux内核使用<code>硬盘作为临时存储器</code>，这个硬盘空间被称为<code>交换分区(swap space)</code>。</p>
<p>尽管交换是让进程运行的极好的方法，但它却慢的要命。与使用物理内存相比，应用程序使用交换的速度可以慢到一千倍。<code>如果系统性能不佳，确定系统使用了多少交换通常是有用的。</code></p>
<h4 id="缓冲区-buffer-和缓存-cache-物理内存太多"><a href="#缓冲区-buffer-和缓存-cache-物理内存太多" class="headerlink" title="缓冲区(buffer)和缓存(cache)(物理内存太多)"></a>缓冲区(buffer)和缓存(cache)(物理内存太多)</h4><h5 id="缓存-cache"><a href="#缓存-cache" class="headerlink" title="缓存(cache)"></a>缓存(cache)</h5><p>相反，如果你的<code>系统物理内存容量超过了应用程序的需求</code>，Linux就会在<code>物理内存中缓存近期使用过的文件</code>，这样，后续访问这些文件时就不用去访问硬盘了。</p>
<p>对要频繁访问硬盘的应用程序来说，这可以显著加速其速度，显然，对经常启动的应用程序而言，这是特别有用的。</p>
<p>应用程序首次启动时，它需要从硬盘读取；但是，如果应用程序留着缓存中，那它就需要从更快速的物理内存读取。</p>
<h5 id="缓冲区-buffer"><a href="#缓冲区-buffer" class="headerlink" title="缓冲区(buffer)"></a>缓冲区(buffer)</h5><p>Linux还使用了额外的存储作为缓冲区。为了进一步优化应用程序，<code>Linux为需要被写回硬盘的数据预留了存储空间。这些预留空间被称为缓冲区</code>。如果应用程序要将<code>数据写回硬盘</code>，通常需要花费<code>较长时间</code>，Linux让应用程序<code>立刻继续执行</code>，但将<code>文件数据</code>保存到<code>内存缓冲区</code>。在之后的某个时刻，<code>缓冲区被刷新到硬盘</code>，而应用程序可以<code>立即继续</code>。</p>
<p><code>高速缓存和缓冲区</code>的使用使得系统内<code>空闲的内存</code>很少，默认情况下，Linux试图尽可能多的使用你的内存。这是好事。</p>
<p>如果<code>Linux侦测</code>到有<code>空闲内存</code>，它就会<code>将应用程序和数据缓存到这些内存以加速未来的访问</code>。由于访问内存的速度比访问硬盘的速度<code>快了几个数量级</code>，因此，这就可以显著地提升<code>整体性能</code>。</p>
<p>如果系统需要缓存空间做更重要的事情，那么缓存空间将被擦除并交给系统。之后，对原来被缓存对象的访问就需要转向硬盘来满足。</p>
<h4 id="活跃与非活跃内存"><a href="#活跃与非活跃内存" class="headerlink" title="活跃与非活跃内存"></a>活跃与非活跃内存</h4><ul>
<li><code>活跃内存</code>是指当前被进程使用的内存。</li>
<li><code>不活跃内存</code>是指已经被分配了，但暂时还未使用的内存。</li>
</ul>
<p>这两种类型的内存没有本质上的区别。需要时，Linux找出进程最近最少使用的<code>内存页面</code>，并将它们从活跃列表移动到不活跃列表。当要选择把<code>哪个内存页交换到硬盘</code>时，<code>内核就从不活跃内存列表中进行选择</code>。</p>
<h4 id="内核的内存使用情况-分片"><a href="#内核的内存使用情况-分片" class="headerlink" title="内核的内存使用情况(分片)"></a>内核的内存使用情况(分片)</h4><p>除了<code>应用程序</code>需要分配内存外，<code>Linux内核</code>也会为了<code>记账</code>的目的消耗一定量的内存。</p>
<p>记账包括，比如<code>跟踪从网络或磁盘I/O来的数据</code>，以及跟踪哪些进程正在运行，哪些正在休眠。<code>为了管理记账，内核有一系列缓存</code>，包含<code>一个或多个内存分片</code>。每个分片为一组对象，个数可以是一个或多个。</p>
<p><code>内核消耗的内存分片数量取决于使用的是Linux内核的哪些部分</code>，而且还可以随着机器负载类型的变化而变化。</p>
<h3 id="进程内存"><a href="#进程内存" class="headerlink" title="进程内存"></a>进程内存</h3><p>当进程试图访问虚拟内存中<code>尚未分配物理页面</code>的页面时, 即应用程序中没有加载的内存中数据,将触发<code>页面错误</code>。</p>
<ul>
<li>如果需要分配一个新的<code>物理内存页</code>，这被称为<code>次要页面故障</code>。</li>
<li>如果内核需要<code>从磁盘检索一页内存</code>，则称为<code>重大页面故障</code>。</li>
</ul>
<p>发生重大页面错误的原因包括恢复已换出的虚拟内存页面，或将数据或代码从可执行文件映射到内存。<code>次要页面错误</code>会导致<code>少量开销</code>，但是<code>重大页面错误</code>会对<code>性能</code>产生重大影响。</p>
<p>要查看每个进程的<code>次要和主要页面错误</code>，你可以使用<code>ps</code>命令，询问<code>minflt</code>和<code>majflt</code>列:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ ps -o pid,cmd,comm,minflt,majflt $$</span><br><span class="line">   PID CMD                         COMMAND         MINFLT MAJFLT</span><br><span class="line"> 12280 -bash                       bash             11203      0</span><br><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ ps -o pid,cmd,comm,minflt,majflt 889</span><br><span class="line">   PID CMD                         COMMAND         MINFLT MAJFLT</span><br><span class="line">   889 /usr/bin/etcd --name=defaul etcd              7091     90</span><br></pre></td></tr></table></figure>

<h3 id="使用cgroups限制内存"><a href="#使用cgroups限制内存" class="headerlink" title="使用cgroups限制内存"></a>使用cgroups限制内存</h3><p>进程可用的内存量可以用<code>cgroup</code>内存控制器来限制。在内存cgroup中有几个相关的文件涉及内核参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ ls /sys/fs/cgroup/memory/</span><br><span class="line">cgroup.clone_children           memory.kmem.tcp.limit_in_bytes      memory.oom_control</span><br><span class="line">cgroup.event_control            memory.kmem.tcp.max_usage_in_bytes  memory.pressure_level</span><br><span class="line">cgroup.procs                    memory.kmem.tcp.usage_in_bytes      memory.soft_limit_in_bytes</span><br><span class="line">cgroup.sane_behavior            memory.kmem.usage_in_bytes          memory.stat</span><br><span class="line">docker                          memory.limit_in_bytes               memory.swappiness</span><br><span class="line">memory.failcnt                  memory.max_usage_in_bytes           memory.usage_in_bytes</span><br><span class="line">memory.force_empty              memory.memsw.failcnt                memory.use_hierarchy</span><br><span class="line">memory.kmem.failcnt             memory.memsw.limit_in_bytes         notify_on_release</span><br><span class="line">memory.kmem.limit_in_bytes      memory.memsw.max_usage_in_bytes     release_agent</span><br><span class="line">memory.kmem.max_usage_in_bytes  memory.memsw.usage_in_bytes         system.slice</span><br><span class="line">memory.kmem.slabinfo            memory.move_charge_at_immigrate     tasks</span><br><span class="line">memory.kmem.tcp.failcnt         memory.numa_stat                    user.slice</span><br></pre></td></tr></table></figure>


<p>看一个docker 进程的相关信息</p>
<ul>
<li><code>memory.stat</code>: :这个cgroup中内存和交换分区的使用情况以及内存总量的详细统计。</li>
</ul>
<p>dockers配置了开机自动启动，从Cgroup角度看，所以他在是systemd这个slicp下面，作为一个service单元受CGroup管理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/sys/fs/cgroup/memory/system.slice/docker.service]</span><br><span class="line">└─$ cat ./memory.stat</span><br><span class="line">cache 3657728</span><br><span class="line">rss 144375808</span><br><span class="line">rss_huge 113246208</span><br><span class="line">mapped_file 0</span><br><span class="line">swap 0</span><br><span class="line">pgpgin 25693</span><br><span class="line">pgpgout 23278</span><br><span class="line">pgfault 84168</span><br><span class="line">pgmajfault 0</span><br><span class="line">inactive_anon 4096</span><br><span class="line">active_anon 144375808</span><br><span class="line">inactive_file 397312</span><br><span class="line">active_file 3256320</span><br><span class="line">unevictable 0</span><br><span class="line">hierarchical_memory_limit 9223372036854771712</span><br><span class="line">hierarchical_memsw_limit 9223372036854771712</span><br><span class="line">total_cache 3657728</span><br><span class="line">total_rss 144375808</span><br><span class="line">total_rss_huge 113246208</span><br><span class="line">total_mapped_file 0</span><br><span class="line">total_swap 0</span><br><span class="line">total_pgpgin 25693</span><br><span class="line">total_pgpgout 23278</span><br><span class="line">total_pgfault 84168</span><br><span class="line">total_pgmajfault 0</span><br><span class="line">total_inactive_anon 4096</span><br><span class="line">total_active_anon 144375808</span><br><span class="line">total_inactive_file 397312</span><br><span class="line">total_active_file 3256320</span><br><span class="line">total_unevictable 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>memory.limit_in_bytes</code>:在这里写入一个值，以<code>限制这个cgroup中可以使用的用户内存(包括缓存)的数量</code>。字节以外的单位可以通过在被设置的值后面加上k、m或g来使用。</li>
</ul>
<p>所以我们可以通过修改这个值来限制docker的内存使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/sys/fs/cgroup/memory/system.slice/docker.service]</span><br><span class="line">└─$ cat ./memory.limit_in_bytes</span><br><span class="line">9223372036854771712</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1G &gt; ./memory.limit_in_bytes</span><br></pre></td></tr></table></figure>
<ul>
<li><code>memory.memsw.limit_in_bytes</code>:类似于<code>memory.limit_in_bytes</code>，但这一次是<code>内存+交换</code>组合。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/sys/fs/cgroup/memory/system.slice/docker.service]</span><br><span class="line">└─$ cat ./memory.memsw.limit_in_bytes</span><br><span class="line">9223372036854771712</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当然也可以在单位配置文件<code>[Service]</code>部分中添加下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemoryLimit=value</span><br></pre></td></tr></table></figure>
<p>对<code>cgroup</code>中执行的进程设定其可用内存的最大值，同样，<code>MemoryAccounting 参数必须在同一单元中启用</code>。<code>MemoryAccounting=yes</code>打开此单元的进程和内核内存占。接受一个布尔参数 ,这里 <code>MemoryLimit 参数可以控制 memory.limit_in_bytes Cgroup参数</code>实现内存限制</p>
<p>其他的内核参数</p>
<ul>
<li><code>memory.failcnt</code>和<code>memory.memsw.failcnt</code>:这些文件报告内存的频率。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/sys/fs/cgroup/memory/system.slice/docker.service]</span><br><span class="line">└─$ cat ./memory.failcnt</span><br><span class="line">0</span><br><span class="line">┌──[root@liruilongs.github.io]-[/sys/fs/cgroup/memory/system.slice/docker.service]</span><br><span class="line">└─$ cat memory.memsw.failcnt</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>要查看<code>进程</code>的<code>虚拟地址空间</code>是如何使用的，可以使用<code>pmap PID</code>命令，或者查看<code>/proc/PID/maps</code>和<code>/proc/PID/maps</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ pmap 889 | head  -10</span><br><span class="line">889:   /usr/bin/etcd --name=default --data-dir=/var/lib/etcd/default.etcd --listen-client-urls=http://192.168.26.55:2379,http://localhost:2379</span><br><span class="line">000000c000000000      8K rw---   [ anon ]</span><br><span class="line">000000c41ffc6000   6376K rw---   [ anon ]</span><br><span class="line">000000c420600000   1216K rw---   [ anon ]</span><br><span class="line">00005618c7aaa000  15784K r-x-- etcd</span><br><span class="line">00005618c8c14000   8672K r---- etcd</span><br><span class="line">00005618c948c000    332K rw--- etcd</span><br><span class="line">00005618c94df000    168K rw---   [ anon ]</span><br><span class="line">00005618ca601000    132K rw---   [ anon ]</span><br><span class="line">00007ff23c000000    132K rw---   [ anon ]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ cat /proc/889/maps | head  -10</span><br><span class="line">c000000000-c000002000 rw-p 00000000 00:00 0</span><br><span class="line">c41ffc6000-c420600000 rw-p 00000000 00:00 0                              [stack:889]</span><br><span class="line">c420600000-c420730000 rw-p 00000000 00:00 0</span><br><span class="line">5618c7aaa000-5618c8a14000 r-xp 00000000 08:01 272289927                  /usr/bin/etcd</span><br><span class="line">5618c8c14000-5618c948c000 r--p 00f6a000 08:01 272289927                  /usr/bin/etcd</span><br><span class="line">5618c948c000-5618c94df000 rw-p 017e2000 08:01 272289927                  /usr/bin/etcd</span><br><span class="line">5618c94df000-5618c9509000 rw-p 00000000 00:00 0</span><br><span class="line">5618ca601000-5618ca622000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7ff23c000000-7ff23c021000 rw-p 00000000 00:00 0</span><br><span class="line">7ff23c021000-7ff240000000 ---p 00000000 00:00 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ cat /proc/889/smaps | head  -10</span><br><span class="line">c000000000-c000002000 rw-p 00000000 00:00 0</span><br><span class="line">Size:                  8 kB</span><br><span class="line">Rss:                   8 kB</span><br><span class="line">Pss:                   8 kB</span><br><span class="line">Shared_Clean:          0 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:         0 kB</span><br><span class="line">Private_Dirty:         8 kB</span><br><span class="line">Referenced:            8 kB</span><br><span class="line">Anonymous:             8 kB</span><br><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<h2 id="找到内存泄漏"><a href="#找到内存泄漏" class="headerlink" title="找到内存泄漏"></a>找到内存泄漏</h2><p>有时候进程在<code>使用完内存后不能正确地释放内存</code>。</p>
<p>如果进程是一个短生命周期的进程，如<code>ls</code>或<code>netstat</code>，这不是一个大问题，因为当一个进程退出时，它的所有内存都会被内核释放，</p>
<p>如果它是一个<code>长时间运行的进程</code>，问题可能会变得相当严重。</p>
<p>除了<code>杀死并重新启动进程</code>外，系统管理员在<code>修复内存泄漏</code>方面所能做的事情并不多。识别内存泄漏是系统管理员的职责之一。</p>
<p>要识别内存泄漏，可以使用通用工具，如<code>ps</code>,<code>top</code>,<code>free</code>,<code>sar -r</code>和<code>sar -R</code>，</p>
<p>但也有专门的工具，如<code>valgrind</code>工具<code>memcheck</code>。要在memcheck工具下运行进程，可以使用如下命令:<code>valgrind --tool=memcheck program args-pro</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ yum -y install valgrind</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ rpm -ivh bigmem-7.0-1.r29766.x86_64.rpm</span><br><span class="line">准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:bigmem-7.0-1.r29766              <span class="comment">################################# [100%]</span></span><br></pre></td></tr></table></figure>

<p>有两种不同类型的内存泄漏需要注意。</p>
<ul>
<li>在第一种情况下，内存泄露，程序通过malloc<code>(一种分配内存块的函数)</code>等系统调用请求内存，但实际上并<code>不使用这些内存</code>。这将导致程序的虚拟大小增加(<code>VIRT</code>)，以及<code>/proc/meminfo</code>中的<code>Committed_AS(当前在系统上分配的内存量。提交的内存是进程分配的所有内存的总和，即使它还没有被它们“使用”)</code>行，但没有使用实际的物理内存。常驻大小(顶部的<code>RSS</code>)保持(几乎)不变。</li>
</ul>
<p>对应的参数我么可以通过top命令获取，top版本不同，对应的列名有些差别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top - 11:48:07 up 14 min,  1 user,  load average: 0.07, 0.10, 0.13</span><br><span class="line">Tasks: 273 total,   2 running, 271 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : 32931532 total, 23319380 free,  8643596 used,   968556 buff/cache</span><br><span class="line">KiB Swap: 10485756 total, 10485756 free,        0 used. 23759444 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">   889 etcd      20   0 10.559g  29332  11008 S   1.3  0.1   0:10.94 etcd</span><br><span class="line">  8089 nginx     20   0   41636  12148   1588 S   1.3  0.0   0:03.35 redis-server</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%MEM</td>
<td>进程使用内存量占系统物理内存的百分比</td>
</tr>
<tr>
<td>VIRT(v3.x)&#x2F;SIME(v2.x)</td>
<td>进程虚拟内存使用总量。其中包括了应用程序分配到但未使用的全部内存</td>
</tr>
<tr>
<td>SWAP</td>
<td>进程使用的交换区(单位为KB)总量</td>
</tr>
<tr>
<td>RSS(v2.x)&#x2F;RES(v3.x)</td>
<td>应用程序实际使用的物理内存总量</td>
</tr>
<tr>
<td>SHARE(v 2.x)&#x2F;SHR(V 3.x)</td>
<td>可与其他进程共享的内存总量(单位为KB)</td>
</tr>
<tr>
<td>Mem:total，used，free</td>
<td>对物理内存来说，该项表示的是其总量、使用量和空闲量</td>
</tr>
<tr>
<td>swap:total，used，free</td>
<td>对交换分区来说，该项表示的是其总量、使用量和空闲量</td>
</tr>
<tr>
<td>buff&#x2F;cache</td>
<td>用于缓冲区写人硬盘的数值和缓存的物理内存总量(单位为KB)</td>
</tr>
</tbody></table>
<ul>
<li>在第二种情况下，内存溢出，程序实际<code>使用它分配的内存</code>。这将导致<code>驻留大小与虚拟大小同步增加</code>，从而导致实际的内存短缺。虽然泄漏虚拟内存不是一件好事，但泄漏驻留内存将对系统造成更大的影响。</li>
</ul>
<p>看一个书里的Demo，在运行下面的应用程序时，请跟踪内存统计数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ watch <span class="string">&#x27;free -k;grep Committed_AS /proc/meminfo&#x27;</span></span><br><span class="line">Every 1.0s: free -k;grep Committed_AS /proc/meminfo                                             Fri Jul 29 20:47:24 2022</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32927488     4922536    27100148       22264      904804    27579940</span><br><span class="line">Swap:      10485756           0    10485756</span><br><span class="line">Committed_AS:    6853280 kB</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先安装valgrind，然后在valgrind下运行bigmem命令，要求分配256mib的常驻内存。现在bigmem请求256 MiB的虚拟内存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ valgrind --tool=memcheck bigmem 256</span><br><span class="line">==65614== Memcheck, a memory error detector</span><br><span class="line">==65614== Copyright (C) 2002-2017, and GNU GPL<span class="string">&#x27;d, by Julian Seward et al.</span></span><br><span class="line"><span class="string">==65614== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info</span></span><br><span class="line"><span class="string">==65614== Command: bigmem 256</span></span><br><span class="line"><span class="string">==65614==</span></span><br><span class="line"><span class="string">Attempting to allocate 256 Mebibytes of resident memory...</span></span><br><span class="line"><span class="string">Press &lt;Enter&gt; to exit</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>现在我们确定bigmem正在泄漏内存，泄露的原因是<code>bigmem 256</code> 导致的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==65614== Command: bigmem 256</span><br><span class="line">==65614==</span><br><span class="line">Attempting to allocate 256 Mebibytes of resident memory...</span><br></pre></td></tr></table></figure>
<p>观察内存变化，<code>Committed_AS </code>,即分配的虚拟内存增加了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Every 1.0s: free -k;grep Committed_AS /proc/meminfo                                             Fri Jul 29 21:00:49 2022</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       32927488     5157320    26858220       22296      911948    27345124</span><br><span class="line">Swap:      10485756           0    10485756</span><br><span class="line">Committed_AS:    7281208 kB</span><br></pre></td></tr></table></figure>


<h2 id="交换空间调优"><a href="#交换空间调优" class="headerlink" title="交换空间调优"></a>交换空间调优</h2><p>嗯，这里为了方面，我们把交换分区，交换文件统一称交换分区，或者交换空间</p>
<p><code>交换分区</code>会增加系统上的<code>有效内存量</code>。当可用内存减少时，可以将不使用的页面换出到磁盘，以释放空间供其他用途。当再次需要这些页时，会发生一个严重的页错误，在使用它们之前，需要将它们再次从磁盘页到内存中。</p>
<p>这为我们提供了另一种方法来释放正在运行的系统上的内存，并有效地使用我们拥有的内存。<code>swap的缺点是，与RAM相比，大多数存储设备都非常慢。在内存中进行换出和换出会显著降低系统的速度。</code></p>
<p>vmstat实用程序可以为您提供关于系统是否正在进行分页交换(“交换”)的信息。<code>vmstat输出中的关键列是si/so等等。每秒换入的页面和每秒换出的页面。</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ vmstat 1 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 1  0      0 27056464   3104 912452    0    0    28    20  259  310  4  2 94  0  0</span><br><span class="line"> 0  0      0 27055988   3104 912456    0    0     0     0 1583 2023  6  2 93  0  0</span><br><span class="line"> 1  0      0 27044272   3104 912480    0    0    24    36  845 1214  1  1 98  0  0</span><br><span class="line"> 1  0      0 27055892   3104 912480    0    0     0     0 1880 2929  5  2 94  0  0</span><br><span class="line"> 4  0      0 27056416   3104 912484    0    0     0     0 1730 2107  6  2 92  0  0</span><br><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p>将内存页面放置在交换分区中不会损害性能，它可以通过将不需要的页面移出RAM，以便将RAM用于更有用的事情来提高性能。</p>
<p>影响性能的是<code>频繁地将页面移进移出交换区:si和so报告了这一点</code>。一个系统应该有多少互换?人们提出了许多经验法则。如果你仔细想想，你需要交换两个基本的东西。</p>
<p>首先，移动你不需要在内存中所有时间的页面，以便RAM可以用于更好的事情。<br>其次，提供应急储备，避免出现内存不足的情况。空间大小很大程度上取决于系统有多少RAM以及你在计算机上做什么。</p>
<p>因为这比经验法则更难计算，人们倾向于根据粗略的估计来设置交换分区。Red Hat提供的基本指导如下:</p>
<table>
<thead>
<tr>
<th>系统内存最大支持</th>
<th>推荐最小交换分区</th>
</tr>
</thead>
<tbody><tr>
<td>4gb</td>
<td>至少2gb</td>
</tr>
<tr>
<td>4gb ~ 16gb</td>
<td>至少4gb</td>
</tr>
<tr>
<td>16gb ~ 64gb</td>
<td>至少8gb</td>
</tr>
<tr>
<td>64gb ~ 256gb</td>
<td>至少16gb</td>
</tr>
</tbody></table>
<p>系统内存和页缓存进程并不是系统内存的唯一消耗者。内核可以为自己的代码使用内存，或者以其他方式加速系统。</p>
<p>其中一种方法是页缓存。当您运行<code>vmstat或free</code>命令时，即使在拥有大量内存的系统上，也没有多少内存被标记为“空闲”。</p>
<p>如果系统最近执行了大量的存储I&#x2F;O，这一点尤其正确。其中一个原因是页缓存。内核使用大部分未分配的内存作为缓存来存储从磁盘读取或写入的数据。</p>
<p>下一次需要数据时，可以从RAM而不是磁盘中获取数据。这通常会带来显著的性能改进，因为存储通常比物理内存慢得多。保留少量RAM以备短期请求使用;从长远来看，页缓存很容易被释放用于其他用途。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            15G        6.2G        316M        801M        9.0G        8.0G</span><br><span class="line">Swap:          6.0G        107M        5.9G</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>swpd</strong> :当前<code>交换到硬盘的内存总量</code></li>
<li><strong>free</strong> :<code>未被操作系统或应用程序使用的物理内存总量</code></li>
<li><strong>buff</strong> : <code>系统缓冲区大小(单位为KB)，或用于存放等待保存到硬盘的数据的内存大小(单位为KB)</code>。该存储区允许<code>应用程序向Linux内核发出写调用后立即继续执行</code>(而不是等待直到数据被提交到硬盘)</li>
<li><strong>cache</strong> :用于保存之前<code>从硬盘读取的数据的系统高速缓存或内存的大小(单位为KB)</code>。如果应用程序再次需要该数据，内核可以从内存而非硬盘抓取数据，由此可提高性能</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line"> 1  0 110304 323928     80 9453436    0    0     0     2    0    0  1  1 97  1  0</span><br><span class="line"> 0  0 110304 322804     80 9453436    0    0     0     0 16190 24907  1  2 96  1  0</span><br><span class="line"> 0  0 110304 323900     80 9453492    0    0     0     4 15462 24521  1  1 97  1  0</span><br><span class="line"> 0  0 110304 324232     80 9453492    0    0     0     0 14469 23522  1  1 97  1  0</span><br><span class="line"> 0  0 110304 324476     80 9453540    0    0     0    16 15790 24329  1  2 95  1  0</span><br><span class="line">[iomyw@iomywapp1 ~]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>温习一下交换空间的创建</p>
<p><strong>交换分区</strong></p>
<p>为你的系统额外添加一个<code>512MiB</code>的交换分区，此交换分区应在系统启动时<code>自动挂载</code>，不删除或以任何方式改动系统上原有的交换分区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk /dev/vdb  <span class="comment">#需要分区的硬盘</span></span><br><span class="line">.. ..</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n <span class="comment">#添加新分区</span></span><br><span class="line">Partition number (2-128, default 2):  <span class="comment"># 直接回车(默认)</span></span><br><span class="line">First sector (4194304-20971486, default 4194304):  <span class="comment"># 直接回车(默认)</span></span><br><span class="line">Last sector, *sectors or +size&#123;K,M,G,T,P&#125; (4194304-20971486,default 20971486): +512M</span><br><span class="line">Created a new partition 2 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 512 MiB.</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w  <span class="comment"># 保存分区表，并退出</span></span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br><span class="line">$ partprobe /dev/vdb  <span class="comment"># 刷新分区表</span></span><br><span class="line">$ mkswap /dev/vdb2  <span class="comment"># 格式化自建分区 vdb2</span></span><br><span class="line">$ vim /etc/fstab</span><br><span class="line">/dev/vdb2 swap swap defaults 0 0</span><br><span class="line">$ swapon -a  <span class="comment"># 启用 fstab 中的交换设备</span></span><br><span class="line">$ swapon -s  <span class="comment"># 查看交换分区信息</span></span><br></pre></td></tr></table></figure>


<p><strong>交换文件</strong></p>
<p>创建一个 1G 的交换文件，系统启动时挂载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  200G  0 disk</span><br><span class="line">├─sda1   8:1    0  150G  0 part /</span><br><span class="line">└─sda2   8:2    0   10G  0 part [SWAP]</span><br><span class="line">┌──[root@liruilongs.github.io]-[/dev]</span><br><span class="line">└─$ dd <span class="keyword">if</span>=/dev/sda1 of=/swap_LRL bs=1024 count=1048576</span><br><span class="line">记录了1048576+0 的读入</span><br><span class="line">记录了1048576+0 的写出</span><br><span class="line">1073741824字节(1.1 GB)已复制，7.93545 秒，135 MB/秒</span><br><span class="line">┌──[root@liruilongs.github.io]-[/dev]</span><br><span class="line">└─$ mkswap  /swap_LRL</span><br><span class="line">mkswap: /swap_LRL: warning: wiping old xfs signature.</span><br><span class="line">正在设置交换空间版本 1，大小 = 1048572 KiB</span><br><span class="line">无标签，UUID=ddecd087-fa65-4047-860b-609476a942f3</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/]</span><br><span class="line">└─$ vim /etc/fstab</span><br><span class="line">┌──[root@liruilongs.github.io]-[/dev]</span><br><span class="line">└─$ cat /etc/fstab  | grep LRL</span><br><span class="line">/swap_LRL                    swap  swap     defaults        0 0</span><br><span class="line">┌──[root@liruilongs.github.io]-[/]</span><br><span class="line">└─$ swapon -a</span><br><span class="line">swapon: /swap_LRL：不安全的权限 0644，建议使用 0600。</span><br><span class="line">┌──[root@liruilongs.github.io]-[/]</span><br><span class="line">└─$ swapon -s</span><br><span class="line">文件名                          类型            大小    已用    权限</span><br><span class="line">/dev/sda2                               partition       10485756        0       -2</span><br><span class="line">/swap_LRL                               file    1048572 0       -3</span><br></pre></td></tr></table></figure>


<h3 id="调整内核交换的方式"><a href="#调整内核交换的方式" class="headerlink" title="调整内核交换的方式"></a>调整内核交换的方式</h3><p>当内核想要释放一页内存时，它需要在两种选择之间进行权衡。<code>它可以从进程内存中交换一个页(放到交换分区)，也可以从页缓存中删除一个页</code>。为了做出这个决定，内核将执行以下计算:</p>
<p><code>swap_tendency = mapped_ratio/2 + distress + vm_swappiness</code></p>
<p>如果<code>swap_tendency</code>小于100，内核将从页缓存中回收一个页，如果大于或等于100，属于进程内存空间的页将符合交换条件。</p>
<p>在这个计算中，</p>
<ul>
<li><code>mapped_ratio</code>是使用的物理内存的百分比。</li>
<li><code>Distress</code>是衡量内核在释放内存方面有多大困难的指标。它将从0开始，但如果需要更多的尝试来释放内存，它将增加(到最大100)。</li>
<li><code>vm_swappiness</code> 值来自<code>sysctl vm.swappiness</code>即位于内核参数中的一个值,交换分区的采用频率</li>
</ul>
<p><strong>关于 <code>vm.swappiness </code>调优。交换空间会严重影响系统。</strong></p>
<ul>
<li>设置<code>vm.swappiness</code>切换到<code>100</code>，系统几乎总是倾向于<code>换出页面</code>，而不是从页面缓存中回收页面。这将使用<code>更多的内存用于页缓存</code>，这可以大大提高I&#x2F;O繁重工作负载的性能，个人理解有更多内存空间用于buff和cache，所以I&#x2F;O。</li>
<li>设置为<code>0</code>将迫使系统尽可能少地进行交换。这可能会使<code>系统响应速度更快</code>，但以牺牲<code>文件系统性能</code>为代价.因为没有更多的内存用过buff和cache,大量的IO操作会造成IO阻塞。</li>
</ul>
<p>这里我们简单温习一下，Linux内核参数如何调整</p>
<p><strong><code>sysctl -a</code> 查看所有内核参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ sysctl -a  <span class="comment"># 查看所有调优参数</span></span><br><span class="line">abi.vsyscall32 = 1</span><br><span class="line">crypto.fips_enabled = 0</span><br><span class="line">debug.exception-trace = 1</span><br><span class="line">debug.kprobes-optimization = 1</span><br><span class="line">debug.panic_on_rcu_stall = 0</span><br><span class="line">dev.hpet.max-user-freq = 64</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>
<p><strong>cat 根据变量找对应参数文件</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ sysctl -a | grep net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.ipv4.ip_forward_use_pmtu = 0</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ <span class="built_in">cd</span> ../net/ipv</span><br><span class="line">ipv4/ ipv6/</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ <span class="built_in">cd</span> ../net/ipv4/</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/net/ipv4]</span><br><span class="line">└─$ cat ip_forward</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>设置内核参数：临时调整</strong></p>
<p><code>/proc </code>目录下的数据是存放在内存中数据，每次重启就没了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ cat swappiness</span><br><span class="line">30</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ <span class="built_in">echo</span> 40 &gt; swappiness  <span class="comment">## 临时调整</span></span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ cat swappiness</span><br><span class="line">40</span><br></pre></td></tr></table></figure>
<p><strong>设置调优参数：永久调整</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ <span class="built_in">echo</span> <span class="string">&quot;vm.swappiness = 20&quot;</span> &gt;&gt;  /etc/sysctl.conf  <span class="comment">## 永久调整</span></span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ sysctl -p</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">vm.swappiness = 20</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>



<p>下面是vm.swappiness 参数修改后vmstat的两个输出示例。</p>
<ul>
<li>第一个图显示了在内存压力下更倾向于交换的系统</li>
<li>第二个图显示了更倾向于收缩页缓存的系统</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/23f71f4521f04f118f9c2ad66b3cb364.png"></p>
<h3 id="交换分区和文件调优"><a href="#交换分区和文件调优" class="headerlink" title="交换分区和文件调优"></a>交换分区和文件调优</h3><p><code>交换分区性能</code>在很大程度上受到<code>交换分区的位置和数量</code>的影响。</p>
<ul>
<li>在旋转的<code>硬盘驱动器(机械硬盘)</code>上，由于<code>ZCAV效应</code>，将交换分区放置在盘片的<code>外缘</code>比将其放置在<code>中心</code>附近将提供更好的吞吐量</li>
<li>在<code>SSD存储(固态硬盘)</code>上放置交换空间可能会由于其较低的延迟和较高的吞吐量而导致更好的性能。</li>
</ul>
<p>需要注意的是，如果您使用SSD作为交换分区，并且交换分区经常使用，那么您应该确保您的设备<code>支持适当的磨损均衡</code>(基于SLC-的存储可能优于基于MLC的存储,SLC的特点是寿命长，同样规格的MLC寿命比SLC要低,性能则相反)否则，设备可能会过早磨损。</p>
<p>使用<code>mkswap</code>创建多个交换空间。它们可能基于<code>磁盘分区</code>或<code>文件</code>。由于内核映射交换文件的方式，只要交换文件没有<code>碎片化</code>，<code>交换文件和交换分区的性能应该大致相似</code></p>
<p><strong>当使用多个交换分区时，可以使用挂载选项<code>pri=value</code>来指定每个空间的使用优先级。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/fstab |grep -i swap|grep -i mpath</span><br><span class="line">/dev/mapper/mpath18        swap                    swap    sw,pri=60        0 0</span><br></pre></td></tr></table></figure>

<ul>
<li>与较低数字的交换分区将首先被填满，然后再移动到较高的数字。通过这种方式，<code>更快的磁盘可以优先于较慢的磁盘</code>。</li>
<li>当以<code>相同的优先级</code>激活多个交换分区时，将以<code>轮询</code>方式使用它们，从而减少每个交换分区的访问次数，从而获得更好的性能。</li>
</ul>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>Linux <code>物理内存需要不时地回收</code>，以防止内存被填满，从而导致系统不可用。</p>
<h3 id="脏内存和非活动内存回收"><a href="#脏内存和非活动内存回收" class="headerlink" title="脏内存和非活动内存回收"></a>脏内存和非活动内存回收</h3><p>在我们了解内存是如何回收的之前，我们必须首先了解<code>内存页可能处于的不同状态</code>。这些不同的状态是:</p>
<ul>
<li><code>Free</code>: 页面可以立即分配，空闲的内存;</li>
<li><code>inactive Clean</code>: 该页处于<code>非活动使用状态</code>，其内容与磁盘上的内容相对应，因为它已经<code>被回写或自读取以来没有更改</code>。</li>
<li><code>inactive Dirty</code>: 该页不是<code>活跃使用</code>，但该页的<code>内容已经被修改</code>，从磁盘读取后，还没有<code>写回</code>。</li>
<li><code>Active</code>: 该页面正在<code>活跃</code>使用中，并且不是被释放的候选页面</li>
</ul>
<p>当需要分配新页面时，标记为 <code>inactive Clean</code> 的页面可以被视为<code>空闲页面</code>，但是如果拥有该页面的<code>进程以后再次需要它</code>，就会发生重大的<code>页面错误</code>。</p>
<p>通过 <code>/proc/meminfo</code> 可以获得系统范围内内存分配的概览。我们可以处理的是<code>Inactive(file)</code>和<code>Dirty</code>:。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/meminfo </span><br><span class="line">MemTotal:       33011552 kB</span><br><span class="line">MemFree:        19579840 kB</span><br><span class="line">MemAvailable:   22517876 kB</span><br><span class="line">Buffers:             304 kB</span><br><span class="line">Cached:          3497240 kB</span><br><span class="line">SwapCached:        35568 kB</span><br><span class="line">Active:          8894452 kB</span><br><span class="line">Inactive:        2717480 kB</span><br><span class="line">Active(anon):    7107136 kB</span><br><span class="line">Inactive(anon):  1869124 kB</span><br><span class="line">Active(file):    1787316 kB</span><br><span class="line">Inactive(file):   848356 kB</span><br><span class="line">....................</span><br><span class="line">Dirty:               716 kB</span><br><span class="line">....................</span><br></pre></td></tr></table></figure>


<ul>
<li><code>Inactive(file)</code>:可以回收而不会对性能产生巨大影响的页面缓存内存,<code>free 命令中 cache 部分的回收</code></li>
<li><code>Dirty</code>:等待写回磁盘的内存,<code>free 命令中 buff 部分的回收</code></li>
</ul>
<p>匿名页面<code>Inactive(anon)</code>(与磁盘上的文件没有关联的那些页面)不能轻易释放，需要将其交换到磁盘以释放它们。</p>
<p><code>Inactive(file)</code>和<code>Dirty</code>的强制回收需要修改内核参数<code>vm.drop_caches = 0</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl  -a | grep drop_caches</span><br><span class="line">vm.drop_caches = 0</span><br></pre></td></tr></table></figure>

<p>手动执行sync命令(sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I&#x2F;O 和读写映射文件)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ cat drop_caches  <span class="comment">#缓存处理</span></span><br><span class="line">0</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ sync</span><br></pre></td></tr></table></figure>
<p>通过执行 <code>echo 3 &gt; /proc/sys/vm/drop_caches</code>的方式清理，具体参数含义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To free pagecache:</span><br><span class="line">	<span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">To free reclaimable slab objects (includes dentries and inodes):</span><br><span class="line">	<span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">To free slab objects and pagecache:</span><br><span class="line">	<span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3935         212        3357          16         366        3440</span><br><span class="line">Swap:         10239           0       10239</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ <span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3935         200        3575          16         159        3504</span><br><span class="line">Swap:         10239           0       10239</span><br><span class="line">┌──[root@liruilongs.github.io]-[/proc/sys/vm]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<h3 id="脏页写入调优"><a href="#脏页写入调优" class="headerlink" title="脏页写入调优"></a>脏页写入调优</h3><p>对于每个进程视图，你可以使用<code>/proc/pid/maps</code>.这个文件详细说明了<code>分配给进程的每个内存段</code>，包括<code>共享</code>&#x2F;<code>私有干净内存</code>和<code>脏内存</code>的大小。为了解析它，我们可以编写一个小的awk程序，如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/$$/smaps | awk  <span class="string">&#x27;/Shared_Clean/&#123;SHCL+=$2&#125;/Shared_Dirty/&#123;SHDT+=$2&#125;/Private_Clean/&#123;PRCL+=$2&#125;/Private_Dirty/&#123;PRDT+=$2&#125;  END&#123; </span></span><br><span class="line"><span class="string">  print &quot;Total Clean:&quot;,SHCL +PRCL  </span></span><br><span class="line"><span class="string">  print &quot;Total Dirty:&quot;,SHDT  +PRDT</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[/dev]</span><br><span class="line">└─$ cat /proc/$$/smaps | awk  <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&gt; /Shared_Clean/&#123;SHCL+=$2&#125;</span></span><br><span class="line"><span class="string">&gt; /Shared_Dirty/&#123;SHDT+=$2&#125;</span></span><br><span class="line"><span class="string">&gt; /Private_Clean/&#123;PRCL+=$2&#125;</span></span><br><span class="line"><span class="string">&gt; /Private_Dirty/&#123;PRDT+=$2&#125;</span></span><br><span class="line"><span class="string">&gt; END&#123;</span></span><br><span class="line"><span class="string">&gt;   print &quot;Total Clean:&quot;,SHCL +PRCL</span></span><br><span class="line"><span class="string">&gt;   print &quot;Total Dirty:&quot;,SHDT  +PRDT</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span></span><br><span class="line">Total Clean: 1808</span><br><span class="line">Total Dirty: 1536</span><br></pre></td></tr></table></figure>
<p>必须将脏页写入磁盘，以防止内存被无法释放的页填满。由于内存是易失的(断电时内容会丢失)，脏页也需要写入磁盘，以防止断电时数据丢失。</p>
<p>在内核中，将脏页写入磁盘是由<code>per-BDI flush</code>线程处理的，这些线程将在必要时创建。<code>Per-BDI flush</code>线程将在进程列表中显示为<code>flush-MAJOR: MINOR</code>。</p>
<p>有几个<code>内核参数</code>控制<code>per-BDI</code>刷新线程何时开始将数据写入磁盘。这样内核就不会因为某个进程修改了另一个字节的内存而连续地多次写入同一个页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ sysctl  -a | grep dirty_</span><br><span class="line">vm.dirty_background_bytes = 0</span><br><span class="line">vm.dirty_background_ratio = 10</span><br><span class="line">vm.dirty_bytes = 0</span><br><span class="line">vm.dirty_expire_centisecs = 3000</span><br><span class="line">vm.dirty_ratio = 20</span><br><span class="line">vm.dirty_writeback_centisecs = 1500</span><br><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$</span><br></pre></td></tr></table></figure>

<p><code>vm.dirty_ratio = 20</code> :<code>产生写操作的进程</code>在<code>整个系统内存</code>中处于脏状态的百分比，是绝对的脏数据限制，内存里的脏数据百分比不能超过这个值，如果<code>超过将阻塞IO直到写出脏页</code>。</p>
<p><code>vm.dirty_background_ratio = 10</code> :<code>系统总内存</code>和脏页的百分比，即内存可以填充“脏数据”的百分比。在这个百分比事开始，内核会在后台开始写数据</p>
<p><code>vm.dirty_bytes = 0</code>，<code>vm.dirty_background_bytes = 0</code> 这两个参数为上面参数的byte单位时的值</p>
<p><code>vm.dirty_expire_centisecs = 3000</code>:脏数据在符合写入磁盘条件之前必须有多旧(以1&#x2F;100秒为单位),即可以存活多久。这样内核就不会因为某个进程修改了一个字节的内存而连续地多次写入同一个页面。</p>
<p><code>vm.dirty_writeback_centisecs = 1500</code>内核唤醒刷新线程<code>pdflush/flush/kdmflush</code>以写入数据的频率(1&#x2F;100秒)。设置为0将完全禁周期性回写</p>
<p>大多数调优配置文件至少修改上述设置之一。调优规则可以遵循下面的策略</p>
<ul>
<li>设置<code>较低</code>的比率将导致<code>更频繁但更短的写操作</code>，这适合<code>交互式系统</code>，</li>
<li>设置<code>较高</code>的比率将导致<code>更少但更大的写操作</code>，导致<code>总体开销更小</code>，但可能导致<code>交互式应用程序</code>的<code>响应时间更长</code>.适合执行非交互的I&#x2F;O任务处理,比如大文件生成之类。</li>
</ul>
<h3 id="内存不足处理和“OOM-killer-内存杀手-”"><a href="#内存不足处理和“OOM-killer-内存杀手-”" class="headerlink" title="内存不足处理和“OOM killer(内存杀手)”"></a>内存不足处理和“OOM killer(内存杀手)”</h3><p>当脏页的数据太多，同时没有可用的页面时，内核试图回收内存来满足请求。如果不能及时回收足够的内存，就会出现内存不足<code>OOM</code>的情况。</p>
<p>对于系统的级别的OOM，默认情况下，系统将启动<code>OOM killer</code>,选择并<code>杀死一个或多个进程以释放内存</code>，以便满足请求。具体的记录日志是在<code>/var/log/messages</code>中，如果出现了<code>Out of memory</code>字样，说明系统曾经出现过OOM,</p>
<p>在Linux内核参数中，我们可以通过<code>vm.panic_on_oom</code>参数来设置遇到OOM的情况，启动<code>OOM killer</code>的策略</p>
<p>如果内核参数<code>sysctl vm.panic_on_oom</code>设置为<code>1而不是0</code>，内核将会发生<code>panic</code>,即直接摆烂，什么时候挂掉算什么时候。默认为0.即自动启动<code>OOM killer</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──[root@liruilongs.github.io]-[~]</span><br><span class="line">└─$ sysctl vm.panic_on_oom</span><br><span class="line">vm.panic_on_oom = 0</span><br></pre></td></tr></table></figure>
<p>出现内存不足的情况，就没有很多合理的恢复选项。终止进程以释放内存、放弃并终止系统或死锁都是可能的选择。</p>
<p>为了确定OOM杀手应该杀死哪个进程，内核为每个进程保持一个运行不良评分，可以在<code>/proc/pid/oom_score</code>中查看。</p>
<p>systemd进程的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-liruilong ~]<span class="comment"># cat /proc/1/oom_score</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>分数越高，进程越有可能被OOM杀手杀死。许多因素被用来计算这个分数:</p>
<ul>
<li>VM大小(不是RSS大小)，</li>
<li>进程所有子进程的累积VM大小，</li>
<li>nice值(正的nice值会给出更高的分数)，</li>
<li>总运行时间(较长的总运行时间会降低分数)，</li>
<li>运行用户(根进程会得到轻微的保护)，</li>
<li>进程执行直接硬件访问，分数也会降低。</li>
<li>内核本身和PID1 (sysemd)是免疫的OOM杀手。</li>
</ul>
<p>可调的<code>/proc/PID/oom_adj</code>可以用来手动调整<code>oom_score</code>。配置该pid进程被oom killer杀掉的<code>权重</code>，<code>oom_adj</code>可以的值从-17到15，其中0表示不改变(默认)，越高的权重，意味着更可能被oom killer选中，-17表示免疫(永远不会杀死)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-liruilong ~]<span class="comment"># cat /proc/1/oom_adj</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>如果你希望强制的执行<code>OOM Killer</code></strong></p>
<p>可以<code>echo f &gt; /proc/sysrq-trigger</code>，但请记住，至少会有一个进程被杀死。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-liruilong ~]<span class="comment"># echo f &gt; /proc/sysrq-trigger</span></span><br><span class="line"></span><br><span class="line">Message from syslogd@ecs-liruilong at Aug  1 14:32:18 ...</span><br><span class="line"> kernel:[340648.118967] Kernel panic - not syncing: Out of memory: system-wide panic_on_oom is enabled</span><br></pre></td></tr></table></figure>
<p>输出将被发送到dmesg。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-liruilong ~]<span class="comment"># cat /var/log/dmesg</span></span><br></pre></td></tr></table></figure>



<h2 id="博文参考"><a href="#博文参考" class="headerlink" title="博文参考"></a>博文参考</h2><hr>
<ul>
<li><a href="">《 Linux性能优化 》</a></li>
<li><a href="#">《 Red Hat Performance Tuning 442 》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/systemd.resource-control.html#">https://www.freedesktop.org/software/systemd/man/systemd.resource-control.html#</a></li>
<li><a target="_blank" rel="noopener" href="https://access.redhat.com/solutions/406773">https://access.redhat.com/solutions/406773</a></li>
<li><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/s2-proc-meminfo">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux&#x2F;6&#x2F;html&#x2F;deployment_guide&#x2F;s2-proc-meminfo</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011677209/article/details/52769225">Linux vm运行参数之(二)：OOM相关的参数: https://blog.csdn.net/u011677209/article/details/52769225</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutimo/article/details/52024487">Linux内核OOM机制的理解: https://blog.csdn.net/zhoutimo/article/details/52024487</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>关于Linux性能调优之内存负载调优</p><p><a href="https://liruilongs.github.io/2022/07/23/rhca/RH442/关于 Linux性能调优之内存负载调优/">https://liruilongs.github.io/2022/07/23/rhca/RH442/关于 Linux性能调优之内存负载调优/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://liruilongs.github.io"><p>山河已无恙</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-07-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2023/11/10/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8-Tuned-%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/" target="_blank">Linux 性能优化之使用 Tuned 配置优化方案</a><br></span><span>  2.<a class="is-size-6" href="/2023/11/09/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E5%86%85%E6%A0%B8%E5%8F%AF%E8%B0%83%E5%8F%82%E6%95%B0/" target="_blank">Linux 性能调优之内核可调参数优化</a><br></span><span>  3.<a class="is-size-6" href="/2023/10/17/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/" target="_blank">Linux 性能调优之资源限制</a><br></span><span>  4.<a class="is-size-6" href="/2023/10/07/rhca/RH442/Linux%20%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/" target="_blank">Linux 性能调优之网络内核参数优化</a><br></span><span>  5.<a class="is-size-6" href="/2023/10/07/%E5%BE%85%E5%8F%91%E5%B8%83/Linux%20%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B9%8B%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/" target="_blank">Linux 性能调优之硬件资源监控</a><br></span><span>  6.<a class="is-size-6" href="/2022/12/06/Linux/What-is-the-difference-between-the-iptables-command-and-iptables-service/" target="_blank">iptables 命令和 iptables.service 服务的区别是上面 ?</a><br></span><span>  7.<a class="is-size-6" href="/2022/12/03/Linux/%E5%85%B3%E4%BA%8E%20Linux%20%E4%B8%AD%20firewalld%20%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/" target="_blank">关于 Linux 中 firewalld 的一些笔记整理</a><br></span><span>  8.<a class="is-size-6" href="/2022/10/03/%E5%BE%85%E5%8F%91%E5%B8%83/%E3%80%8ALinux-Basics-for-Hackers-Getting-Started-with-Networking-Scripting-and-Security-in-Kali-%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Linux Basics for Hackers：Getting Started with Networking, Scripting, and Security in Kali 》读书笔记</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br><span>  1.<a class="is-size-6" href="/2021/08/27/K8s/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BB%8EDocker%E5%88%B0Kubernetes%E5%AE%9E%E8%B7%B5%E5%85%A8%E6%8E%A5%E8%A7%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank">《Kubernetes权威指南:从Docker到Kubernetes实践全接触》读书笔记</a><br></span><span>  2.<a class="is-size-6" href="/2023/06/17/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/AdaFace%EF%BC%9A-%E9%80%9A%E8%BF%87AdaFace%E5%AE%9E%E7%8E%B0%E4%BD%8E%E8%B4%A8%E9%87%8F%E9%9D%A2%E9%83%A8%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%B2%BE%E5%87%86%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" target="_blank">AdaFace(CVPR(2022))：通过AdaFace实现低质量面部数据集的人脸识别</a><br></span><span>  3.<a class="is-size-6" href="/2023/05/04/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/DeepFace%EF%BC%9A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%93%20DeepFace%20%E7%AE%80%E5%8D%95%E8%AE%A4%E7%9F%A5/" target="_blank">DeepFace：人脸识别库 DeepFace 简单认知</a><br></span><span>  4.<a class="is-size-6" href="/2023/07/24/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E4%BD%BF%E7%94%A8-OpenCV-%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A%E5%BA%A6%E6%A3%80%E6%B5%8B-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E5%B7%AE%E6%96%B9%E6%B3%95/" target="_blank">使用 OpenCV 进行图像模糊度检测(拉普拉斯方差方法)</a><br></span><span>  5.<a class="is-size-6" href="/2023/06/15/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/Nvidia%203060%20%E6%98%BE%E5%8D%A1%20CUDA%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(Ubuntu22.04+Nvidia%20510+Cuda11.6+cudnn8.8)/" target="_blank">Nvidia 3060 显卡 CUDA 环境搭建(Ubuntu22.04+Nvidia 510+Cuda11.6+cudnn8.8)</a><br></span><span>  6.<a class="is-size-6" href="/2023/05/17/AI&amp;%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/%E5%85%B3%E4%BA%8EOpenCv%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%8C%85-imutils-%E7%AE%80%E5%8D%95%E8%AE%A4%E7%9F%A5/" target="_blank">关于 OpenCV 图像处理工具包 imutils 简单认知</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay%EF%BF%A5.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat%EF%BF%A5.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/07/26/Git/%E5%85%B3%E4%BA%8EGit%E5%88%86%E6%94%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">关于Git分支基础知识的一些笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/07/16/Java/%E5%85%B3%E4%BA%8E%20Java&amp;JavaScript%E4%B8%ADStream%E5%BC%8FAPI%E5%AF%B9%E6%AF%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/"><span class="level-item">关于Java&amp;JavaScript中(伪)Stream式API对比的一些笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '3e8ec9ea25881acd1244151ce7a63793',
            repo: 'blog_comment',
            owner: 'LIRUILONGS',
            clientID: '9fdc9739266d48d5f62e',
            clientSecret: 'c1cc33697d099a2197650ec9dadcb16bd4904655',
            admin: ["LIRUILONGS"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#写在前面"><span class="mr-2">1</span><span>写在前面</span></a></li><li><a class="is-flex is-mobile" href="#内存管理"><span class="mr-2">2</span><span>内存管理</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex is-mobile" href="#交换分区-物理内存不足"><span class="mr-2">2.1.1</span><span>交换分区(物理内存不足)</span></a></li><li><a class="is-flex is-mobile" href="#缓冲区-buffer"><span class="mr-2">2.1.2</span><span>缓冲区(buffer)</span></a></li><li><a class="is-flex is-mobile" href="#活跃与非活跃内存"><span class="mr-2">2.1.3</span><span>活跃与非活跃内存</span></a></li><li><a class="is-flex is-mobile" href="#内核的内存使用情况-分片"><span class="mr-2">2.1.4</span><span>内核的内存使用情况(分片)</span></a></li></ul><li><a class="is-flex is-mobile" href="#进程内存"><span class="mr-2">2.2</span><span>进程内存</span></a></li><li><a class="is-flex is-mobile" href="#使用cgroups限制内存"><span class="mr-2">2.3</span><span>使用cgroups限制内存</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#找到内存泄漏"><span class="mr-2">3</span><span>找到内存泄漏</span></a></li><li><a class="is-flex is-mobile" href="#交换空间调优"><span class="mr-2">4</span><span>交换空间调优</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#调整内核交换的方式"><span class="mr-2">4.1</span><span>调整内核交换的方式</span></a></li><li><a class="is-flex is-mobile" href="#交换分区和文件调优"><span class="mr-2">4.2</span><span>交换分区和文件调优</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#内存回收"><span class="mr-2">5</span><span>内存回收</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#脏内存和非活动内存回收"><span class="mr-2">5.1</span><span>脏内存和非活动内存回收</span></a></li><li><a class="is-flex is-mobile" href="#脏页写入调优"><span class="mr-2">5.2</span><span>脏页写入调优</span></a></li><li><a class="is-flex is-mobile" href="#内存不足处理和“OOM-killer-内存杀手-”"><span class="mr-2">5.3</span><span>内存不足处理和“OOM killer(内存杀手)”</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#博文参考"><span class="mr-2">6</span><span>博文参考</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class=""><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg" alt="山河已无恙"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">山河已无恙</p><p class="is-size-6 is-block">爱自己，是终生浪漫的开始</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国·呼和浩特</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">318</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">102</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">153</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LIRUILONGS"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="CSDN" href="https://liruilong.blog.csdn.net/"><i class="fa fa-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1224965096@qq.com"><i class="fa fa-envelope"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://liruilong.blog.csdn.net/?t=1&amp;type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">liruilong.blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/liruilong/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://github.com/LIRUILONGS" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Githup</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://gitee.com/liruilonger" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">码云</span></span><span class="level-right"><span class="level-item tag">gitee.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-19T19:40:00.000Z">2023-11-20</time></p><p class="title"><a href="/2023/11/20/%E5%BE%85%E5%8F%91%E5%B8%83/Golang%20VScode%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">Golang VScode 开发环境搭建</a></p><p class="categories"><a href="/categories/GO/">GO</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-15T12:44:37.000Z">2023-11-15</time></p><p class="title"><a href="/2023/11/15/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%9F%BA%E4%BA%8E%20selenium%20%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87%E9%87%87%E9%9B%86/">基于 selenium 实现网站图片采集</a></p><p class="categories"><a href="/categories/selenium/">selenium</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-13T20:29:38.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/%E5%BE%85%E5%8F%91%E5%B8%83/%E5%85%B3%E4%BA%8E-Kubernetes%E4%B8%ADAdmission-Controllers-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/">关于 Kubernetes中Admission Controllers(准入控制器) 认知的一些笔记</a></p><p class="categories"><a href="/categories/Kubernetes/">Kubernetes</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-13T19:52:18.000Z">2023-11-14</time></p><p class="title"><a href="/2023/11/14/%E5%BE%85%E5%8F%91%E5%B8%83/K8s%20Pod%20%E5%88%9B%E5%BB%BA%E5%9F%8B%E7%82%B9%E5%A4%84%E7%90%86(Mutating%20%20Admission%20Webhook)/">K8s Pod 创建埋点处理(Mutating  Admission Webhook)</a></p><p class="categories"><a href="/categories/test3/">test3</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-09T18:55:27.000Z">2023-11-10</time></p><p class="title"><a href="/2023/11/10/%E5%BE%85%E5%8F%91%E5%B8%83/Linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8-Tuned-%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">Linux 性能优化之使用 Tuned 配置优化方案</a></p><p class="categories"><a href="/categories/Linux/">Linux</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/AdaFace/"><span class="level-start"><span class="level-item">AdaFace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ajax/"><span class="level-start"><span class="level-item">Ajax</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ansible/"><span class="level-start"><span class="level-item">Ansible</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/AppCube/"><span class="level-start"><span class="level-item">AppCube</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Bind9/"><span class="level-start"><span class="level-item">Bind9</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CI-CD/"><span class="level-start"><span class="level-item">CI/CD</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CSS/"><span class="level-start"><span class="level-item">CSS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Ceph/"><span class="level-start"><span class="level-item">Ceph</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DAD-3DHeads/"><span class="level-start"><span class="level-item">DAD-3DHeads</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DNS/"><span class="level-start"><span class="level-item">DNS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/08/"><span class="level-start"><span class="level-item">八月 2023</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag is-grey-lightest">91</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">34</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ansible/"><span class="tag">Ansible</span><span class="tag is-grey-lightest">25</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ceph/"><span class="tag">Ceph</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JAVA/"><span class="tag">JAVA</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenShift/"><span class="tag">OpenShift</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"><span class="tag">程序人生</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DNS/"><span class="tag">DNS</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OKD/"><span class="tag">OKD</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/selenium/"><span class="tag">selenium</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%B9%E5%99%A8/"><span class="tag">容器</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CKA/"><span class="tag">CKA</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GO/"><span class="tag">GO</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ISCSI/"><span class="tag">ISCSI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NFS/"><span class="tag">NFS</span><span class="tag is-grey-lightest">3</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="山河已无恙" height="28"></a><p class="size-small"><span>&copy; 2024 山河已无恙</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">备案号</a><br></span><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2021/6/26 21:27:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.css"><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/katex.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/KaTeX/0.11.1/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.loli.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('9fdc9739266d48d5f62e','c1cc33697d099a2197650ec9dadcb16bd4904655','LIRUILONGS','blog_comment',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>